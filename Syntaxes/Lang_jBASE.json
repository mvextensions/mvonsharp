{
    "Language": {
        "Type": "jBASE PickBASIC",
        "Keywords": [
            {
                "key": "$append",
                "icon": 3,
                "documentation": "The $append() method allows you to add (append) a value to the end of an array.",
                "detail": "\\$append($value)",
                "snippet": "$append(${1:value})"
            },
            {
                "key": "$classname",
                "icon": 3,
                "documentation": "The $classname() method returns the name of the class as a text string.",
                "detail": "\\$classname()",
                "snippet": "$classname()"
            },
            {
                "key": "$clear",
                "icon": 3,
                "documentation": "The $clear() method clears (deletes) all the members (properties) from an object leaving the object void.",
                "detail": "\\$clear()",
                "snippet": "$clear()"
            },
            {
                "key": "$clone",
                "icon": 3,
                "documentation": "The $clone() method creates an exact copy of an existing object. Making any changes to the original object does not affect the cloned object, and vice versa. The cloned object contains all nested objects and arrays.",
                "detail": "\\$clone()",
                "snippet": "$clone()"
            },
            {
                "key": "$delete",
                "icon": 3,
                "documentation": "The $delete() method deletes a property from an object or array.",
                "detail": "\\$delete($property_name)",
                "snippet": "$delete(${1:property_name})"
            },
            {
                "key": "$dump",
                "icon": 3,
                "documentation": "The $dump() method displays the internal contents of an object.",
                "detail": "\\$dump($mode)",
                "snippet": "$dump(${1:mode})"
            },
            {
                "key": "$equals",
                "icon": 3,
                "documentation": "The $equals(), or $equal(), method tests if two objects or arrays are equal.  For objects, the properties can be in any order but the properties and their values must be the same in both objects.  For arrays, they must be absolutely equal. If you have the same values in both arrays, but in different positions, they will not be considered equal. All nested objects and arrays are compared.",
                "detail": "\\$equals($var)",
                "snippet": "$equals(${1:var})"
            },
            {
                "key": "$fromfile",
                "icon": 3,
                "documentation": "The $fromfile() static method creates an object from an operating system file. The file must be in a valid JSON format.",
                "detail": "\\$fromfile($path)",
                "snippet": "$fromfile(${1:path})"
            },
            {
                "key": "$fromjson",
                "icon": 3,
                "documentation": "The $fromjson() method converts a valid JSON string to an object. This is the complement of the $tojson() method.",
                "detail": "\\$fromjson()",
                "snippet": "$fromjson()"
            },
            {
                "key": "$insert",
                "icon": 3,
                "documentation": "The $insert() method inserts a value before a specified position in an array.",
                "detail": "\\$insert($value, $position)",
                "snippet": "$insert(${1:value}, ${2:position})"
            },
            {
                "key": "$isfile",
                "icon": 3,
                "documentation": "The $isfile() method is used to determine if a variable is a file variable.",
                "detail": "\\$isfile()",
                "snippet": "$isfile()"
            },
            {
                "key": "$ismethod",
                "icon": 3,
                "documentation": "The $ismethod() method is used to determine if a method exists for a specific class.",
                "detail": "\\$ismethod($method_name)",
                "snippet": "$ismethod(${1:method_name})"
            },
            {
                "key": "$isobject",
                "icon": 3,
                "documentation": "The $isobject() method is used to determine if a variable is an object or array.",
                "detail": "\\$isobject()",
                "snippet": "$isobject()"
            },
            {
                "key": "$isproperty",
                "icon": 3,
                "documentation": "The $isproperty() method is used to determine if a variable is a property of an object or array.",
                "detail": "\\$isproperty($property_name)",
                "snippet": "$isproperty(${1:property_name})"
            },
            {
                "key": "$keys",
                "icon": 3,
                "documentation": "The $keys() method will return an array of all the key values from an object.  This method is intended to be compatible with the JavaScript keys() method, but with a small syntax enhancement. The functionality created with $keys() can easily be replicated using iterators and the $iterate() class, but this provides some compatibility for those more familiar with JavaScript.",
                "detail": "\\$keys($1)",
                "snippet": "$keys($1)"
            },
            {
                "key": "$lasterror",
                "icon": 3,
                "documentation": "The $lasterror method returns an object with the results of a $fromjson() method call, and since it is an object its properties can be accessed.",
                "detail": "\\$lasterror()",
                "snippet": "$lasterror()"
            },
            {
                "key": "$locate",
                "icon": 3,
                "documentation": "The $locate() method is used to find an value in a Dynamic Objects array, optionally specifying a case insensitive search.",
                "detail": "\\$locate($value)",
                "snippet": "$locate(${1:value})"
            },
            {
                "key": "$merge",
                "icon": 3,
                "documentation": "The $merge() method combines (concatenates) one array with another array.",
                "detail": "\\$merge($array)",
                "snippet": "$merge(${1:array})"
            },
            {
                "key": "$merge",
                "icon": 3,
                "documentation": "The $merge() method combines (merges) one object into another object, optionally specifying which object takes precedence if both objects contain  the same properties.",
                "detail": "\\$merge($obj, $precedence)",
                "snippet": "$merge(${1:obj}, ${2:precedence})"
            },
            {
                "key": "$objecttype",
                "icon": 3,
                "documentation": "The $objecttype() method returns the type of the object.",
                "detail": "\\$objecttype()",
                "snippet": "$objecttype()"
            },
            {
                "key": "$prepend",
                "icon": 3,
                "documentation": "The $prepend() method allows you to insert a new value at the beginning of the array.",
                "detail": "\\$prepend($value)",
                "snippet": "$prepend(${1:value})"
            },
            {
                "key": "$refcount",
                "icon": 3,
                "documentation": "The $refcount() method returns the number of variables that reference the same object.",
                "detail": "\\$refcount()",
                "snippet": "$refcount()"
            },
            {
                "key": "$setboolean",
                "icon": 3,
                "documentation": "The $setboolean() method allows you to create boolean values in JSON output that wouldn't normally be supported by native jBASE data types.",
                "detail": "\\$setboolean($property_name_or_index, $boolean)",
                "snippet": "$setboolean(${1:property_name_or_index}, ${2:boolean})"
            },
            {
                "key": "$setnull",
                "icon": 3,
                "documentation": "The $setnull() method sets a value to null in an object or an array. These null values can only be used in JSON output that wouldn't normally be supported by native jBASE data types.",
                "detail": "\\$setnull($property_name_or_index)",
                "snippet": "$setnull(${1:property_name_or_index})"
            },
            {
                "key": "$setserialize",
                "icon": 3,
                "documentation": "The $setserialize() method provides a limited amount of control over a serialized object when a character string is required and a dynamic object is the source. The object is serialized to a JSON string.",
                "detail": "\\$setserialize($1)",
                "snippet": "$setserialize($1)"
            },
            {
                "key": "$size",
                "icon": 3,
                "documentation": "The $size() method returns the number of properties in an object or the number of values in an array.",
                "detail": "\\$size()",
                "snippet": "$size()"
            },
            {
                "key": "$sort",
                "icon": 3,
                "documentation": "The $sort() method sorts the properties in an object, optionally specifying sort sequence.",
                "detail": "\\$sort($sequence)",
                "snippet": "$sort(${1:sequence})"
            },
            {
                "key": "$tojson",
                "icon": 3,
                "documentation": "The $tojson() method converts an object to a JSON string and optionally formats the string in a number of ways. This is the complement of the $fromjson() method.",
                "detail": "\\$tojson($format)",
                "snippet": "$tojson(${1:format})"
            },
            {
                "key": "$valuetype",
                "icon": 3,
                "documentation": "The $valuetype() method returns type of an object's property.",
                "detail": "\\$valuetype($property_name)",
                "snippet": "$valuetype(${1:property_name})"
            },
            {
                "key": "$Include",
                "icon": 14,
                "documentation": "The $INCLUDE or $INSERT directive inserts the program\/code snippet specified into the current source code. If the optional filename is specified the code is read from that file.",
                "detail": "$INCLUDE programname\n$INCLUDE filename programname\n$INSERT programname\n$INSERT filename programname",
                "snippet": "$INCLUDE ${1:programname}"
            },
            {
                "key": "@Am",
                "icon": 21,
                "documentation": "Inserts an attribute mark CHAR(254).",
                "detail": "@AM"
            },
            {
                "key": "@Account",
                "icon": 21,
                "documentation": "Returns the name of the current jBASE user account.",
                "detail": "@ACCOUNT"
            },
            {
                "key": "@Application.Id",
                "icon": 21,
                "documentation": "@ID Dataname used to reference the record-id in a query language statement.",
                "detail": "@APPLICATION.ID"
            },
            {
                "key": "@Callstack",
                "icon": 21,
                "documentation": "For DEBUG purposes - returns the callstack if used in a subroutine.",
                "detail": "@CALLSTACK"
            },
            {
                "key": "@Codepage",
                "icon": 21,
                "documentation": "Returns the current JBASE_CODEPAGE setting when in I18N mode.",
                "detail": "@CODEPAGE"
            },
            {
                "key": "@Command",
                "icon": 21,
                "documentation": "See @SENTENCE.",
                "detail": "@COMMAND"
            },
            {
                "key": "@CR",
                "icon": 21,
                "documentation": "Inserts a carriage return CHAR(13).",
                "detail": "@CR"
            },
            {
                "key": "@Data",
                "icon": 21,
                "documentation": "Returns the data stack or input queue.",
                "detail": "@DATA"
            },
            {
                "key": "@Date",
                "icon": 21,
                "documentation": "Returns the internal date \u2013 on some systems, this differs from the DATE function in that the variable is set when program execution starts, whereas the function reflects the current date.",
                "detail": "@DATE"
            },
            {
                "key": "@Day",
                "icon": 21,
                "documentation": "Returns the day of the month from @DATE.",
                "detail": "@DAY"
            },
            {
                "key": "@Eof",
                "icon": 21,
                "documentation": "Returns the End of File character from the TTY characteristics.",
                "detail": "@EOF"
            },
            {
                "key": "@Esc",
                "icon": 21,
                "documentation": "Inserts a escape character CHAR(27).",
                "detail": "@ESC"
            },
            {
                "key": "@False",
                "icon": 21,
                "documentation": "Inserts a zero.",
                "detail": "@FALSE"
            },
            {
                "key": "@Ff",
                "icon": 21,
                "documentation": "Inserts a form feed chacater for printing CHAR(12).",
                "detail": "@FF"
            },
            {
                "key": "@Filename",
                "icon": 21,
                "documentation": "Returns the current filename, used in I-types.",
                "detail": "@FILENAME"
            },
            {
                "key": "@Fm",
                "icon": 21,
                "documentation": "Inserts an attribute\/field mark CHAR(254).",
                "detail": "@FM"
            },
            {
                "key": "@Id",
                "icon": 21,
                "documentation": "Returns the current Item ID, used in I-types.",
                "detail": "@ID"
            },
            {
                "key": "@Im",
                "icon": 21,
                "documentation": "Inserts an item mark CHAR(255).",
                "detail": "@IM"
            },
            {
                "key": "@Level",
                "icon": 21,
                "documentation": "Returns the EXECUTE nesting level.",
                "detail": "@LEVEL"
            },
            {
                "key": "@Lf",
                "icon": 21,
                "documentation": "Inserts a line feed CHAR(10).",
                "detail": "@LF"
            },
            {
                "key": "@Locale",
                "icon": 21,
                "documentation": "Returns the current JBASE_LOCALE setting.",
                "detail": "@LOCALE"
            },
            {
                "key": "@Logname",
                "icon": 21,
                "documentation": "Returns the current operating system user name.",
                "detail": "@LOGNAME"
            },
            {
                "key": "@Lptrhigh",
                "icon": 21,
                "documentation": "Returns the number of lines on the device to which you are printing (terminal or printer).",
                "detail": "@LPTRHIGH"
            },
            {
                "key": "@Month",
                "icon": 21,
                "documentation": "Returns the number of the current month from @DATE.",
                "detail": "@MONTH"
            },
            {
                "key": "@Parasentence",
                "icon": 21,
                "documentation": "The last sentence or paragraph that invoked the current process.",
                "detail": "@PARASENTENCE"
            },
            {
                "key": "@Path",
                "icon": 21,
                "documentation": "Current working directory.",
                "detail": "@PATH"
            },
            {
                "key": "@Pid",
                "icon": 21,
                "documentation": "Current Process ID.",
                "detail": "@PID"
            },
            {
                "key": "@Record",
                "icon": 21,
                "documentation": "Returns the current record, used in I-types.",
                "detail": "@RECORD"
            },
            {
                "key": "@Rm",
                "icon": 21,
                "documentation": "Inserts a record mark CHAR(255).",
                "detail": "@TM"
            },
            {
                "key": "@Selected",
                "icon": 21,
                "documentation": "Returns the item count from the active select.",
                "detail": "@SELECTED"
            },
            {
                "key": "@Sentence",
                "icon": 21,
                "documentation": "The last sentence or paragraph that invoked the current process.",
                "detail": "@SENTENCE"
            },
            {
                "key": "@Sm",
                "icon": 21,
                "documentation": "Inserts a subvalue mark CHAR(252).",
                "detail": "@SM"
            },
            {
                "key": "@Svm",
                "icon": 21,
                "documentation": "Inserts a subvalue mark CHAR(252).",
                "detail": "@SVM"
            },
            {
                "key": "@Tab",
                "icon": 21,
                "documentation": "Inserts a tab character CHAR(9).",
                "detail": "@TAB"
            },
            {
                "key": "@Time",
                "icon": 21,
                "documentation": "Returns the current time in internal format.",
                "detail": "@TIME"
            },
            {
                "key": "@Timezone",
                "icon": 21,
                "documentation": "Returns the current JBASE_TIMEZONE setting.",
                "detail": "@TIMEZONE"
            },
            {
                "key": "@Tm",
                "icon": 21,
                "documentation": "Inserts a text mark CHAR(251).",
                "detail": "@TM"
            },
            {
                "key": "@True",
                "icon": 21,
                "documentation": "Inserts a one.",
                "detail": "@TRUE"
            },
            {
                "key": "@Tty",
                "icon": 21,
                "documentation": "Returns the current terminal device.",
                "detail": "@TTY"
            },
            {
                "key": "@Udtno",
                "icon": 21,
                "documentation": "Returns the current jBASE port number.",
                "detail": "@UDTNO"
            },
            {
                "key": "@Uid",
                "icon": 21,
                "documentation": "Returns the operating system user ID.",
                "detail": "@UID"
            },
            {
                "key": "@User",
                "icon": 21,
                "documentation": "Returns the operating system login name.",
                "detail": "@USER"
            },
            {
                "key": "@Userno",
                "icon": 21,
                "documentation": "Returns the jBASE port number.",
                "detail": "@USERNO"
            },
            {
                "key": "@Userstats",
                "icon": 21,
                "documentation": "Returns the current user statistics.",
                "detail": "@USERSTATS"
            },
            {
                "key": "@Vm",
                "icon": 21,
                "documentation": "Inserts a value mark CHAR(253).",
                "detail": "@VM"
            },
            {
                "key": "@Who",
                "icon": 21,
                "documentation": "Returns the name of the current jBASE account name.",
                "detail": "@WHO"
            },
            {
                "key": "@Year",
                "icon": 21,
                "documentation": "Returns the current two-digit year number.",
                "detail": "@YEAR"
            },
            {
                "key": "Abort",
                "icon": 14,
                "documentation": "The ABORT statement terminates the running program as well as the program that called it. The optional message.number provided with the statement must be a numeric value, which corresponds to a record key in the jBASE error message file. A single expression or a list of expression(s) may follow the message.number. Where more than one expression is listed, they must be delimited by use of the comma character. The expression(s) correspond to the parameters that need to be passed to the error file record to print it. The optional message.number and expression(s) given with the command are parameters or resultants provided as variables, literal strings, expressions, or functions.",
                "detail": "ABORT {message.number{, expression ...}}",
                "snippet": "ABORT ${1:messagenum}, ${2:expression}"
            },
            {
                "key": "Abs",
                "icon": 3,
                "documentation": "The ABS function will return the mathematical absolute of the ()expression. expression can be an expression of any form that should evaluate to a numeric. The ABS function will then return the mathematical absolute of the expression. This will convert any negative number into a positive result.",
                "detail": "ABS(expression)",
                "snippet": "ABS(${1:math_expression})"
            },
            {
                "key": "Abss",
                "icon": 3,
                "documentation": "Use the ABSS function to return the absolute values of all the elements in a dynamic array. If an element in the dynamic array is null, it returns null for that element.",
                "detail": "ABSS(dynamic array)",
                "snippet": "ABSS(${1:DynArr})"
            },
            {
                "key": "Adds",
                "icon": 3,
                "documentation": "The ADDS function returns a dynamic array, the content of which is derived by adding corresponding elements from two dynamic arrays supplied as arguments. DynArr1 and DynArr2 represent dynamic arrays.",
                "detail": "ADDS(DynArr1, DynArr2)",
                "snippet": "ADDS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Alpha",
                "icon": 3,
                "documentation": "The ALPHA function will check that the expression consists entirely of alphabetic characters. The expression can return a result of any type. The ALPHA function will then return TRUE (1) if the expression consists entirely of alphabetic characters. If any character in expression is non alphabetic then the function returns FALSE (0).",
                "detail": "ALPHA(expression)",
                "snippet": "ALPHA(${1:value})"
            },
            {
                "key": "Ands",
                "icon": 3,
                "documentation": "Use the ANDS function to create a dynamic array of the logical AND of corresponding elements from two dynamic arrays. Each element of the new dynamic array is the logical AND of the corresponding elements of array1 and array2. If an element of one dynamic array has no corresponding element in the other dynamic array, it returns a false (0) for that element. If both corresponding elements of array1 and array2 are null, it returns null for those elements. If one element is a null value and the other is zero or an empty string, it returns false for those elements.",
                "detail": "ANDS(Array1, Array2)",
                "snippet": "ANDS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Ascii",
                "icon": 3,
                "documentation": "The ASCII function converts all the characters in the expression from the EBCDIC character set to the ASCII character set. The expression may return a data string of any form. The function will then assume that the characters are all members of the EBCDIC character set and translate them using a character map. The original expression is unchanged while the returned result of the function is now the ASCII equivalent.",
                "detail": "ASCII(expression)",
                "snippet": "ASCII(${1:expression})"
            },
            {
                "key": "Assigned",
                "icon": 3,
                "documentation": "The ASSIGNED function returns a Boolean TRUE or FALSE result depending on whether a variable has been assigned a value or not. ASSIGNED returns TRUE if the variable named has been assigned a value before the execution of this statement. If the variable has never been assigned a value then the function returns FALSE.",
                "detail": "ASSIGNED(variable)",
                "snippet": "ASSIGNED(${1:variable})"
            },
            {
                "key": "Begin Case",
                "icon": 14,
                "documentation": "The CASE structure is bounded by the BEGIN CASE and END CASE statements.",
                "detail": "BEGIN CASE\n\tCASE $1\n\t$2\nEND CASE",
                "snippet": "BEGIN CASE\n\tCASE $1\n\t$2\nEND CASE"
            },
            {
                "key": "Bitand",
                "icon": 3,
                "documentation": "Use the BITAND function to perform the bitwise AND comparison of two integers specified by numeric expressions The bitwise AND operation compares two integers bit by bit. It returns a bit of 1 if both bits are 1; else, it returns a bit of 0. If either expression1 or expression2 evaluates to a null value, null is returned. Non integer values are truncated before the operation is performed. The BITAND operation is performed on a 32-bit twos-complement word.",
                "detail": "BITAND(expression1, expression2)",
                "snippet": "BITAND(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Bitchange",
                "icon": 3,
                "documentation": "BITCHANGE toggles the state of a specified bit in the local bit table, and return the original value of the bit.  table_no specifies the position in the table of the bit to be changed. A unique table of 128 bits (numbered 1 to 128) is maintained for each process. Each bit in the table is treated as a two-state flag - the value returned will always be 0 (zero) or 1. BITCHANGE returns the value of the bit before it was changed. It is therefore possible to check and set (or reset) a flag in one step. Some special functions ara available if one of the following table_no values is used:r -1 toggles (enables\/disables) the BREAK key Inhibit bit. -2 toggles (enables\/disables) the Command Level Restart feature. -3 toggles (enables\/disables) the Break\/End Restart feature.",
                "detail": "BITCHANGE(table_no)",
                "snippet": "BITCHANGE(${1:tableno})"
            },
            {
                "key": "Bitcheck",
                "icon": 3,
                "documentation": "BITCHECK returns the current value of a specified bit from the local bit table. table_no specifies the position in the table of the bit to be checked. A unique table of 128 bits (numbered 1 to 128) is maintained for each process. Each bit in the table is treated as a two-state flag - the value returned will always be 0 (zero) or 1. BITCHECK also provides some special functions if one of the following table_no values is used: -1 returns the setting of the BREAK key Inhibit bit. -2 returns the setting of the Command Level Restart feature. -3 returns the setting of the Break\/End Restart feature.",
                "detail": "BITCHECK(table_no)",
                "snippet": "BITCHECK(${1:tableno})"
            },
            {
                "key": "Bitload",
                "icon": 3,
                "documentation": "BITLOAD assigns all values in the local bit table, or retrieves all the values.bit-string is an ASCII string of characters which represent a hexadecimal value. It is interpreted as a bit pattern and used to assign values to the table from left to right. Assignment stops at the end of the string or when a non-hexadecimal character is found. If the string represents less than 128 bits, the remaining bits in the table are reset to 0 (zero). If bit-string is omitted or evaluates to null, an ASCII hex character string is returned, which defines the value of the table. Trailing zeroes in the string are truncated.",
                "detail": "BITLOAD(bit_string)",
                "snippet": "BITLOAD(${1:bitstring})"
            },
            {
                "key": "Bitnot",
                "icon": 3,
                "documentation": "BITNOT returns the bitwise negation of an integer specified by any numeric expression. If expression evaluates to the null value, null is returned. If bit# evaluates to the null value, the BITNOT function fails and the program terminates with a run-time error message. Non integer values are truncated before the operation is performed.",
                "detail": "BITNOT(expression, bit#)",
                "snippet": "BITNOT(${1:expression}, ${2:bitnum})"
            },
            {
                "key": "Bitor",
                "icon": 3,
                "documentation": "BITOR performs the bitwise OR comparison of two integers specified by numeric expressions. The bitwise OR operation compares two integers bit by bit. It returns the bit 1 if the bit in either or both numbers is 1; else, it returns the bit 0. If either expression1 or expression2 evaluates to the null value, null is returned. Non integer values are truncated before the operation is performed.",
                "detail": "BITOR(expression1, expression2)",
                "snippet": "BITOR(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Bitreset",
                "icon": 3,
                "documentation": "BITRESET resets the value of a specified bit in the local bit table to 0 and returns the value of the bit before it was changed. table_no specifies the position in the table of the bit to be reset. If table_no evaluates to zero, all elements in the table are reset to 0 (zero) and the returned value is zero. A unique table of 128 bits (numbered 1 to 128) is maintained for each process. Each bit in the table is treated as a two-state flag - the value returned will always be 0 (zero) or 1.",
                "detail": "BITRESET(table_no)",
                "snippet": "BITRESET(${1:tableno})"
            },
            {
                "key": "Bitset",
                "icon": 3,
                "documentation": "BITSET sets the value of a specified bit in the bit table to 1 and returns the value of the bit before it was changed. table_no specifies the bit to be SET. If table_no evaluates to zero, all elements in the table are set to 1 (one) and the returned value is one. A unique table of 128 bits (numbered 1 to 128) is maintained for each process. Each bit in the table is treated as a two-state flag - the value returned will always be 0 (zero) or 1.",
                "detail": "BITSET(table_no)",
                "snippet": "BITSET(${1:tableno})"
            },
            {
                "key": "Bittest",
                "icon": 3,
                "documentation": "BITTEST tests the bit number of the integer specified by an expression. The function returns 1 if the bit is set; it returns 0 if it is not; Bits are counted from right to left. The number of the rightmost bit is 0. If expression evaluates to the null value, null is returned. If bit# evaluates to null, the BITTEST function fails and the program terminates with a run-time error message. Non integer values are truncated before the operation is performed.",
                "detail": "BITTEST(expression, bit#)",
                "snippet": "BITTEST(${1:expression}, ${2:bitnum})"
            },
            {
                "key": "Bitxor",
                "icon": 3,
                "documentation": "BITXOR performs the bitwise XOR comparison of two integers specified by numeric expressions. The bitwise XOR operation compares two integers bit by bit. It returns a bit 1 if only one of the two bits is 1; else, it returns a bit 0. If either expression1 or expression2 evaluates to the null value, null is returned. Non integer values are truncated before the operation is performed.",
                "detail": "BITXOR(expression1, expression2)",
                "snippet": "BITXOR(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Break",
                "icon": 14,
                "documentation": "The BREAK statement allows the break key to be configured. When used with an expression, or the keywords ON or OFF the BREAK statement enables or disables the BREAK key for the current process. In UNIX terms the BREAK key is more commonly known as the interrupt sequence intr defined by the stty command. Used as a standalone statement, BREAK will terminate the currently executing loop. The EXIT statement is functionally equivalent to the BREAK statement used without arguments.",
                "detail": "BREAK\nBREAK ON\nBREAK OFF\nBREAK expression",
                "snippet": "BREAK $1"
            },
            {
                "key": "Bytelen",
                "icon": 3,
                "documentation": "The BYTELEN function  will return the length of the expression as the number of bytes rather than the number of characters. The expression can return a result of any type. The BYTELEN function will then return the byte count of the expression.",
                "detail": "BYTELEN(expression)",
                "snippet": "BYTELEN(${1:expression})"
            },
            {
                "key": "Call",
                "icon": 14,
                "documentation": "The CALL statement transfers program execution to the subroutine called subroutine.name, which can be any valid string either quoted or unquoted. The CALL @ variant of this statement assumes that subroutine.name is a variable that contains the name of the subroutine to call. The CALL statement may optionally pass a number of parameters to the target subroutine. These parameters can consist of any valid expression or variable name. If a variable name is used then the called program may return a value to the variable by changing the value of the equivalent variable in its own parameter list.",
                "detail": "CALL {@}subroutine.name {(argument {, argument ... })}",
                "snippet": "CALL ${1:subroutine_name}(${2:arguments})"
            },
            {
                "key": "Callc",
                "icon": 14,
                "documentation": "The CALLC statement is used to invoke user supplied C functions compiled and built into standard libraries. Cfunction must correspond to a valid C function name in an associated C source. argument must correspond to a valid variable name Variable must correspond to a valid variable name which contains the name of the C function to invoke. The indirect, '@', form of the statement expects the specified variable to contain the name of the 'C' function to be invoked. All arguments to be passed to and from the calling program to the 'C' function must be of type VAR and the 'C' function coded accordingly, the 'C' function should also be coded to return a result of type VAR. Refer to the jsystem.h header file and jBASE 'C' programming for more information on the jBASE VAR type. The 'C' functions should be coded in a separate source, then compiled and built into a shared library and made available to the calling program similar to subroutines",
                "detail": "CALLC Cfunction{(argument{,...})}\nor\nCALLC @Variable{(argument {, argument ... })}",
                "snippet": "CALLC ${1:Cfunction}(${2:args})"
            },
            {
                "key": "Calldotnet",
                "icon": 14,
                "documentation": "The CALLdotNET command allows jBASE BASIC to call any .NET assembly and is useful when using third party applications. NameSpaceAndClassName The \u201cfull\u201d NameSpace (e.g., myNameSpace.myClass) methodName The name of the .NET in this class (e.g., \u201cmyMethod\u201d) Param Any parameter (e.g. DynArray)",
                "detail": "CALLdotNET NameSpaceAndClassName, methodName, param SETTING ret [ON ERROR errStatment]",
                "snippet": "CALLdotNET ${1:NameSpaceAndClassName}, ${2:methodName}, ${3:param} SETTING ${4:ret}"
            },
            {
                "key": "Callj",
                "icon": 14,
                "documentation": "The CALLJ statement allows a jBC program to call a Java method. packageAndClassName The \u201cfull\u201d class name (e.g., com.jbase.util.utilClass). methodName The name of the Java method in this class (e,g., \u201cmyMethod\u201d). If the method is static, you must include a \u2018$\u2019 before the name. This \u2018$\u2019 will be removed from the method name before calling it. param Any parameter (e.g. DynArray)",
                "detail": "CALLJ packageAndClassName, [$]methodName, param SETTING ret [ON ERROR] statements",
                "snippet": "CALLJ ${1:packageAndClassName}, ${2:methodName}, ${3:param} SETTING ${4:ret}"
            },
            {
                "key": "Callonexit",
                "icon": 3,
                "documentation": "The CALLONEXIT function call allows you to specify the name of a SUBROUTINE to call when the program terminates. The subroutine definition would look like this  SUBROUTINE CALLONEXIT(parm1)  You can add parameters to the error subroutine by adding multi-values to the parameter to CALLONEXIT, which are passed to the called subroutine in the first parameter. If you execute CALLONEXIT multiple times with the same subroutine name, it discards other calls. If you execute CALLONEXIT multiple times with a different subroutine name, then upon exit multiple subroutines will be called in the order that CALLONEXIT was called.",
                "detail": "rc = CALLONEXIT('ErrorExit')",
                "snippet": "CALLONEXIT(${1:subroutine_name})"
            },
            {
                "key": "Case",
                "icon": 14,
                "documentation": "The CASE statement allows the programmer to execute a particular sequence of instructions based upon the results of a series of test expressions. The CASE structure is bounded by the BEGIN CASE and END CASE statements. Within this block, an arbitrary number of CASE expression statements may exist followed by any number of jBC statements. The expression should evaluate to a TRUE or FALSE result. At execution time, each expression is evaluated in order. If the expression returns a TRUE result, then the statements beneath it are executed. On completion of the associated statements, execution will resume at the first statement following the END CASE.",
                "detail": "CASE expression\nstatement(s)\nCASE expression\nstatement(s)\n.....\nEND CASE",
                "snippet": "CASE ${1:expr}"
            },
            {
                "key": "Cats",
                "icon": 3,
                "documentation": "The CATS function concatenates the corresponding elements in two dynamic arrays. DynArr1 and DynArr2 represent dynamic arrays. If one dynamic array supplied to the CATS function is null then the result of the CATS function is the non-null dynamic array.",
                "detail": "CATS(DynArr1, DynArr2)",
                "snippet": "CATS(${1:DynArr1}, ${2:DynArr2})"
            },
            {
                "key": "Chain",
                "icon": 14,
                "documentation": "The CHAIN statement exits the current program and transfers process control to the program defined by the expression. Process control will never return to the originating program. The expression should evaluate to a valid UNIX or Windows command (this may be another jBC program). The command string may be suffixed with the (I option, which will cause any COMMON variables in the current program to be inherited by the new program (providing it is a jBC program).",
                "detail": "CHAIN expression {(I}",
                "snippet": "CHAIN ${1:expression}"
            },
            {
                "key": "Change",
                "icon": 3,
                "documentation": "The CHANGE function operates on a variable and replaces all occurrences of one string with another. expression1 may evaluate to any result and is the string of characters that will be replaced. expression2 may also evaluate to any result and is the string of characters that will replace expression1. The variable may be any previously assigned variable in the program. Either string can be of any length and is not required to be the same length. See also the SWAP function. The jBC language also supports the CHANGE statement.",
                "detail": "CHANGE( variable, expression1, expression2 )",
                "snippet": "CHANGE ${1:search} TO ${2:replace} IN ${3:variable}"
            },
            {
                "key": "Change",
                "icon": 14,
                "documentation": "The CHANGE statement operates on a variable and replaces all occurrences of one string with another. expression1 may evaluate to any result and is the string of characters that will be replaced, expression2 may also evaluate to any result and is the string of characters that will replace expression1, variable may be any previously assigned variable in the program. There is no requirement that strings be of the same length. ",
                "detail": "CHANGE expression1 TO expression2 IN variable",
                "snippet": "CHANGE ${1:expression1} TO ${2:expression2} IN ${3:variable}"
            },
            {
                "key": "Changetimestamp",
                "icon": 3,
                "documentation": "Use CHANGETIMESTAMP to adjust existing timestamp to return new timestamp value. The CHANGETIMESTAMP function generates a new timestamp by adjusting an existing timestamp value using the elements specified in the dynamic array. The format of the adjustment array is as follows: Years^Months^Weeks^Days^Hours^Minutes^Seconds^Milliseconds",
                "detail": "CHANGETIMESTAMP(Timestamp, Array)",
                "snippet": "CHANGETIMESTAMP(${1:Timestamp}, ${2:Array})"
            },
            {
                "key": "Char",
                "icon": 3,
                "documentation": "The CHAR function returns the  ASCII character specified by the expression. The expression must evaluate to a numeric argument in the range 0-255.  International Mode The CHAR function will return Unicode values encoded as UTF-8 byte sequences as follows: Expression values 0 \u2013 127 return UTF-8 single byte characters equivalent to ASCII. Expression values 127 \u2013 248 return UTF-8 double byte character sequences. Expression values 249 \u2013 255 return system delimiters 0xf8 \u2013 0xff Expression values > 255 return UTF-8 multi byte character sequences When system delimiter values are not specifically required, generate UTF-8 byte sequences using the UTF8 function. i.e. X = UTF8(@AM) will generate a UTF-8 byte sequence in variable X for the system delimiter equating to Unicode value 0x000000fe.",
                "detail": "CHAR(expression)",
                "snippet": "CHAR(${1:expression})"
            },
            {
                "key": "Chars",
                "icon": 3,
                "documentation": "The CHARS function accepts a dynamic array of numeric expressions and returns a dynamic array of the corresponding ASCII characters Each element of DynArr must evaluate to a numeric argument in the range 0-255. If any of the dynamic array elements are non-numeric, a run-time error will occur. See also CHAR().",
                "detail": "CHARS(DynArr)",
                "snippet": "CHARS(${1:DynArr})"
            },
            {
                "key": "Chdir",
                "icon": 3,
                "documentation": "The CHDIR function allows the current working directory, as seen by the process environment, to be changed. The expression should evaluate to a valid path name within the file system. The function returns a Boolean TRUE result if the CHDIR succeeded and a Boolean FALSE result if it failed.",
                "detail": "CHDIR(expression)",
                "snippet": "CHDIR(${1:path})"
            },
            {
                "key": "Checksum",
                "icon": 3,
                "documentation": "The CHECKSUM function returns a simple numeric checksum of a character string. The expression may evaluate to any result but will usually be a string. The function then scans every character in the string and returns a numeric addition of the characters within the string. The function calculates the checksum by summing the product of the ASCII value of each character and its position within the string.",
                "detail": "CHECKSUM(expression)",
                "snippet": "CHECKSUM(${1:expression})"
            },
            {
                "key": "Clear",
                "icon": 14,
                "documentation": "The CLEAR statement will initialize all variables to numeric 0. CLEAR can be used at any time during the execution of the program.",
                "detail": "CLEAR",
                "snippet": "CLEAR"
            },
            {
                "key": "Clearcommon",
                "icon": 14,
                "documentation": "The CLEARCOMMON statement initializes all unnamed common variables to a value of zero.",
                "detail": "CLEARCOMMON",
                "snippet": "CLEARCOMMON"
            },
            {
                "key": "Cleardata",
                "icon": 14,
                "documentation": "The CLEARDATA statement clears data that has been stacked by the DATA statement.",
                "detail": "CLEARDATA",
                "snippet": "CLEARDATA"
            },
            {
                "key": "Clearfile",
                "icon": 14,
                "documentation": "The CLEARFILE statement is used to clear all the data from a file previously opened with the OPEN statement. The variable must have been the subject of an OPEN statement before the execution of CLEARFILE upon it. If the variable is omitted from the CLEARFILE statement, then the default file variable is assumed as per the OPEN statement. The CLEARFILE statement will remove every database record on the file it is executed against. It should therefore be used with great care. If the variable argument does not describe a previously opened file, the program will enter the debugger with an appropriate message.",
                "detail": "CLEARFILE {variable} {SETTING setvar} {ON ERROR statements}",
                "snippet": "CLEARFILE ${1:variable}"
            },
            {
                "key": "Clearinput",
                "icon": 14,
                "documentation": "The CLEARINPUT statement clears the type-ahead buffer to allow the next INPUT statement to force a response from the user. CLEARINPUT only clears the type-ahead buffer. It does not clear data stacked with the DATA statement. The CLEARINPUT statement is synonymous with INPUTCLEAR.",
                "detail": "CLEARINPUT",
                "snippet": "CLEARINPUT"
            },
            {
                "key": "Clearselect",
                "icon": 14,
                "documentation": "The CLEARSELECT statement is used to clear specific active select lists. CListName must evaluate to a jBC list variable. ListNumber is one of the numbered lists in the range 0 to 11. If neither ListName or ListNumber are specified then the default list (0) is cleared.",
                "detail": "CLEARSELECT {ListName | ListNumber}",
                "snippet": "CLEARSELECT ${1:ListName}"
            },
            {
                "key": "Close",
                "icon": 14,
                "documentation": "The statement is used to CLOSE a previously opened file when it is no longer needed. Item locks and file locks are released. The variable list should contain previously opened file variables that are no longer needed. The variables will be cleared and may be reused as ordinary variables.",
                "detail": "CLOSE variable{, variable ...}",
                "snippet": "CLOSE ${1:variable}"
            },
            {
                "key": "Closeseq",
                "icon": 14,
                "documentation": "The statement is used to CLOSE a file previously opened for sequential access. FileVar contains the file descriptor of the previously opened sequential file",
                "detail": "CLOSESEQ FileVar",
                "snippet": "CLOSESEQ ${1:filevar}"
            },
            {
                "key": "Col1",
                "icon": 3,
                "documentation": "The function is used in conjunction with the FIELD function to determine the character position 1 position before the last field that was located. When a field has been located in a string, it is sometimes useful to know its exact position within the string to manipulate either it, or the rest of the string. COL1() will return the position of the character immediately before the last field located.",
                "detail": "COL1()",
                "snippet": "COL1()"
            },
            {
                "key": "Col2",
                "icon": 3,
                "documentation": "The function is used in conjunction with the FIELD function to determine the character position 1 position after the last field that was located. COL2() will return the position of the character immediately after the end of the last field located. Together with COL1(), they can then be used to manipulate the string.",
                "detail": "COL2()",
                "snippet": "COL2()"
            },
            {
                "key": "Collectdata",
                "icon": 14,
                "documentation": "The COLLECTDATA statement is used to retrieve data passed from the PASSDATA clause of an EXECUTE statement. variable is the name of the variable which is to store the retrieved data. The COLLECTDATA statement can be used in any program which is EXECUTEd (or PERFORMed) by another program where the calling program uses a PASSDATA clause. The EXECUTEd program uses a COLLECTDATA statement to retrieve the passed data. If a PASSDATA clause is not in effect, variable will be assigned a value of null.",
                "detail": "COLLECTDATA variable",
                "snippet": "COLLECTDATA ${1:variable}"
            },
            {
                "key": "Common",
                "icon": 14,
                "documentation": "The COMMON statement declares a list of variables and matrices that can be shared among various programs. There can be many common areas including a default, unnamed common area. The list of variables should not have been declared or referenced previously in the program file. The compiler will detect any bad declarations and display suitable warning or error messages. If the common area declared with the statement is to be named then the first entry in the list should be a string, delimited by the \/ character.",
                "detail": "COMMON {\/CommonName\/} variable{, variable ... }",
                "snippet": "COMMON $1"
            },
            {
                "key": "Compare",
                "icon": 3,
                "documentation": "The COMPARE function compares two strings and returns a value indicating whether or not they are equal. expression1 is the first string for comparison expression2 is the second string for comparison justification specifies how the strings are to be compared. \"L\" indicates a left justified comparison. \"R\" indicates a right justified comparison. The default is left justification.",
                "detail": "COMPARE(expression1, expression2{, justification})",
                "snippet": "COMPARE(${1:expression1}, ${2:expression2}, ${3:justification})"
            },
            {
                "key": "Continue",
                "icon": 14,
                "documentation": "The CONTINUE statement is the complimentary statement to the BREAK statement without arguments. The statement is used within a loop to skip the remaining code in the current iteration and proceed directly to the next iteration. See also: BREAK, EXIT The compiler will issue a warning message and ignore the statement if it is found outside an iterative loop such as FOR...NEXT, LOOP...REPEAT.",
                "detail": "CONTINUE",
                "snippet": "CONTINUE"
            },
            {
                "key": "Convert",
                "icon": 3,
                "documentation": "This is the function form of the CONVERT statement. It performs exactly the same function, but may also operate on an expression rather than being restricted to variables. expression1 is the string to which the conversion will apply. expression2 is the list of all characters to translate in expression1. expression3 is the list of characters that will be converted to.  For Prime, Universe and Unidata emulations: expression1 is the list of all characters to translate in expression1. expression2 is the list of characters that will be converted to. expression3 is the string to which the conversion will apply.",
                "detail": "CONVERT(expression1, expression2, expression3)",
                "snippet": "CONVERT ${1:search} TO ${2:replace} IN ${3:expression}"
            },
            {
                "key": "Convert",
                "icon": 14,
                "documentation": "The CONVERT statement converts one or more characters in a string to their corresponding replacement characters. expression1 is the list of all characters to translate in expression3. expression2 is the list of characters that will be converted to. expression3 is the string to which the conversion will apply.",
                "detail": "CONVERT expression1 TO expression2 IN expression3",
                "snippet": "CONVERT ${1:expression1} TO ${2:expression2} IN ${3:expression3}"
            },
            {
                "key": "Cos",
                "icon": 3,
                "documentation": "The COS function calculates the cosine of any angle using floating point arithmetic, then rounds to the precision implied by the jBC program. This makes it very accurate. The expression must evaluate to a numeric result or a runtime error will occur.",
                "detail": "COS(expression)",
                "snippet": "COS(${1:expression})"
            },
            {
                "key": "Count",
                "icon": 3,
                "documentation": "The COUNT function returns the number of times that one string occurs in another. Both expression1 and expression2 may evaluate to any data type but logically they will evaluate to character strings. The count is made on overlapping occurrences as a pattern match from each character in expression1. This means that the string jjj occurs 3 times in the string jjjjj.",
                "detail": "COUNT(expression1, expression2)",
                "snippet": "COUNT(${1:expression}, ${2:delimiter})"
            },
            {
                "key": "Counts",
                "icon": 3,
                "documentation": "The COUNTS function counts the number of times a substring is repeated in each element of a dynamic array. The result is a new dynamic array whose elements are the counts corresponding to the elements in the dynamic array. dynamic.array specifies the dynamic array whose elements are to be searched. substring is an expression that evaluates to the substring to be counted. substring can be a character string, a constant, or a variable. Each character in an element is matched to substring only once. Therefore, when substring is longer than one character and a match is found, the search continues with the character following the matched substring. No part of the matched element is recounted toward another match. If substring does not appear in an element, a 0 value is returned. If substring is an empty string, the number of characters in the element is returned. If substring is null, the COUNTS function fails and the program terminates with a run-time error message. If any element in dynamic.array is null, null is returned.",
                "detail": "COUNTS(dynamic array, substring)",
                "snippet": "COUNTS(${1:dynamic_array}, ${2:substring})"
            },
            {
                "key": "Create",
                "icon": 14,
                "documentation": "Use the CREATE statement after an OPENSEQ statement to create a record in a jBASE directory file or to create a UNIX or DOS file. CREATE creates the record or file if the OPENSEQ statement fails. An OPENSEQ statement for the specified file.variable must be executed before the CREATE statement to associate the pathname or record ID of the file to be created with the file.variable. If file.variable is null, the CREATE statement fails and the program enters the debugger. Use the CREATE statement when OPENSEQ cannot find a record or file to open and the next operation is to be a READSEQ or READBLK. If the first file operation is a WRITESEQ, WRITESEQ creates the record or file if it does not exist. If the record or file is created, it executes the THEN statements; if no record or file is created, it executes the ELSE statements.",
                "detail": "CREATE file.variable {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "CREATE ${1:filevar} THEN $2 ELSE $3"
            },
            {
                "key": "Crt",
                "icon": 14,
                "documentation": "The CRT statement sends data directly to the terminal, even if a PRINTER ON statement is currently active.  An expression can evaluate to any data type. The CRT statement will convert the result to a string type for printing. Expressions separated by commas will be sent to the screen separated by a tab character. The CRT statement will append a newline sequence to the final expression unless it is terminated with a colon \":\" character.",
                "detail": "CRT expression {, expression..} {:}",
                "snippet": "CRT ${1:expression}"
            },
            {
                "key": "Crt @",
                "icon": 14,
                "documentation": "The CRT statement sends data directly to the terminal, even if a PRINTER ON statement is currently active.  An expression can evaluate to any data type. The CRT statement will convert the result to a string type for printing. Expressions separated by commas will be sent to the screen separated by a tab character. The CRT statement will append a newline sequence to the final expression unless it is terminated with a colon \":\" character.",
                "detail": "CRT @(col, row): expression {, expression..} {:}",
                "snippet": "CRT @(${1:col}, ${2:row}):${3:expression}"
            },
            {
                "key": "Data",
                "icon": 14,
                "documentation": "The DATA statement stacks the series of expressions on an input FIFO stack. Terminal input statements will then treat this data as if it were typed in at the keyboard The expression may evaluate to any data type. Each comma separated expression will be viewed as one line of terminal input. The DATA statement cannot be used to send input to the jBC IN statement in that the IN statement reads from a different location than the INPUT statement. The INPUT statement reads from stdin and IN reads from the 'raw' device (normally the keyboard). ",
                "detail": "DATA expression {, expression ...}",
                "snippet": "DATA ${1:expression}"
            },
            {
                "key": "Date",
                "icon": 3,
                "documentation": "The DATE() function returns the date in internal system form. This date is expressed as the number of days before or after December 31, 1967. The system and any programs should manipulate date fields in internal form. They can then be converted to a readable format of your choice using the OCONV() function and the date conversion codes. See also: TIMEDATE()",
                "detail": "DATE()",
                "snippet": "DATE()"
            },
            {
                "key": "Dcount",
                "icon": 3,
                "documentation": "The DCOUNT() function counts the number of field elements in a string that are separated by a specified delimiter. expression1 evaluates to a string in which fields are to be counted. expression2 evaluates to the delimiter string that will be used to count the fields. The delimiter string may consist of more than 1 character. If expression1 is a NULL string, then the function will return a value of 0. The delimiter string may consist of any character, including system delimiters such as field marks or value marks. See also COUNT.",
                "detail": "DCOUNT(expression1, expression2)",
                "snippet": "DCOUNT(${1:expression}, ${2:delimiter})"
            },
            {
                "key": "Debug",
                "icon": 14,
                "documentation": "The DEBUG statement causes the executing program to enter the jBC debugger.",
                "detail": "DEBUG",
                "snippet": "DEBUG"
            },
            {
                "key": "Decrypt",
                "icon": 3,
                "documentation": "The DECRYPT function decodes a string encrypted by the ENCRYPT function. string specifies the string to be decrypted. key is the value used to decrypt the string. It's use depends on method. method is a number which indicates the decryption mechanism to use: 0\tGeneral purpose encryption scheme. \tThis method will decrypt the string using the key value supplied. 1\tSimple ROT13 algorithm. \tkey not used. 2\tXOR MOD11 algorithm. \tThe first character of key is used as a seed value. See also ENCRYPT.",
                "detail": "DECRYPT(string, key, method)",
                "snippet": "DECRYPT(${1:string}, ${2:key}, ${3:method})"
            },
            {
                "key": "Defc",
                "icon": 14,
                "documentation": "The DEFC statement is used to declare an external C function to the jBC compiler and define its arguments and return types. FuncType and ArgType are selected from one of INT, FLOAT or VAR. FuncType specifies the type of result that the function will return. If FuncType is omitted then INT will be assumed. The optional list of ArgTypes specifies the argument types that the C function will expect. The compiler must know this in advance as it will automatically perform type conversions on these arguments.",
                "detail": "DEFC {FuncType} FuncName ({ArgType {, ArgType ...}})",
                "snippet": "DEFC ${1:FuncType} ${2:FuncName} (${3:ArgTypes})"
            },
            {
                "key": "Defce",
                "icon": 14,
                "documentation": "The DEFCE statement should be used, rather than the DEFC statement, for calling external C programs, which are pure \u2018C\u2019 code and do not use the jBASE library macros and functions. The arguments passed can only be of type INT, FLOAT and STRING.",
                "detail": "DEFCE {FuncType} FuncName ({ArgType {, ArgType ...}})",
                "snippet": "DEFCE ${1:FuncType} ${2:FuncName} (${3:ArgTypes})"
            },
            {
                "key": "Deffun",
                "icon": 14,
                "documentation": "The DEFFUN statement is used to declare an external jBC function to the jBC compiler and optionally define its arguments. DEFFUN is used in the program that calls the function. FuncName is the name used to define the function. It must be the same as the source file name. Argument specifies a value that is passed to the function by the calling program. To pass an array, the keyword MAT must be used before the argument name. These parameters are entirely optional (as indicated in the Command Syntax), but can be specified for clarity. Note that if the arguments are not initialized somewhere in the program you will receive a compiler warning. The DEFFUN statement identifies a user-written function to the jBC compiler. It must be present in each program that calls the function, before the function is called. A hidden argument is passed to the function so that a value can be returned to the calling program. The return value is set in the function using the  RETURN (value) statement. If the RETURN statement specifies no value then an empty string is returned by the function.",
                "detail": "DEFFUN FuncName  ({ {MAT} Argument1, {MAT} Argument2...})",
                "snippet": "DEFFUN ${1:FuncName}(${2:args})"
            },
            {
                "key": "Del",
                "icon": 3,
                "documentation": "The DEL statement or legacy DELETE function is used to remove a specified element from a dynamic array. The variable can be any previously assigned variable or matrix element. The expressions must evaluate to a numeric value or a runtime error will occur. expression1 specifies the field in the array to operate upon and must be present. expression2 specifies the multivalue within the field to operate upon and is an optional parameter. expression3 is optionally present when expression2 has been included. It specifies which subvalue to delete within the specified multivalue.",
                "detail": "DEL variable\nDELETE(variable,expression1{, expression2{, expression3})",
                "snippet": "DEL ${1:variable}"
            },
            {
                "key": "Delete",
                "icon": 14,
                "documentation": "The DELETE statement is used to delete a record from a jBASE file. If specified, variable should have been the subject of a previous OPEN statement. If variable is omitted then the default file variable is assumed. The expression should evaluate to the name of a record stored in the open file.",
                "detail": "DELETE {variable,} expression {SETTING setvar} {ON ERROR statements}",
                "snippet": "DELETE ${1:variable},${2:expression}"
            },
            {
                "key": "Deletelist",
                "icon": 14,
                "documentation": "The DELETELIST statement will delete the previously stored list named by the expression. The expression should evaluate to the name of a list that has been stored either with the WRITELIST statement or the SAVE-LIST command from the shell.",
                "detail": "DELETELIST expression",
                "snippet": "DELETELIST ${1:expression}"
            },
            {
                "key": "Deleteseq",
                "icon": 14,
                "documentation": "DELETESEQ deletes an operating system file. Expression specifies the explicit path of an operating system file to delete. Expression, Filename Filename is a file that resides in the directory path specified by Expression Statements conditional jBC statements",
                "detail": "DELETESEQ Expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN | ELSE statements\nor\nDELETESEQ Expression, Filename {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN | ELSE statements",
                "snippet": "DELETESEQ ${1:Expression} THEN $2 ELSE $3"
            },
            {
                "key": "Deleteu",
                "icon": 14,
                "documentation": "Use the DELETEU statement to delete a record without releasing the update record lock set by a previous READU statement. If no file variable is specified in the DELETEU statement, the statement applies to the default file.",
                "detail": "DELETEU {variable,} expression {SETTING setvar} {ON ERROR statements}",
                "snippet": "DELETEU ${1:variable},${2:expression}"
            },
            {
                "key": "Dim",
                "icon": 14,
                "documentation": "The DIM statement is used to declare arrays to the compiler before they are referenced. The variable may be any valid variable name that has not already been used or declared. The numbers define the size of each dimension and must be either constants or the subject of an EQUATE statement. A number of arrays may be declared by a single DIM statement by separating their declarations with a comma. The array must be declared before it is referenced in the program source (compilation as opposed to execution). The compiler will display an error message if a variable is used as a dimensioned array before it has been declared. The array variable may not be used as a normal variable or dynamic array before being dimensioned and the compiler will detect this as an error. A dimension size may not be specified as 1 as this has no logical meaning. The compiler will detect this as a warning. When arrays are referenced directly as in A = Array(7), the compiler will optimize the reference as if it was a single undimensioned variable. If the emulation option 'resize_array=true' is set, then the array may be dimensioned with a variable. It can also be resized (i.e. redimensioned).",
                "detail": "DIM{ENSION} variable(number{, number... }){, variable(number {,number...}) ...}",
                "snippet": "DIM ${1:variable}(${2:numbers})"
            },
            {
                "key": "Dimension",
                "icon": 14,
                "documentation": "The DIMENSION statement is used to declare arrays to the compiler before they are referenced. The variable may be any valid variable name that has not already been used or declared. The numbers define the size of each dimension and must be either constants or the subject of an EQUATE statement. A number of arrays may be declared by a single DIM statement by separating their declarations with a comma. The array must be declared before it is referenced in the program source (compilation as opposed to execution). The compiler will display an error message if a variable is used as a dimensioned array before it has been declared. The array variable may not be used as a normal variable or dynamic array before being dimensioned and the compiler will detect this as an error. A dimension size may not be specified as 1 as this has no logical meaning. The compiler will detect this as a warning. When arrays are referenced directly as in A = Array(7), the compiler will optimize the reference as if it was a single undimensioned variable. If the emulation option 'resize_array=true' is set, then the array may be dimensioned with a variable. It can also be resized (i.e. redimensioned).",
                "detail": "DIMENSION variable(number{, number... }){, variable(number {,number...}) ...}",
                "snippet": "DIMENSION ${1:variable}"
            },
            {
                "key": "Dir",
                "icon": 3,
                "documentation": "The DIR function returns information about a file.The filename is a string argument representing the path and filename of a file. This function returns a dynamic array with four attributes. Attribute\tDescription 1\tFile size in Bytes 2\tLast modified date (in internal format) 3\tLast modified time (in internal format) 4\t'D' if the filename is a directory, blank if the filename is a file",
                "detail": "DIR(filename)",
                "snippet": "DIR(${1:filename})"
            },
            {
                "key": "Display",
                "icon": 14,
                "documentation": "The DISPLAY statement sends data directly to the terminal, even if a PRINTER ON statement is currently active. An expression can evaluate to any data type. The DISPLAY statement will convert the result to a string type for printing. Expressions separated by commas will be sent to the screen separated by a tab character. The DISPLAY statement will append a newline sequence to the final expression unless it is terminated with a colon \":\" character. As the expression can be any valid expression, it may have output formatting applied to it. A jBC program is normally executed using buffered output mode. This means that data is not flushed to the terminal screen unless a newline sequence is printed or terminal input is requested and makes it very efficient. However you can force output to be flushed to the terminal by printing a null character 'CHAR(0)'. This has the same effect as a newline sequence but without affecting screen output.",
                "detail": "DISPLAY expression {, expression..} {:}",
                "snippet": "DISPLAY ${1:expression}"
            },
            {
                "key": "Div",
                "icon": 3,
                "documentation": "The DIV function  calculates the value of the quotient after division of the dividend by the divisor. The dividend and divisor expressions can evaluate to any numeric value. The only exception is that the divisor cannot be zero. If either dividend or divisor evaluates to null, it returns null.",
                "detail": "DIV(dividend, divisor)",
                "snippet": "DIV(${1:dividend}, ${2:divisor})"
            },
            {
                "key": "Divs",
                "icon": 3,
                "documentation": "The DIVS function returns a dynamic array, the content of which is derived by dividing each element of the first dynamic array argument by the corresponding element of the second dynamic array argument. DynArr1 and DynArr2 represent dynamic arrays. Null elements of argument arrays are treated as zero. Otherwise, a non-numeric element in an argument array will cause a run-time error. If a zero value element in DynArr2 has a corresponding element in DynArr1, then a run-time error will occur. If a zero value element in DynArr2 does not have a corresponding element in DynArr1, then the corresponding element in the result array will be zero.",
                "detail": "DIVS(DynArr1, DynArr2)",
                "snippet": "DIVS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Downcase",
                "icon": 3,
                "documentation": "DOWNCASE converts all uppercase characters in an expression to lowercase characters. expression in a string containing alphabetic characters. Non-alphabetic characters are ignored. The function LOWCASE is synonymous with DOWNCASE.",
                "detail": "DOWNCASE(expression)",
                "snippet": "DOWNCASE(${1:expression})"
            },
            {
                "key": "Dquote",
                "icon": 3,
                "documentation": "The function will put double quotation mark at the beginning and end of a string. expression may be any expression that is valid in the JBC language.",
                "detail": "DQUOTE(Expression)",
                "snippet": "DQUOTE(${1:expression})"
            },
            {
                "key": "Dround",
                "icon": 3,
                "documentation": "The DROUND( ) function performs double-precision rounding on a value. expression1 is the value to round. expression2 is the optional precision. Double-precision rounding uses 2 words to store a number. If a precision is not specified as the second expression, DROUND() uses whatever precision is set at the time of the calculation. If no PRECISION statement was issued then the default precision of 4 is used. The specified precision (either with the PRECISION statement or with the optional precision parameter) to be greater than or equal to the rounding digit, otherwise the calculation will truncate the value to the whatever precision is 'active' at the time of the calculation.",
                "detail": "DROUND(expression1{, expression2})",
                "snippet": "DROUND(${1:value}, ${2:precision})"
            },
            {
                "key": "Dtx",
                "icon": 3,
                "documentation": "The DTX function will return the hexadecimal representation of a numeric expression. expression must evaluate to a decimal numeric value or a runtime error will occur.",
                "detail": "DTX(expression)",
                "snippet": "DTX(${1:expression})"
            },
            {
                "key": "Dyntoxml",
                "icon": 3,
                "documentation": "The DYNTOXML function converts a dynamic array to XML. Convert an array to XML using the optional xsl to transform Takes the contents of the dynamic array and returns a generic XML representation of that array or an error",
                "detail": "DYNTOXML(array,xsl,result)",
                "snippet": "DYNTOXML(${1:array}, ${2:xsl}, ${3:result})"
            },
            {
                "key": "Ebcdic",
                "icon": 3,
                "documentation": "The EBCDIC function converts all the characters in an expression from the ASCII character set to the EBCDIC character set. expression may contain a data string of any form. The function will convert it to a character string, assuming that the characters are all members of the ASCII set and translate them using a character map. The original expression is unchanged while the result of the function is now the EBCDIC equivalent.",
                "detail": "EBCDIC(expression)",
                "snippet": "EBCDIC(${1:expression})"
            },
            {
                "key": "Echo",
                "icon": 14,
                "documentation": "The ECHO statement will turn on or off the echoing of characters typed at the keyboard. The statement may be used with the keywords ON and OFF to specify echoing or not. If used with an expression, then the expression should evaluate to a Boolean TRUE or FALSE result. If TRUE then echoing will be turned on, and if FALSE, echoing will be turned off. The SYSTEM function can be used to determine the current state of character echoing. If echoing is enabled then SYSTEM(24) will return Boolean TRUE and if disabled it will return Boolean FALSE.",
                "detail": "ECHO ON\nECHO OFF\nECHO expression",
                "snippet": "ECHO ${1:expression}"
            },
            {
                "key": "Encrypt",
                "icon": 3,
                "documentation": "The ENCRYPT function encrypts a string. string specifies the string to be encrypt. key is the value used to encrypt the string. It's use depends on method. method is a number which indicates the encryption mechanism to use: 0\tGeneral purpose encryption scheme. \tThis method will encrypt the string using the key value supplied. 1\tSimple ROT13 algorithm. \tkey not used. 2\tXOR MOD11 algorithm. \tThe first character of key is used as a seed value. See also DECRYPT.",
                "detail": "ENCRYPT(string, key, method)",
                "snippet": "ENCRYPT(${1:string}, ${2:key}, ${3:method})"
            },
            {
                "key": "End",
                "icon": 14,
                "documentation": "The END statement is used to terminate a program or to conclude a set of jBC statements bounded by a condition. The END statement is not required in a jBC program. If the compiler encounters an END statement that is not the conclusion to a conditional block, then no statements can follow it.",
                "detail": "END",
                "snippet": "END"
            },
            {
                "key": "End Case",
                "icon": 14,
                "documentation": "The END CASE statement terminates a CASE block. There should be a corresponding END CASE for each BEGIN CASE.",
                "detail": "END CASE",
                "snippet": "END CASE"
            },
            {
                "key": "End Else",
                "icon": 14,
                "documentation": "The END ELSE terminates the THEN portion and begin the ELSE portion of a code block",
                "detail": "END ELSE",
                "snippet": "END ELSE"
            },
            {
                "key": "Enter",
                "icon": 14,
                "documentation": "The ENTER statement unconditionally passes control to another executable program. program_name is the name of the program to be executed. The use of single or double quotes to surround program_name is optional. @ specifies that the program name is contained in a named variable. variable_name is the name of the variable which contains the program name. The jBC COMMON data area can be passed to another jBC program by specifying the \"(I\" option after the program name. Note that the program must be compiled with 'enter_keeps_common_data = true' set in the '$JBCRELEASEDIR\/config\/Config_EMULATE' file (under the appropriate emulation section). The COMMON data area can only be passed to another jBC program. ENTER can be used to execute any type of program. If the program which contains the ENTER command (the current program) was called from a jCL program, and the program to be executed (the target program) is another jBC program, control will return to the original jCL program when the target program terminates. If the target program is a jCL program, control will return to the command shell when the jCL program terminates.",
                "detail": "ENTER program_name\nENTER @variable_name",
                "snippet": "ENTER ${1:name}"
            },
            {
                "key": "Eqs",
                "icon": 3,
                "documentation": "The EQS function tests if elements in one dynamic array are equal to the elements of another dynamic array. This function compares each element of array 1 with the corresponding element of array 2 and returns a one if the two elements are equal in the corresponding element of a dynamic array. It returns a zero if the two elements are not equal. It returns zero if an element of one dynamic array does not have a corresponding element in the other dynamic array. If either element of a corresponsing pair is null, it returns null for that element.",
                "detail": "EQS(array1, array2)",
                "snippet": "EQS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Equate",
                "icon": 14,
                "documentation": "EQUATE is used to declare a symbol equivalent to a literal, variable or simple expression. symbol is the name of the symbol to use. Can be any name that would be valid for a variable. expression can be a literal, a variable or a simple expression.",
                "detail": "EQU{ATE} symbol TO expression",
                "snippet": "EQUATE ${1:symbol} TO ${2:expression}"
            },
            {
                "key": "Ereplace",
                "icon": 3,
                "documentation": "The EREPLACE function replaces a substring in an expression with another substring. occurrence specifies the number of occurrences of substring to replace. To replace all occurrences, specify occurrence as a number less than 1. begin specifies the first occurrence to replace. If begin is omitted or less than one, it defaults to one. If substring is an empty string, replacement is prefixed to expression. If replacement is an empty string, it removes all occurrences of substring. If expression evaluates to null, it returns null. If substring, replacement, occurrence, or begin evaluates to null, the EREPLACE function fails and the program terminates with a run-time error message. The EREPLACE function behaves like the CHANGE function except when substring evaluates to an empty string.",
                "detail": "EREPLACE(expression, substring, replacement [, occurrence [, begin]])",
                "snippet": "EREPLACE(${1:expression}, ${2:substring}, ${3:replacement}, ${4:occurrence}, ${5:begin})"
            },
            {
                "key": "Execute",
                "icon": 14,
                "documentation": "The EXECUTE or PERFORM statement allows the currently executing program to pause and execute any other UNIX\/Windows program, including another jBC program or a jBASE command. The expression to be EXECUTEd can be formed from any jBASE construct. The system will not verify that the command exists before executing it. The command is executed by a new Bourne Shell (sh) by default. The shell type can be changed by preceding the command with a CHAR(255) (or equivalently, @IM) concatenated with either \"k\", \"c\", or \"s\" to signify the Korn shell, C shell or Bourne Shell. Variables used to pass data to the executed program should have been assigned a value before they are used. Any variable name may be used to receive data.  CAPTURING variable The capturing clause will capture any output that the executing program would normally send to the terminal screen and place it in the variable specified. Every newline normally sent to the terminal is replaced with a field mark in the variable. RETURNING variable or SETTING variable The returning and setting clauses are identical. Both clauses will capture the output associated with any error messages the executing program issues. The first field of the variable will be set to the exit code of the program. PASSLIST variable The PASSLIST clause allows jBASE programs to exchange lists or dynamic arrays between them. The variable should contain the list that the program wishes to pass to the jBASE program it is executing. The program to be executed should be able to process lists, otherwise the list will just be ignored. If the variable name is not specified then the clause will pass the default select list to the executing program. RTNLIST variable If the program executed sets up a list then the RTNLIST clause may be used to place that list into a specified variable. If the variable is omitted then the list is placed in the default list variable. PASSDATA variable The data in the specified variable is passed to another jBC program. The executing jBC program should retrieve the data using the COLLECTDATA statement. RTNDATA variable The RTNDATA statement returns any data passed from an executing jBC program in the specified variable. The executing jBC program should use the RTNDATA statement to pass data back to the calling program. The clauses may be specified in any order within the statement but only one of each clause may exist.",
                "detail": "EXECUTE expression {CAPTURING variable} {RETURNING|SETTING variable}\n{PASSLIST expression} {RTNLIST {variable}}\n{PASSDATA variable} {RTNDATA variable}",
                "snippet": "EXECUTE ${1:expression}"
            },
            {
                "key": "Exit",
                "icon": 14,
                "documentation": "The EXIT statement is used to halt the execution of a program and return a numeric exit code to the parent process. For compatibility with older versions of the language the EXIT statement may be used without an expression. In this case it is synonymous with the BREAK statement. Any expression provided must be parenthesized and must evaluate to a numeric result. The numeric result is used as the UNIX or Windows exit code, which is returned to the parent process by the C function exit(). If the expression does not evaluate to a numeric then the program will enter the debugger with a suitable error message.",
                "detail": "EXIT (expression)\nEXIT",
                "snippet": "EXIT($1)"
            },
            {
                "key": "Exp",
                "icon": 3,
                "documentation": "The EXP function returns the mathematical constant e to the specified power. The expression may consist of any form of jBC expression but should evaluate to a numeric argument or a runtime error will occur and the program will enter the debugger. The function will return a value that is accurate to as many decimal places as are specified by the PRECISION of the program.",
                "detail": "EXP(expression)",
                "snippet": "EXP(${1:expression})"
            },
            {
                "key": "Extract",
                "icon": 3,
                "documentation": "The EXTRACT function is an alternative method of accessing values in a dynamic array. expression1 specifies the dynamic array to work with and will normally be a previously assigned variable. expressions 2 through 4 should all return a numeric value or a runtime error will occur and the program will enter the debugger. expression2 specifies the field to extract, expression3 the value to extract and expression4 the sub-value to extract.",
                "detail": "EXTRACT(expression1, expression2 {, expression3 {, expression4}})",
                "snippet": "EXTRACT(${1:dynArr}, ${2:attr}, ${3:value}, ${4:subvalue})"
            },
            {
                "key": "Fadd",
                "icon": 3,
                "documentation": "The FADD function performs the floating point addition of two numeric values. Both expression1 and expression 2 must evaluate to non-null numeric values. If either of the arguments is not numeric, a runtime 'non-numeric' error will occur.",
                "detail": "FADD(expression1, expression2)",
                "snippet": "FADD(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Fdiv",
                "icon": 3,
                "documentation": "The FDIV function performs the floating point division of two numeric values. Both expression1 and expression 2 must evaluate to non-null numeric values. If either of the arguments evaluates to null then a run time 'non-numeric' error will occur. If the second argument evaluates to zero then a run time 'divide by zero' error will occur. The calculation is not subject to the PRECISION setting.",
                "detail": "FDIV(expression1, expression2)",
                "snippet": "FDIV(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Field",
                "icon": 3,
                "documentation": "The FIELD function will return a multi-character delimited field from within a string. string specifies the string from which the field(s) are to be extracted. delimiter specifies the character or characters that delimit the fields within the dynamic array. occurrence should evaluate to an integer of value 1 or higher. \tIt specifies the delimiter used as the starting point for the extraction. extractCount is an integer that specifies the number of fields to extract. \tIf omitted, 1 is assumed. If the emulation option 'jbase_field' is set, then the field delimiter may consist of more than a single character, allowing fields to be delimited by complex codes. If extractCount is greater than 1 then only the first character of  delimiter is used, regardless of the setting of jbase_field.",
                "detail": "FIELD(string, delimiter, occurrence{, extractCount})",
                "snippet": "FIELD(${1:string}, ${2:delimiter}, ${3:occurrence}, ${4:extractCnt})"
            },
            {
                "key": "Fields",
                "icon": 3,
                "documentation": "The FIELDS function is an extension of the FIELD function. It returns a dynamic array of multi-character delimited fields from a dynamic array of strings. DynArr should evaluate to a dynamic array. Delimiter specifies the character or characters that delimit the fields within the dynamic array. Occurrence should evaluate to an integer of value 1 or higher. \tIt specifies the delimiter used as the starting point for the extraction. ExtractCount is an integer that specifies the number of fields to extract. \tIf omitted, 1 is assumed. If the emulation option 'jbase_field' is set, then the field delimiter may consist of more than a single character, allowing fields to be delimited by complex codes. If extractCount is greater than 1 then only the first character of  delimiter is used, regardless of the setting of jbase_field.",
                "detail": "FIELDS(DynArr, Delimiter, Occurrence{, ExtractCount})",
                "snippet": "FIELDS(${1:dynArr}, ${2:delimiter}, ${3:occurrence}, ${4:extractCount})"
            },
            {
                "key": "Fileinfo",
                "icon": 3,
                "documentation": "The FILEINFO function returns information about a specified file variable. This function is currently limited to return values to determine if the file variable is a valid file descriptor variable",
                "detail": "FILEINFO(file.variable, key)",
                "snippet": "FILEINFO(${1:file_variable}, ${2:key})"
            },
            {
                "key": "Filelock",
                "icon": 14,
                "documentation": "When the FILELOCK statement is executed, it will attempt to take an exclusive lock on the specified file. When the FILELOCK statement is executed, it will attempt to take an exclusive lock on the entire file. If there are any locks currently outstanding on the file, then the statement will block until there are no more locks on the file. The use of the LOCKED clause allows the application to perform an unblocked operation. When the FILELOCK statement is blocked waiting for a lock, other processes may continue to perform database operations on that file, including the removal of record locks and also the taking of record locks. Once the FILELOCK is taken, it will block ALL database access to the file whether or not the access involves record locks. i.e. a READ will block once a FILELOCK has been executed, as will READU, READL, WRITE, CLEARFILE and so on. The lock continues until either the file is closed, the program terminates or a FILEUNLOCK statement is executed",
                "detail": "FILELOCK filevar {LOCKED statements} {ON ERROR statements}",
                "snippet": "FILELOCK ${1:filevar} LOCKED ${2:lock_statements} ON ERROR ${3:error_statements}"
            },
            {
                "key": "Fileunlock",
                "icon": 14,
                "documentation": "FILEUNLOCK is used to release a specified file lock set by the FILELOCK statement.",
                "detail": "FILEUNLOCK filevar {ON ERROR statements}",
                "snippet": "FILEUNLOCK ${1:file_variable} ON ERROR ${2:statements}"
            },
            {
                "key": "Find",
                "icon": 14,
                "documentation": "The FIND statement allows the location of a specified string within a dynamic array. expression1 evaluates to the string to compare every element of the dynamic array with. Var1 is the dynamic array that will be searched. The FIND command will normally find the first occurrence of expression1 unless expression2 is specified. If specified then expression2 will cause a specific occurrence of expression1 to be located. The three variables Var2, Var3, Var4 are used to record the Field, Value and Sub-Value positions in which expression1 was found. If expression1 is found in any element of Var1 then Vars 2, 3 and 4 are set to the position in which it was found and any THEN clause of the statement is executed. If expression1 is not found within any element of the dynamic array then Vars 2, 3 and 4 are undefined and the ELSE clause of the statement is executed. The statement may omit either the THEN clause or the ELSE clause but may not omit both.",
                "detail": "FIND expression1 IN Var1 {, expression2} SETTING Var2 {, Var3 {, Var4}} THEN | ELSE statement(s)",
                "snippet": "FIND ${1:expression1} IN ${2:Var1} SETTING ${3:Var2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Findstr",
                "icon": 14,
                "documentation": "The FINDSTR statement is used to locate a string as a substring of a dynamic array element. It is similar in operation to the FIND statement. eexpression1 evaluates to the string to search every element of the dynamic array with. Var1 is the actual dynamic array that will be searched. FINDSTR will normally locate the first occurrence of expression1 unless expression2 is specified. If specified then expression2 will cause a specific occurrence of expression1 to be located. The three variables Var2, Var3, Var4 are used to record the Field, Value and Sub-Value positions in which expression1 was found. If expression1 is found as a substring of any element of Var1 then Vars 2, 3 and 4 are set to the position in which it was found and the THEN clause of the statement is executed if it is present. If expression1 is not found within any element of the dynamic array then Vars 2,3 and 4 are undefined and the ELSE clause of the statement is executed. The statement may omit either the THEN clause or the ELSE clause but may not omit both.",
                "detail": "FINDSTR expression1 IN Var1 {, expression2} SETTING Var2 {,Var3 {, Var4}} THEN | ELSE statement(s)",
                "snippet": "FIND ${1:expression1} IN ${2:Var1} SETTING ${3:Var2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Flush",
                "icon": 14,
                "documentation": "Writes all the buffers for a sequential I\/O file immediately. Normally, sequential I\/O uses buffering for input\/output operations, and writes are not immediately flushed.",
                "detail": "FLUSH $file_variable THEN $1 ELSE $2 END",
                "snippet": "FLUSH ${1:file_variable} THEN $2 ELSE $3 END"
            },
            {
                "key": "Fmt",
                "icon": 3,
                "documentation": "Performs formatting of output data values for use with PRINT and CRT commands. MaskExpression -> Numeric Mask Codes: [j][n][m][Z][,][c][$][Fill Character][Length]",
                "detail": "FMT(Variable, MaskExpression)",
                "snippet": "FMT(${1:var}, ${2:code})"
            },
            {
                "key": "Fmts",
                "icon": 3,
                "documentation": "Performs formatting of the elements of a dynamic array for output. Each element of the array is independently acted upon and returned as an element in a new dynamic array. format is an expression that evaluates to a string of formatting codes. The Syntax of the format expression is: [width] [background\/fill] justification [edit] [mask] The format expression specifies the width of the output field, the placement of background or fill characters, line justification, editing specifications, and format masking. If dynamic.array evaluates to null, it returns null. If format evaluates to null, the FMTS function fails and the program enters the debugger.",
                "detail": "FMTS(dynamic.array, format)",
                "snippet": "FMTS(${1:dynArr}, ${2:format})"
            },
            {
                "key": "Fmul",
                "icon": 3,
                "documentation": "The FMUL function performs the floating point multiplication of two numeric values. Both expression1 and expression 2 must evaluate to non-null numeric value. If either of the arguments evaluates to null then a run time 'non-numeric' error will occur. The calculation is not subject to the PRECISION setting.",
                "detail": "FMUL(expression1, expression2)",
                "snippet": "FMUL(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Fold",
                "icon": 3,
                "documentation": "The FOLD function re-delimits a string by replacing spaces with attribute marks at positions defined by a length parameter. expression1 evaluates a string to be re-delimited. expression2 evaluates to a positive integer that represents the maximum number of characters between delimiters in the resultant string. The FOLD function creates a number of sub-strings such that the length of each sub-string does not exceed the length value in expression2. Spaces are converted to attribute marks except when in enclosed in sub-strings. Extraneous spaces are removed.",
                "detail": "FOLD(expression1, expression2)",
                "snippet": "FOLD(${1:expression1}, ${2:expression2}, ${3:expression3})"
            },
            {
                "key": "Footing",
                "icon": 14,
                "documentation": "The FOOTING statement causes all subsequent output to the terminal to be halted at the end of each output page. The expression should evaluate to a string that will be printed at the bottom of every page of output. The string may contain a number of special characters that are interpreted and replaced in the string before it is printed.",
                "detail": "FOOTING expression",
                "snippet": "FOOTING ${1:expression}"
            },
            {
                "key": "For",
                "icon": 14,
                "documentation": "The FOR statement allows the programming of looping constructs within the program. The loop is controlled by a counting variable and may be terminated early by expressions tested after every iteration. var is the counting variable used to control the loop. The first time the loop is entered var is assigned the value of expression1, which must evaluate to a numeric value. After every iteration of the loop var is automatically incremented by 1. expression2 must also evaluate to a numeric value as it causes the loop to terminate when the value of var is greater than the value of this expression. expression2 is evaluated at the start of every iteration of the loop and compared with the value of expression1. If the STEP expression3 clause is included within the statement, var will automatically be incremented by the value of expression3 after each iteration of the loop. expression3 is evaluated at the start of each iteration. expression3 may be negative, in which case the loop will terminate when var is less than expression2. The statement may optionally include either a WHILE or UNTIL clause (not both), which will be evaluated before each iteration of the loop. When the WHILE clause is specified, the loop will only continue with the next iteration if expression4 evaluates to Boolean TRUE. When the UNTIL clause is specified the loop will only continue with the next iteration if expression4 evaluates to Boolean FALSE. Because expression2 and expression3 must be evaluated upon each iteration of the loop, complex expressions should only be coded here if they may change within each iteration. If the values they yield will not change then the value of these expressions should be assigned to a variable before coding the loop statement. Expressions 3 and 4 should then be replaced with these variables. This can offer large performance increases where complex expressions are being used.",
                "detail": "FOR var = expression1 TO expression2 {STEP expression3}\n\n{WHILE | UNTIL expression4}\nNEXT {var}",
                "snippet": "FOR ${1:var} = ${2:expression1} TO ${3:expression2} \n\t${4:statements}\nNEXT ${5:var}"
            },
            {
                "key": "FormList",
                "icon": 14,
                "documentation": "The FORMLIST statement creates an active select list from a dynamic array. variable1 specifies the dynamic array from which the active select list is to be created If variable2 is specified then the newly created list will be placed in the variable. Alternatively, a select list number in the range 0 to 10 can be specified with listnum. If neither variable2 nor listnum is specified then the default list variable will be assumed.",
                "detail": "FORMLIST variable1 {TO variable2 | listnum}",
                "snippet": "FORMLIST ${1:variable1} TO ${2:variable2}"
            },
            {
                "key": "Fsub",
                "icon": 3,
                "documentation": "The FSUB function performs the floating point subtraction of two numeric values. Both expression1 and expression 2 must evaluate to non-null numeric values. If either of the arguments evaluates to null then a run time 'non-numeric' error will occur.",
                "detail": "FSUB(expression1, expression2)",
                "snippet": "FSUB(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Function",
                "icon": 14,
                "documentation": "Identifies a user-defined function which can be invoked by other jBC programs. Arguments to the function can optionally be declared. name is the name by which the function is invoked. variable is an expression used to pass values between the calling program and the function. The FUNCTION statement is used to identify user-written source code functions. Each function must be coded in separate records and the record Id must match that of the Function Name, which in turn should match the reference in the calling program. The optional comma separated variable list can be a number of expressions that pass values between the calling programs and the function. To pass an array the variable name must be preceded by the MAT keyword. When a user-written function is called, the calling program must specify the same number of variables as are specified in the FUNCTION statement. An extra 'hidden' variable is used to return a value from the user-written function. The value to be returned can be specified within the Function by the RETURN (value) statement. If the RETURN statement is used without a value then by default an empty string is returned. The calling program must specify a DEFFUN or DEFB statement to describe the function to be called and the function source must be cataloged and locatable similar to subroutines.",
                "detail": "FUNCTION name {({MAT} variable, {MAT} variable...) }",
                "snippet": "FUNCTION ${1:name}(${2:arguments})\n\t${3:statements}\nRETURN (${4:var})"
            },
            {
                "key": "Ges",
                "icon": 3,
                "documentation": "The GES function performs a comparison of corresponding elements in two dynamic arrays. If an element from the first dynamic array is greater than or equal to the corresponding element in the second dynamic array ,then a 1 is placed in the corresponding element of the resultant dynamic array. If an element from the first dynamic array is less than the corresponding element in the second dynamic array, then a 0 is placed in the corresponding element of the resultant dynamic array.",
                "detail": "GES(DynArr1, DynArr2)",
                "snippet": "GES(${1:array1}, ${2:array2})"
            },
            {
                "key": "Get",
                "icon": 14,
                "documentation": "The GET statement reads a block of data directly from a device. Var is the variable in which to place the input (from the previously open Device). If length is specified, it limits the number of characters read from the input device. If the optional Count option is used, it returns the number of characters actually read from the device. Device is the file variable associated with the result from a successful OPENSEQ or OPENSER command. TermChars specifies one or more characters that will terminate input. TermChar The actual character that terminated input. Timeout is the number of seconds to wait for input. If no input is present when the timeout period expires, the ELSE clause (if specified) is executed. The GET statement does no pre-or post-processing of the input data stream - nor does it handle any terminal echo characteristics. It is assumed that if this is desired the application - or device drive - will handle it. If the length and timeout expressions are not specified, the default input length is one (1) character. If no length is specified, but TermChars are, there is no limit to the number of characters input. The GET syntax requires that either a THEN or ELSE clause, or both, be specified. If the data is received without error, the THEN clause is executed. If the data cannot be received (or a timeout occurs), the ELSE clause is executed.",
                "detail": "GET Var {,length} {SETTING Count} FROM Device {UNTIL TermChars} {RETURNING TermChar} {WAITING Timeout} THEN | ELSE statements",
                "snippet": "GET ${1:Var},${2:length} SETTING ${3:Count} FROM ${4:Device} UNTIL ${5:TermChars} RETURNING ${6:TermChar} WAITING ${7:Timeout} THEN\n\t${8:then_statements}\nEND ELSE\n\t${9:else_statements}\nEND"
            },
            {
                "key": "Getx",
                "icon": 14,
                "documentation": "The GETX statement reads a block of data (in ASCII hexadecimal format) directly from a device. Var is the variable in which to place the input (from the previously open Device). If length is specified, it limits the number of characters read from the input device. If the optional Count option is used, it returns the number of characters actually read from the device. Device is the file variable associated with the result from a successful OPENSEQ or OPENSER command. TermChars specifies one or more characters that will terminate input. TermChar The actual character that terminated input. Timeout is the number of seconds to wait for input. If no input is present when the timeout period expires, the ELSE clause (if specified) is executed. The GETX statement does no pre-or post-processing of the input data stream - nor does it handle any terminal echo characteristics. It is assumed that if this is desired the application - or device drive - will handle it. If the length and timeout expressions are not specified, the default input length is one (1) character. If no length is specified, but TermChars are, there is no limit to the number of characters input. The GETX syntax requires that either a THEN or ELSE clause, or both, be specified. If the data is received without error, the THEN clause is executed. If the data cannot be received (or a timeout occurs), the ELSE clause is executed. GETX will convert all input into ASCII hexadecimal format after input.",
                "detail": "GETX Var {,length} {SETTING Count} FROM Device {UNTIL TermChars} {RETURNING TermChar} {WAITING Timeout} THEN | ELSE statements",
                "snippet": "GETX ${1:Var},${2:length} SETTING ${3:Count} FROM ${4:Device} UNTIL ${5:TermChars} RETURNING ${6:TermChar} WAITING ${7:Timeout} THEN\n\t${8:then_statements}\nEND ELSE\n\t${9:else_statements}\nEND"
            },
            {
                "key": "Getcwd",
                "icon": 3,
                "documentation": "The GETCWD function allows a jBC program to determine the current working directory of the program. This will normally be the directory from which the program was executed but may have been changed with the CHDIR function. When executed the Var will be set to the name of the current working directory. The function itself returns a Boolean TRUE or FALSE value indicating whether the command was successful or not. Refer to your UNIX or Windows documentation (sh is a good place to start), for more information on the concept of the current working directory.",
                "detail": "GETCWD(Var)",
                "snippet": "GETCWD(${1:Var})"
            },
            {
                "key": "Getenv",
                "icon": 3,
                "documentation": "The GETENV function allows a jBC program to determine the value of any of the environment variables associated with it. The expression should evaluate to the name of the environment variable whose value is to be returned. The function will then assign the value of the environment variable to variable. The function itself returns a Boolean TRUE or FALSE value indicating the success or failure of the function.",
                "detail": "GETENV(expression, variable)",
                "snippet": "GETENV(${1:expression}, ${2:variable})"
            },
            {
                "key": "Getlist",
                "icon": 14,
                "documentation": "GETLIST allows the program to retrieve a previously stored list (perhaps created with the SAVE-LIST command), into a jBC variable. variable1 is the variable into which the list will be read. expression should evaluate to the name of a previously stored list to retrieve, or null. If expression evaluates to null, the current default external select list (generated by a previous SELECT command for example) will be retrieved. If specified, variable2 will be set to the number of elements in the list. If the statement succeeds in retrieving the list, then the statements associated with any THEN clause will be executed. If the statement fails to find the list, then the statements associated with any ELSE clause will be executed. The GETLIST statement is identical in function to the READLIST statement.",
                "detail": "GETLIST expression TO variable1 {SETTING variable2} THEN|ELSE statements",
                "snippet": "GETLIST ${1:listname} TO ${2:variable1} SETTING ${3:variable2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Getusergroup",
                "icon": 14,
                "documentation": "For UNIX, the jBC function GETUSERGROUP returns the group number for the user ID specified by @uid.",
                "detail": "GETUSERGROUP($uid)",
                "snippet": "GETUSERGROUP(${1:uid})"
            },
            {
                "key": "Gosub",
                "icon": 14,
                "documentation": "The GOSUB statement causes execution of a local subroutine, after which execution will continue with the next line of code. The label should refer to an existent label within the current source code. This label denotes the start of a local subroutine. Labels can be numeric or alphanumeric but an alphanumeric label must be terminated with a colon when used to denote the start of a local subroutine. Numeric labels can be terminated with a colon but it is not mandatory. The use of the colon in the GOSUB statement is optional.",
                "detail": "GOSUB label[:]",
                "snippet": "GOSUB ${1:label}"
            },
            {
                "key": "Goto",
                "icon": 14,
                "documentation": "The GOTO statement causes program execution to jump to the code at a specified label. The label should refer to an existing label within the current source code. Labels can be numeric or alphanumeric but alphanumeric labels must be terminated with a colon. Numeric labels can be terminated with a colon but it is not mandatory. The use of the colon in the GOTO statement is optional.  The use of the GOTO command is not recommended as it obscures the readability of code and therefore is a hindrance to maintainability. All programs written using the GOTO construct can be written using structured statements such as LOOP and FOR. Opinions on this are divided but the consensus is that GOTO should be avoided. One possibly acceptable use of the GOTO statement is to transfer execution to an error handler upon detection of a fatal error that will cause the program to terminate.",
                "detail": "GOTO label[:]\nGO TO label[:]\nGO label[:]",
                "snippet": "GOTO ${1:nope}"
            },
            {
                "key": "Group",
                "icon": 3,
                "documentation": "The GROUP function is equivalent to the FIELD function. Expression1 evaluates to the string containing fields to be extracted. Expression2 evaluates to the character(s) delimiting each field within Expression1. Expression3 should evaluate to a numeric value specifying the number of the first field to extract from Expression1. Expression4 evaluates to a numeric value specifying the number of fields to extract as a group. Expression2 may evaluate to more than a single character allowing fields to be delimited with complex expressions.",
                "detail": "GROUP(Expression1, Expression2, Expression3, Expression4)",
                "snippet": "GROUP(${1:subject}, ${2:delimiter}, ${3:first_field}, ${4:num_to_extract})"
            },
            {
                "key": "Groupstore",
                "icon": 14,
                "documentation": "The GROUPSTORE statement substitutes one group of characters with another group of characters. from.var The string which will be inserted into the 'to.var' variable. to.var The string which will be amended. start The starting group number in 'to.var' which will be replaced. \tIf 'start' is less than 0 , then the absolute value of 'start' is used. If 'start' is zero, then it defaults to 1. \tIf 'start' exceeds the number of groups in 'to.var' then delimiters will be added as necessary. replace The number of groups in 'to.var' that will be replaced. \tIf 'replace' is greater than 0, then 'replace' groups of 'from.var' will replace 'replace' groups in 'from.var' \tIf 'replace' is 0 , then all of 'from.var' will be inserted. \tIf 'replace' is less than 0, the absolute value of 'replace' is used. delim This optionally specifies the delimiting character to use, with an attribute mark (CHAR(254)) as a default. \tIf the string is more than one character, only the first character is used.",
                "detail": "GROUPSTORE from.var IN to.var USING start,replace{,delim}",
                "snippet": "GROUPSTORE ${1:fromvar} IN ${2:tovar} USING ${3:start}, ${4:replace}"
            },
            {
                "key": "Heading",
                "icon": 14,
                "documentation": "The HEADING statement causes all subsequent output to the terminal to be halted at the end of each page. The statement allows an expression to be evaluated and displayed at the top of each page. If output is currently being sent to the terminal, output is paused until a carriage return is entered at the terminal - unless the N option is specified. The expression should evaluate to a string that will be printed at the top of every page of output. The string may contain a number of special characters that are interpreted and replaced in the string before it is printed. If ON channel is specified then it is assumed that a PRINTER ON statement is in force and the heading will be sent to the spooler channel number assigned from a SP-ASSIGN statement. If output is being directed to the printer (a PRINTER ON statement is in force), output sent to the terminal with the CRT statement will not be paged. If output is being sent to the terminal, all output will be paged unless the N option is specified. The second and subsequent HEADING statements cause a page throw in the output to the terminal or the printer. However if the HEADING expression is preceded by an attribute mark then the page throw does not occur and the new heading is used at the next 'natural' page break or PAGE statement. The emulation option 'defer_header_output' can also be used to obtain this behavior without using the attribute mark.",
                "detail": "HEADING {ON channel} expression",
                "snippet": "HEADING ${1:expression}"
            },
            {
                "key": "Headinge",
                "icon": 14,
                "documentation": "The HEADINGE statement is the same as the HEADING statement, but causes a page eject with the HEADING statement.",
                "detail": "HEADINGE {ON channel} expression",
                "snippet": "HEADINGE ${1:expression}"
            },
            {
                "key": "Headingn",
                "icon": 14,
                "documentation": "The HEADINGN statement is the same as the HEADING statement, but suppresses the page eject.",
                "detail": "HEADINGN {ON channel} expression",
                "snippet": "HEADINGN ${1:expression}"
            },
            {
                "key": "Hush",
                "icon": 14,
                "documentation": "The HUSH statement turns the echoing of characters typed at the keyboard on or off. ON suppresses input and output OFF resumes input and output INPUT suppresses input only expression must evaluate to one of the above values HUSH acts as a toggle. If it is used without a qualifier, it changes the current state. It is not recommended that the statement be used to shut off output display unless it is really necessary. When HUSH ON is used, all output is suppressed including error messages and requests for information.",
                "detail": "HUSH ON\nHUSH OFF\nHUSH expression",
                "snippet": "HUSH ${1:expression}"
            },
            {
                "key": "Iconv",
                "icon": 3,
                "documentation": "The ICONV function converts data in external form such as dates to their internal form. expression1 evaluates to the data that the conversion is to be performed upon. expression2 should evaluate to the conversion code that is to be performed against the data. If the conversion code used assumes a numeric value and a non-numeric value is passed then the original value in expression1 is returned unless the emulation option 'iconv_nonnumeric_return_null' is set.",
                "detail": "ICONV(expression1, expression2)",
                "snippet": "ICONV(${1:subject}, ${2:convcode})"
            },
            {
                "key": "Iconvs",
                "icon": 3,
                "documentation": "The ICONVS function converts each element of a dynamic array to a specified internal storage format. conversion is an expression that evaluates to one or more valid conversion codes, separated by value marks (ASCII 253). Each element of dynamic.array is converted to the internal format specified by conversion and is returned in a dynamic array. If multiple codes are used, they are applied from left to right. The first conversion code converts the value of each element of dynamic.array. The second conversion code converts the value of each element of the output of the first conversion, and so on. If dynamic.array evaluates to null, it returns null. If an element of dynamic.array is null, it returns null for that element. If conversion evaluates to null, the ICONV function fails and the program terminates with a run-time error message. The STATUS function will reflect the result of the conversion.",
                "detail": "ICONVS(dynamic array, conversion)",
                "snippet": "ICONVS(${1:DynArr}, ${2:conversion})"
            },
            {
                "key": "If",
                "icon": 14,
                "documentation": "The IF statement is used to allow other statements to be conditionally executed. The expression will be evaluated to a value of Boolean TRUE or FALSE. If the expression is TRUE then the statements defined by the THEN clause will be executed (if present). If the expression is FALSE then the statements defined by the ELSE clause are executed. The THEN and ELSE clauses may take two different forms, being either single and multiple line statements.",
                "detail": "IF expression THEN statements",
                "snippet": "IF ${1:expression} THEN ${2:statements}"
            },
            {
                "key": "Ifs",
                "icon": 3,
                "documentation": "The IFS function returns a dynamic array whose elements are chosen individually from one of two dynamic arrays based on the contents of a third dynamic array. IFS evaluates each element of the dynamic array. If the element evaluates to true, it returns the corresponding element from true.array to the same element of a new dynamic array. If the element evaluated to false, it returns the corresponding element from false.array. If there is no corresponding element in the correct response array, it returns an empty string for that element. If an element is null, the element evaluates to false.",
                "detail": "IFS (dynamic.array, true.array, false.array)",
                "snippet": "IFS(${1:dynamic_array}, ${2:true_array}, ${3:false_array})"
            },
            {
                "key": "In",
                "icon": 14,
                "documentation": "The IN statement allows the program to receive raw data from the input device, which is normally the terminal keyboard, one character at a time. Var will be assigned the numeric value (0 - 255 decimal) of the next character received from the input device. The statement will normally wait indefinitely (block) for a character from the keyboard. Specifying the FOR clause to the IN statement allows the statement to stop waiting for keyboard after a specified amount of time. The expression should evaluate to a numeric value, which will be taken as the number of deci-seconds (tenths of a second) to wait before abandoning the input. The FOR clause must have either or both of the THEN or ELSE clauses. If a character is received from the input device before the time-out period then Var is assigned its numeric value and the THEN clause is executed (if present). If the input statement times out before a character is received then Var is unaltered and the ELSE clause is executed (if present).",
                "detail": "IN Var {FOR expression THEN|ELSE statements}",
                "snippet": "IN ${1:var}"
            },
            {
                "key": "Include",
                "icon": 14,
                "documentation": "The INCLUDE directive inserts the program\/code snippet specified into the current source code. If the optional filename is specified the code is read from that file.",
                "detail": "INCLUDE programname\nINCLUDE filename programname",
                "snippet": "INCLUDE ${1:programname}"
            },
            {
                "key": "Index",
                "icon": 3,
                "documentation": "The INDEX function will return the position of a character or characters within another string. expression1 evaluates to the string to be searched. expression2 evaluates to the string or character that will be searched for within expression1. expression3 should evaluate to a numeric value and specifies which occurrence of expression2 should be searched for within expression1. If the specified occurrence of expression2 cannot be found in expression1 then 0 is returned.",
                "detail": "INDEX(expression1, expression2, expression3)",
                "snippet": "INDEX(${1:subject}, ${2:search}, ${3:occurrence})"
            },
            {
                "key": "Indices",
                "icon": 3,
                "documentation": "The INDICES function will return information on all of the indexes associated with a specified file. This function has a dual purpose. In its first invocation whereby a single parameter is passed, assumed to be a file descriptor, will return a dynamic array of all the index names associated with the file. In its second invocation two parameters are passed, the first being a file variable again and the second the name of an index. In this case the return value from the function will be a dynamic array containing information about the specified index.",
                "detail": "INDICES(filevar { , index-name } )",
                "snippet": "INDICES(${1:filevar}, ${2:indexname})"
            },
            {
                "key": "Inmat",
                "icon": 3,
                "documentation": "The INMAT() function returns the number of dimensioned array elements. The INMAT() function, used without the 'array' argument, returns the number of dimensioned array elements from the most recent MATREAD, MATREADU or MATPARSE statement. If the number of array elements exceeds the number of elements specified in the corresponding DIM statement, the INMAT() function will return zero. When the INMAT() function is used with the 'array' argument, it returns the current number of elements to which 'array' was dimensioned. In some multi-value dialects the INMAT() function is also used to return the modulo of a file after the execution of an OPEN statement. This is inconsistent with its primary purpose and has not been implemented in jBASE. To achieve this functionality use the IOCTL() function with the JIOCTL_COMMAND_FILESTATUS command.",
                "detail": "INMAT( {array} )",
                "snippet": "INMAT(${1:array})"
            },
            {
                "key": "Input",
                "icon": 14,
                "documentation": "The INPUT statement allows the program to collect data from the current input device, which will normally be the terminal keyboard but may be stacked input from the same or separate program. @(expression1, expression2) allows the screen cursor to be positioned to the specified column and row before the input prompt is sent to the screen. The syntax for this is exactly the same as for the @() function described elsewhere. Var is the variable in which the input data is to be stored. expression3, when specified, should evaluate to a numeric value. This will cause input to be terminated with an automatic newline sequence after exactly this number of characters has been input. If the _ option is specified with expression4 then the automatic newline sequence is not specified but any subsequent input characters are belled to the terminal and thrown away. expression4, when specified, should evaluate to a sequence of 1 to 3 characters. The first character will be printed 'expression3' times to define the field on the terminal screen. At the end of the input, if less than 'expression3' characters were input, then the rest of the field is padded with the second character if it was supplied. If the third character is supplied then the cursor will be positioned after the last character input rather than at the end of the input field. The : option, when specified, suppress the echoing of the newline sequence to the terminal. This will leave the cursor positioned after the last input character on the terminal screen. WITH expression5 allows the default input delimiter (the newline sequence) to be changed. When specified, expression5, should evaluate to a string of up to 256 characters, each of which may delimit the input field. If this clause is used then the newline sequence is removed as a delimiter and must be specified explicitly within expression5 as CHAR(10). The FOR clause allows the INPUT statement to time out after a specified waiting period instead of blocking as normal. Expression6 should evaluate to a numeric value, which will be taken as the number of deci-seconds (tenths of a second) to wait before timing out. The time-out value is used as the time between each keystroke and should a time-out occur, Var will hold the characters that were input until the time-out. The FOR clause requires either or both of the THEN and ELSE clauses. If no time-out occurs the THEN clause is taken. If a time-out does occur the ELSE clause is taken.",
                "detail": "INPUT {@(expression1{, expression2 )}{:} Var{{, expression3}, expression4} {:}{_} {WITH expression5} {FOR expression6 THEN|ELSE statements}",
                "snippet": "INPUT ${1:var}"
            },
            {
                "key": "Input @",
                "icon": 14,
                "documentation": "The INPUT statement allows the program to collect data from the current input device, which will normally be the terminal keyboard but may be stacked input from the same or separate program. @(expression1, expression2) allows the screen cursor to be positioned to the specified column and row before the input prompt is sent to the screen. The syntax for this is exactly the same as for the @() function described elsewhere. Var is the variable in which the input data is to be stored. expression3, when specified, should evaluate to a numeric value. This will cause input to be terminated with an automatic newline sequence after exactly this number of characters has been input. If the _ option is specified with expression4 then the automatic newline sequence is not specified but any subsequent input characters are belled to the terminal and thrown away. expression4, when specified, should evaluate to a sequence of 1 to 3 characters. The first character will be printed 'expression3' times to define the field on the terminal screen. At the end of the input, if less than 'expression3' characters were input, then the rest of the field is padded with the second character if it was supplied. If the third character is supplied then the cursor will be positioned after the last character input rather than at the end of the input field. The : option, when specified, suppress the echoing of the newline sequence to the terminal. This will leave the cursor positioned after the last input character on the terminal screen. WITH expression5 allows the default input delimiter (the newline sequence) to be changed. When specified, expression5, should evaluate to a string of up to 256 characters, each of which may delimit the input field. If this clause is used then the newline sequence is removed as a delimiter and must be specified explicitly within expression5 as CHAR(10). The FOR clause allows the INPUT statement to time out after a specified waiting period instead of blocking as normal. Expression6 should evaluate to a numeric value, which will be taken as the number of deci-seconds (tenths of a second) to wait before timing out. The time-out value is used as the time between each keystroke and should a time-out occur, Var will hold the characters that were input until the time-out. The FOR clause requires either or both of the THEN and ELSE clauses. If no time-out occurs the THEN clause is taken. If a time-out does occur the ELSE clause is taken.",
                "detail": "INPUT {@(expression1{, expression2 )}{:} Var{{, expression3}, expression4} {:}{_} {WITH expression5} {FOR expression6 THEN|ELSE statements}",
                "snippet": "INPUT @(${1:col}, ${2:row}):${3:var}"
            },
            {
                "key": "Inputclear",
                "icon": 14,
                "documentation": "The INPUTCLEAR statement clears the type-ahead buffer. INPUTCLEAR only clears the type-ahead buffer. It does not clear data stacked with the DATA statement. The INPUTCLEAR statement is synonymous with CLEARINPUT.",
                "detail": "INPUTCLEAR",
                "snippet": "INPUTCLEAR"
            },
            {
                "key": "Inputnull",
                "icon": 14,
                "documentation": "The INPUTNULL statement allows the definition of a character that will allow a null input to be seen by the INPUT@ statement. The expression should evaluate to a single character. Subsequently, any INPUT@ statement that sees only this character input before the new-line sequence will NULL the variable in which input is being stored. If expression evaluates to the NULL string \" then the default character of _ is used to define a NULL input sequence. The INPUT statement does not default to accepting the _ character as a NULL input, the programmer must explicitly allow this with the statement: \tINPUTNULL \"",
                "detail": "INPUTNULL expression",
                "snippet": "INPUTNULL ${1:expression}"
            },
            {
                "key": "Ins",
                "icon": 14,
                "documentation": "The INS statement allows the insertion of elements into a dynamic array. expression evaluates to the element to be inserted in the dynamic array. expression1, expression2 and expression3 should all evaluate to numeric values and specify the Field, Value and Sub-Value before which the new element is to be inserted. Specifying a negative value to any of expressions 1 through 3 will cause the element to be appended as the last Field, Value or Sub-Value rather than at a specific position. Only one of the expressions may be negative, otherwise the first negative value is used correctly but the others are treated as the value 1. The statement will insert NULL Fields, Values or Sub-Values accordingly if any of the specified insertion points exceeds the number currently existing.",
                "detail": "INS expression BEFORE Var",
                "snippet": "INS ${1:expression} BEFORE ${2:Var}<${3:attr}, ${4:value}, ${5:subvalue}>"
            },
            {
                "key": "Insert",
                "icon": 3,
                "documentation": "INSERT is the function form of the INS statement, which should be used in preference to this function. expression1 evaluates to a dynamic array in which to insert a new element and will normally be a variable. expression2, expression3 and expression4 should evaluate to numeric values and specify the Field, Value and Sub-Value before which the new element will be inserted. expression5 evaluates to the new element to be inserted in expression1.",
                "detail": "INSERT(expression1, expression2{, expression3 {, expression4 }}; expression5)",
                "snippet": "INSERT(${1:DynArr}, ${2:attr}, ${3:value}, ${4:subvalue}; ${5:expression})"
            },
            {
                "key": "Int",
                "icon": 3,
                "documentation": "The INT function truncates a numeric value into its nearest integer form. expression should evaluate to a numeric value. The function will then return the integer portion of the value. The function works by truncating the fractional part of the numeric value rather than by standard mathematical rounding techniques. Therefore INT(9.001) and INT(9.999) will both return the value 9.",
                "detail": "INT(expression)",
                "snippet": "INT(${1:expression})"
            },
            {
                "key": "Ioctl",
                "icon": 3,
                "documentation": "The purpose of the IOCTL function is to allow commands to be sent to the database driver for a particular file, and then to receive a reply from that same databasedriver. Filevar\tIs a variable that has had a file opened against it using the OPEN statement. \tHowever, if you want to use the default file variable, use -1 in this position. Command\tCan be any numeric value (or variable containing a numeric). \tHowever, it is up to the database driver to support that particular command number. Status\tProvide a jBC variable here. \tThe use of this variable depends upon the command parameter. \tThe return value is 0 for failure, or 1 for success. \tA value of -1 generally shows the command has not been recognized.",
                "detail": "IOCTL(Filevar, Command, Parameter)",
                "snippet": "IOCTL(${1:filevar}, ${2:command}, ${3:parameter})"
            },
            {
                "key": "Isalnum",
                "icon": 3,
                "documentation": "The ISALNUM function checks that an expression consists entirely of alphanumeric characters. expression can return a result of any type. The ISALNUM function will then return TRUE (1) if the expression consists of entirely alphanumeric characters. The function will return FALSE (0) if any character in the expression is not alphanumeric. When the ISALNUM function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
                "detail": "ISALNUM( expression)",
                "snippet": "ISALNUM(${1:expression})"
            },
            {
                "key": "Isalpha",
                "icon": 3,
                "documentation": "The ISALPHA function checks that an expression consists entirely of alphabetic characters. expression can return a result of any type. The ISALPHA function will then return TRUE (1) if the expression consists of entirely alphabetic characters. The function will return FALSE (0) if any character in the expression is not alphabetic. When the ISALPHA function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
                "detail": "ISALPHA( expression)",
                "snippet": "ISALPHA(${1:expression})"
            },
            {
                "key": "Iscntrl",
                "icon": 3,
                "documentation": "The ISCNTRL function checks that an expression consists entirely of control characters. expression can return a result of any type. The ISCNTRL function will then return TRUE (1) if the expression consists of entirely control characters. The function will return FALSE (0) if any character in the expression is not a control character. When the ISCNTRL function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
                "detail": "ISCNTRL( expression)",
                "snippet": "ISCNTRL(${1:expression})"
            },
            {
                "key": "Isdigit",
                "icon": 3,
                "documentation": "The ISDIGIT function checks that an expression consists entirely of numeric characters. expression can return a result of any type. The ISDIGIT function will then return TRUE (1) if the expression consists entirely of numeric characters. The function will return FALSE (0) if any character in the expression is not numeric. When the ISDIGIT function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
                "detail": "ISDIGIT( expression)",
                "snippet": "ISDIGIT(${1:expression})"
            },
            {
                "key": "Islower",
                "icon": 3,
                "documentation": "The ISLOWER function checks that an expression consists entirely of lower case characters. expression can return a result of any type. The ISLOWER function will then return TRUE (1) if the expression consists of entirely lower case characters. The function will return FALSE (0) if any character in the expression is not lower case. When the ISLOWER function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
                "detail": "ISLOWER( expression)",
                "snippet": "ISLOWER(${1:expression})"
            },
            {
                "key": "Isprint",
                "icon": 3,
                "documentation": "The ISPRINT function checks that an expression consists entirely of printable characters. expression can return a result of any type. The ISPRINT function will then return TRUE (1) if the expression consists of entirely printable characters. The function will return FALSE (0) if any character in the expression is not printable. When the ISPRINT function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
                "detail": "ISPRINT( expression)",
                "snippet": "ISPRINT(${1:expression})"
            },
            {
                "key": "Isspace",
                "icon": 3,
                "documentation": "The ISSPACE function checks that an expression consists entirely of space characters. expression can return a result of any type. The ISSPACE function will then return TRUE (1) if the expression consists of entirely space type characters. The function will return FALSE (0) if any character in the expression is not a space. When the ISSPACE function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
                "detail": "ISSPACE( expression)",
                "snippet": "ISSPACE(${1:expression})"
            },
            {
                "key": "Isupper",
                "icon": 3,
                "documentation": "The ISUPPER function checks that an expression consists entirely of upper case characters. expression can return a result of any type. The ISUPPER function will then return TRUE (1) if the expression consists of entirely upper case characters. The function will return FALSE (0) if any character in the expression is not upper case. When the ISUPPER function is used in International Mode the properties of each character are determined according to the Unicode Standard.",
                "detail": "ISUPPER( expression)",
                "snippet": "ISUPPER(${1:expression})"
            },
            {
                "key": "Itype",
                "icon": 3,
                "documentation": "The ITYPE function is used to return the value resulting from the evaluation of an I-type expression in a jBASE file dictionary. i.type is an expression evaluating to the contents of an existing I-descriptor. If i.type evaluates to null, the ITYPE function fails and the program terminates with a run-time error message. Set @FILENAME to the name of the file before ITYPE execution.",
                "detail": "ITYPE(i.type)",
                "snippet": "ITYPE(${1:itype})"
            },
            {
                "key": "Jbasecoredump",
                "icon": 3,
                "documentation": "The JBASECOREDUMP function is a diagnostic tool for applications that allows a portion of the application to be dumped to an external file for later analysis. The first expression provides the name of the operating system file to output the core dump to. You can supply \"\" instead of a file name and jBASE allocates a filename of: \t\/JBASECOREDUMP_nnnn_mmmmm where nnn is the port number and mmmmmm is the process id. The second expression is not used at present. Future versions will allow extra information to be selectively dumped. A null string is always returned from the function.",
                "detail": "JBASECOREDUMP(expression1, expression2)",
                "snippet": "JBASECOREDUMP(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Jbasethreadcreate",
                "icon": 3,
                "documentation": "The JBASETHREADCreate function starts a new thread from the current process. ProgramName\tName of program to execute Arguments\tCommand line arguments Reserved\tThis internal string parameter is required and must always be set to \"\" (null) Handle\tThis variable will contain the returned thread handle",
                "detail": "JBASETHREADCreate(ProgramName, Arguments, Reserved, Handle)",
                "snippet": "JBASETHREADCreate(${1:ProgramName}, ${2:Arguments}, ${3:User}, ${4:Handle})"
            },
            {
                "key": "Jbasethreadstatus",
                "icon": 3,
                "documentation": "The JBASETHREADStatus function returns the status of all running threads. ThreadList\tA list of all active thread handles in this process, with one attribute per thread.",
                "detail": "JBASETHREADStatus(ThreadList)",
                "snippet": "JBASETHREADStatus(${1:ThreadList})"
            },
            {
                "key": "Jqlcompile",
                "icon": 3,
                "documentation": "The JQLCOMPILE function compiles a jQL statement. Statement: is the variable, which will receive the compiled statement, used by a majority of functions to execute and work on the result set etc. Command: is the actual jQL query that you want to compile (such as SELECT or something similar). Use RETRIEVE to obtain data records as the verb rather than an existing jQL verb. This will ensure that the right options are set internally. In addition, use any word that is not a jQL reserved word as the verb and it will work in the same way as RETRIEVE, implement a PLOT command that passes the entire command line into JQLCOMPILE and the results will be the same as if the first word were replaced with RETRIEVE. Option: you must specify JQLOPT_USE_SELECT to supply a select list to the JQLEXECUTE function; the compile builds a different execution plan if using select lists. Messages: If the statement fails to compile, this dynamic array is in the STOP format, therefore STOP messages can be programmed and printed. Provides a history of compilation for troubleshooting purposes; Returns -1 if there is a problem found in the statement and 0 for no problem",
                "detail": "JQLCOMPILE(Statement, Command, Options, Messages)",
                "snippet": "JQLCOMPILE(${1:Statement}, ${2:Command}, ${3:Options}, ${4:Messages})"
            },
            {
                "key": "Jqlexecute",
                "icon": 3,
                "documentation": "The JQLEXECUTE statement executes a compiled jQL statement. Statement\tis the valid result of a call to a JQLCOMPILE statement SelectVar\tis a valid select list used to limit the statement to a predefined set of items.-",
                "detail": "JQLEXECUTE(Statement, SelectVar)",
                "snippet": "JQLEXECUTE(${1:Statement}, ${2:SelectVar})"
            },
            {
                "key": "Jqlfetch",
                "icon": 3,
                "documentation": "The JQLFETCH statement fetches the next result in a compiled jQL statement. Statement: is the result of a valid call to a JQLCOMPILE statement, followed by a valid call to a  JQLEXECUTE statement. ControlVar: will receive the \u2018control break\u2019 elements of any query. DataVar: will receive the actual screen data on a LIST statement for instance. The format is one attribute per column. Applies Attribute 7 Conversions (or attribute 3 in Prime-style DICTS) to the data. If the property STMT_PROPERTY_FORMAT is set then each attribute is also formatted according to the width and justification of the attribute definition and any override caused by the use of FMT, of DISPLAY.LIKE on the command line NOTE that column headers may also affect the formatting for that column. This function is called until there is no more output (multiple).",
                "detail": "JQLFETCH(Statement, ControlVar, DataVar)",
                "snippet": "JQLFETCH (${1:Statement}, ${2:ControlVar}, ${3:DataVar})"
            },
            {
                "key": "Jqlgetproperty",
                "icon": 3,
                "documentation": "The JQLGETPROPERTY statement gets the value of a specified property from a compiled jQL statement. PropertyValue\treceives the requested property value from the system or '' if the property is not set. Statement\tis the result of a valid JQLCOMPILE statement. Column\tspecifies that you want the value of the property for a specific column (otherwise 0 for the whole statement). PropertyName\trefers to the equated values defined by including the file JQLINTERFACE.h. \tThis function returns -1 if there is a problem with the parameters or the programmer. These properties answer questions such as 'Was LPTR mode asked for?' and 'How many columns are there?' Note: Properties are valid after the compile; this is the main reason for separating the compile and execute into two functions. After compiling, it is possible examine the properties and set properties before executing.",
                "detail": "JQLGETPROPERTY(PropertyValue, Statement, Column, PropertyName)",
                "snippet": "JQLGETPROPERTY(${1:PropertyValue}, ${2:Statement}, ${3:Column}, ${4:PropertyName})"
            },
            {
                "key": "Jqlputproperty",
                "icon": 3,
                "documentation": "The JQLPUTPROPERTY statement sets the value of a specified property in a compiled jQL statement. PropertyValue\tis the value to which you want to set the specified property. Statement\tis the result of a valid JQLCOMPILE statement. NOTE:\tSome properties may require  JQLEXECUTE first. Column\tholds 0 for a general property of the statement, or a column number if it is something that can be set for a specific column. PropertyName\trefers to the equated values defined by including the file JQLINTERFACE.h. This function returns -1 if it locates a problem in the statement and zero for no problem. Note: Properties are valid after the compile; this is the main reason for separating the compile and execute into two functions. After compiling, it is possible examine the properties and set properties before executing.",
                "detail": "JQLPUTPROPERTY(PropertyValue, Statement, Column, PropertyName)",
                "snippet": "JQLPUTPROPERTY(${1:PropertyValue}, ${2:Statement}, ${3:Column}, ${4:PropertyName})"
            },
            {
                "key": "Keyin",
                "icon": 3,
                "documentation": "The KEYIN function reads a single character from the input buffer and returns it. KEYIN uses raw keyboard input, therefore all special character handling e.g. backspace is disabled. System special character handling such as processing of interrupts is unchanged.",
                "detail": "KEYIN()",
                "snippet": "KEYIN()"
            },
            {
                "key": "Latin1",
                "icon": 3,
                "documentation": "The LATIN1 function converts a UTF-8 byte sequence into the binary or latin1 equivalent. The expression is to be a UTF-8 encoded byte sequence, which is the default format when executing in International Mode.",
                "detail": "LATIN1(expression)",
                "snippet": "LATIN1(${1:expression})"
            },
            {
                "key": "Left",
                "icon": 3,
                "documentation": "The LEFT function extracts a sub-string of a specified length from the beginning of a string. expression evaluates to the string from which the sub string is extracted. length is the number of characters that are extracted. If length is less than 1, LEFT() returns null. The LEFT() function is equivalent to sub-string extraction starting from the first character position, i.e. expression[1,length]",
                "detail": "LEFT(expression, length)",
                "snippet": "LEFT(${1:expression}, ${2:length})"
            },
            {
                "key": "Len",
                "icon": 3,
                "documentation": "The LEN function returns the character length of the supplied expression. expression can evaluate to any type and the function will convert it to a string automatically.",
                "detail": "LEN(expression)",
                "snippet": "LEN(${1:expression})"
            },
            {
                "key": "Lens",
                "icon": 3,
                "documentation": "The LENS function returns a dynamic array of the number of bytes in each element of a dynamic array. Each element of dynamic.array must be a string value. The characters in each element of dynamic.array are counted, with the counts returned. The LENS function includes all blank spaces, including trailing blanks, in the calculation. If dynamic.array evaluates to a null string, it returns zero (0). If any element of dynamic.array is null, returns zero (0) for that element. The LENS function when used in International Mode will return the number of characters in the specified expression rather than the number of bytes. If the expression consists of entirely of UTF-8 characters in the ASCII range 0 \u2013 127 then the character length of the expression will equate to the byte length. However, when the expression contains characters outside the ASCII range 0 \u2013 127 then byte length and character length will differ. If the byte length is specifically required then use the BYTELEN function in place of the LEN function.",
                "detail": "LENS(dynamic.array)",
                "snippet": "LENS(${1:dynamic_array})"
            },
            {
                "key": "Lendp",
                "icon": 3,
                "documentation": "The LENDP function returns the display length of an expression. The expression can evaluate to any type. The LENDP function will evaluate each character in the expression and return the calculated display length. When used in International Mode the LENDP function will return the display length for the characters in the specified expression rather than the number of bytes. NOTE: Some characters, usually Japanese, Chinese, etc. will return a display length of greater than one for certain characters. Some characters, for instance control characters or null (char 0), will return a display length of 0.",
                "detail": "LENDP(expression)",
                "snippet": "LENDP(${1:expression})"
            },
            {
                "key": "Les",
                "icon": 3,
                "documentation": "The LES function determines whether elements in one dynamic array are less than or equal to the corresponding elements in another dynamic array. Each element of array1 is compared with the corresponding element of array2. If the element from array1 is less than or equal to the element from array2, a 1 is returned in the corresponding element of a new dynamic array. If the element from array1 is greater than the element from array2, it returns a zero (0). If an element of one dynamic array has no corresponding element in the other dynamic array, it evaluates the undefined element as empty, and the comparison continues. If either of a corresponding pair of elements is null, it returns null for that element. ",
                "detail": "LES(array1, array2)",
                "snippet": "LES(${1:array1}, ${2:array2})"
            },
            {
                "key": "Ln",
                "icon": 3,
                "documentation": "The LN function returns the value of the natural logarithm of the supplied value. The expression should evaluate to a numeric value. The function will then return the natural logarithm of that value. The natural logarithm is calculated using the mathematical constant e as a number base.",
                "detail": "LN(expression)",
                "snippet": "LN(${1:expression})"
            },
            {
                "key": "Localdate",
                "icon": 3,
                "documentation": "The LOCALDATE function returns an internal date using the specified Timestamp and TimeZone combination. The LOCALDATE function uses the specified Timestamp and adjusts the value by the specified TimeZone to return the date value in internal date format.",
                "detail": "LOCALDATE(Timestamp, TimeZone)",
                "snippet": "LOCALDATE(${1:Timestamp}, ${2:TimeZone})"
            },
            {
                "key": "Localtime",
                "icon": 3,
                "documentation": "The LOCALTIME function returns an internal time using the specified Timestamp and TimeZone combination. The LOCALTIME function uses the specified Timestamp and adjusts the value by the specified TimeZone to return the time value in internal time format.",
                "detail": "LOCALTIME(Timestamp, TimeZone)",
                "snippet": "LOCALTIME(${1:Timestamp}, ${2:TimeZone})"
            },
            {
                "key": "Locate",
                "icon": 14,
                "documentation": "The LOCATE statement finds the position of an element within a specified dimension of a dynamic array. expression1 evaluates to the string that will be searched for in expression2. expression2 evaluates to the dynamic array within which expression1 will be searched for. expression3 and expression4, when specified, cause a value or subvalue search respectively. expression5 indicates the field, value or subvalue from which the search will begin. BY expression6 causes the search to expect the elements to be arranged in a specific order, which can considerably improve the performance of some searches. The available string values for expression6 are: AL Values are in ascending alphanumeric order AR Values are in right justified, then ascending order AN Values are in ascending numeric order DL Values are in descending alphanumeric order DR Values are in right justified, then descending order DN Values are in descending numeric order Var will be set to the position of the Field, Value or Sub-Value in which expression1 was found if indeed, it was found. If it was not found and expression6 was not specified then Var will be set to one position past the end of the searched dimension. If expression6 did specify the order of the elements then Var will be set to the position before which the element should be inserted to retain the specified order. The statement must include one of or both of the THEN and ELSE clauses. If expression1 is found in an element of the dynamic array the statements defined by the THEN clause are executed. If expression1 is not found in an element of the dynamic array the statements defined by the ELSE clause are executed.",
                "detail": "LOCATE expression1 IN expression2{}, {,expression5} {BY expression6} SETTING Var THEN|ELSE statement(s)",
                "snippet": "LOCATE ${1:search} IN ${2:subject} SETTING ${3:returnVar} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Locate",
                "icon": 3,
                "documentation": "The LOCATE 'function' is the equivalent of the LOCATE statement in its traditional Pick format",
                "detail": "LOCATE(expression1, expression2{,expression3{,expression4}}; Var; expression6) THEN|ELSE statements",
                "snippet": "LOCATE(${1:search}, ${2:subject}; ${3:attr}; ${4:returnVar}) THEN ${5:statements}"
            },
            {
                "key": "Lock",
                "icon": 14,
                "documentation": "The LOCK statement will attempt to set an execution lock, thus requiring any other jBC program which respects that lock to wait until this program has released it. The expression should evaluate to a numeric value between 0 and 255 (63 in R83 import mode). The statement will execute the THEN clause (if defined) providing the lock could be taken. If the LOCK is already held by another program and an ELSE clause was provided then the statements defined by the ELSE clause are executed. If no ELSE clause was provided with the statement then it will block (hang) until the lock has been released by the other program. If the program was compiled with the environment variable JBCEMULATE set to r83, the number of execution locks is limited to 64. If an execution lock greater than this number is specified, the actual lock taken is the specified number modulo 64. Warning! Issuing a RELEASE statement with no arguments will release all execution locks that were set in the current program.",
                "detail": "LOCK expression {THEN|ELSE statements}",
                "snippet": "LOCK ${1:expression} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Loop",
                "icon": 14,
                "documentation": "The LOOP construct allows the programmer to specify loops with multiple exit conditions. statements1 and statements2 consist of any number of standard statements include the LOOP statement itself, thus allowing nested loops. statements1 will always be executed at least once, after which the WHILE or UNTIL clause is evaluated. expression is tested for Boolean TRUE\/FALSE by either the WHILE clause or the UNTIL clause. When tested by the WHILE clause, statements2 will only be executed if expression is Boolean TRUE. When tested by the UNTIL clause, statements2 will only be executed if the expression evaluates to Boolean FALSE. REPEAT causes the loop to start again with the first statement following the LOOP statement.",
                "detail": "LOOP statements1 WHILE|UNTIL expression DO statements2 REPEAT",
                "snippet": "LOOP ${1:statements1} ${2|WHILE,UNTIL|} ${3:expression} DO ${4:statements2} REPEAT"
            },
            {
                "key": "Lowcase",
                "icon": 3,
                "documentation": "The LOWCASE function converts all uppercase characters in an expression to lowercase characters. Equivalent to DOWNCASE(). expression in a string containing some alphabetic characters. Non-alphabetic characters are ignored.",
                "detail": "LOWCASE(expression)",
                "snippet": "LOWCASE(${1:expression})"
            },
            {
                "key": "Lower",
                "icon": 3,
                "documentation": "The LOWER function lowers system delimiters in a string to the next lowest delimiter The expression is a string containing one or more delimiters which are lowered.",
                "detail": "LOWER(expression)",
                "snippet": "LOWER(${1:expression})"
            },
            {
                "key": "Maketimestamp",
                "icon": 3,
                "documentation": "The MAKETIMESTAMP function generates a timestamp using a combination of internal date, time and timezone. Use the MAKETIMESTAMP function to generate a timestamp using a specified time zone. The internal date and internal time values are combined together with the time zone specification to return a UTC timestamp as  decimal seconds.",
                "detail": "MAKETIMESTAMP(InternalDate, InternalTime, Timezone)",
                "snippet": "MAKETIMESTAMP(${1:InternalDate}, ${2:InternalTime}, ${3:TimeZone})"
            },
            {
                "key": "Mat",
                "icon": 14,
                "documentation": "The MAT command is used to either assign every element in a specified array to a single value or to assign the entire contents of one array to another. Array, Array1 and Array2 are all pre-dimensioned arrays declared with the DIM statement. Expression can evaluate to any data type. Note that if any element of the array Array2 has not been assigned a value then a runtime error will occur. This can be avoided by coding the statement MAT Array2 = \" after the DIM statement.",
                "detail": "MAT Array = expression\nMAT Array1 = MAT Array2",
                "snippet": "MAT ${1:array} = ${2:expression}"
            },
            {
                "key": "Matbuild",
                "icon": 14,
                "documentation": "The MATBUILD statement is used to create a dynamic array out of a dimensioned array. variable is the jBC variable into which the created dynamic array will be stored. Array is a previously dimensioned and assigned matrix from which the dynamic array will be created. expression1 and expression2 should evaluate to numeric integers. expression1 specifies which element of the array the extraction will start with; expression2 specifies which element of the array the extraction will end with (inclusive). By default, each array element is separated in the dynamic array by a field mark. By specifying expression3, the separator character can be changed. If expression3 evaluates to more than a single character, only the first character of the string is used. When specifying start and end positions with multi-dimensional arrays, it is necessary to expand the matrix into its total number of variables to calculate the correct element number. See the information about dimensioned arrays earlier in this chapter for detailed instructions on calculating element numbers.",
                "detail": "MATBUILD variable FROM array{, expression1{, expression2}} {USING expression3}",
                "snippet": "MATBUILD ${1:variable} FROM ${2:array}, ${3:expression1}, ${4:expression2}"
            },
            {
                "key": "Match",
                "icon": 14,
                "documentation": "The MATCH or MATCHES function allows pattern matching to be applied to an expression. expression1 may evaluate to any type. expression2 should evaluate to a valid pattern matching string as described below. expression1 is then matched to the pattern supplied and a value of Boolean TRUE is returned if the pattern is matched. A value of Boolean FALSE is returned if the pattern is not matched. expression2 can contain any number of patterns to match separated by value marks. The value mark implies a logical OR of the specified patterns and the match will evaluate to Boolean TRUE if expression1 matches any of the specified patterns.",
                "detail": "expression1 MATCH expression2",
                "snippet": "${1:expression1} MATCH ${2:expression2}"
            },
            {
                "key": "Matches",
                "icon": 14,
                "documentation": "The MATCH or MATCHES function allows pattern matching to be applied to an expression. expression1 may evaluate to any type. expression2 should evaluate to a valid pattern matching string as described below. expression1 is then matched to the pattern supplied and a value of Boolean TRUE is returned if the pattern is matched. A value of Boolean FALSE is returned if the pattern is not matched. expression2 can contain any number of patterns to match separated by value marks. The value mark implies a logical OR of the specified patterns and the match will evaluate to Boolean TRUE if expression1 matches any of the specified patterns.",
                "detail": "expression1 MATCHES expression2",
                "snippet": "${1:expression1} MATCHES ${2:expression2}"
            },
            {
                "key": "Matchfield",
                "icon": 3,
                "documentation": "The MATCHFIELD function checks a string against a match pattern. See also MATCHES for information about pattern matching. field is an expression that evaluates to the portion of the match string to be returned. If string matches pattern, the MATCHFIELD function returns the portion of string that matches the specified field in pattern. If string does not match pattern, or if string or pattern evaluates to the null value, the MATCHFIELD function returns an empty string. If field evaluates to the null value, the MATCHFIELD function fails and the program terminates with a run-time error. pattern must contain specifiers to cover all characters contained in string.",
                "detail": "MATCHFIELD(string, pattern, field)",
                "snippet": "MATCHFIELD(${1:string}, ${2:pattern}, ${3:field})"
            },
            {
                "key": "Matparse",
                "icon": 14,
                "documentation": "The MATPARSE statement is used to assign the elements of a matrix from the elements of a dynamic array. array is a previously dimensioned matrix, which will be assigned to from each element of the dynamic array. variable1 is the jBC variable from which the matrix array will be stored. expression1 and expression2 should evaluate to numeric integers. expression1 specifies which element of the array the assignment will start with; expression2 specifies which element of the array the assignment will end with (inclusive). By default, each array element in the dynamic array is assumed to be separated by a field mark. By specifying expression3, the separator character can be changed. If expression3 evaluates to more than a single character, only the first character of the string is used. As assignment will stop when the contents of the dynamic array have been exhausted, it can be useful to determine the number of matrix elements that were actually assigned to. If the SETTING clause is specified then variable2 will be set to the number of elements of the array that were assigned to. When specifying start and end positions with multi-dimensional arrays, it is necessary to expand the matrix into its total number of variables to calculate the correct element number.",
                "detail": "MATPARSE array{, expression1{, expression2}} FROM variable1 {USING expression3} SETTING variable2",
                "snippet": "MATPARSE ${1:array}, ${2:expression1}, ${3:expression2} FROM ${4:variable1} SETTING ${5:variable2}"
            },
            {
                "key": "Matread",
                "icon": 14,
                "documentation": "The MATREAD statement allows a record stored in a jBASE file to be read and mapped directly into a dimensioned array. array should be a previously dimensioned array, which will be used to store the record to be read. If specified, variable1 should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable1 is not specified then the default file is assumed. The expression should evaluate to a valid record key for the file. If the record is found and can be read from the file then it is mapped into array and the THEN statements are executed (if any). If the record cannot be read from the file for some reason then array is unchanged and the ELSE statements (if any) are executed. If the record could not be read because another process already had a lock on the record then one of two actions is taken. If the LOCKED clause was specified in the statement then the statements dependant on it are executed. If no LOCKED clause was specified then the statement blocks (hangs) until the lock is released by the other process. If a LOCKED clause is used and the read is successful, a lock will be set. If the SETTING clause is specified, setvar will be set to the number of fields in the record on a successful read. If the read fails, setvar will be assigned an Incremental File Errorcode. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the Incremental File Errors except error 128. The record is mapped into the array using a predefined algorithm. The record is expected to consist of a number of Field separated records, which are then assigned one at a time to each successive element of the matrix. If there were more fields in the record than elements in the array then the final element of the array will be assigned all remaining fields. If there were fewer fields in the record than elements in the array then remaining array elements will be assigned a null value.",
                "detail": "MATREAD array FROM {variable1,}expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} {THEN|ELSE statements}",
                "snippet": "MATREAD ${1:array} FROM ${2:expression} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Matreadu",
                "icon": 14,
                "documentation": "The MATREADU statement allows a record stored in a jBASE file to be read and mapped directly into a dimensioned array. The record will also be locked for update by the program. array should be a previously dimensioned array, which will be used to store the record to be read. If specified, variable1 should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable1 is not specified then the default file is assumed (see OPEN statement). The expression should evaluate to a valid record key for the file. If the record is found and can be read from the file then it is mapped into array and the THEN statements are executed (if any). If the record cannot be read from the file for some reason then array is unchanged and the ELSE statements (if any) are executed. If the record could not be read because another process already had a lock on the record then one of two actions is taken. If the LOCKED clause was specified in the statement then the statements dependant on it are executed. If no LOCKED clause was specified then the statement blocks (hangs) until the lock is released by the other process. If the SETTING clause is specified, setvar will be set to the number of fields in the record on a successful read. If the read fails, setvar will be assigned an Incremental File Error code. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the above Incremental File Errors except error 128. The record is mapped into the array using a predefined algorithm. The record is expected to consist of a number of Field separated records, which are then assigned one at a time to each successive element of the matrix. If there were more fields in the record than elements in the array then the final element of the array will be assigned all remaining fields. If there were fewer fields in the record than elements in the array then remaining array elements will be assigned a null value.",
                "detail": "MATREADU array FROM { variable1,}expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} {THEN|ELSE statements}",
                "snippet": "MATREADU ${1:array} FROM ${2:expression} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Matwrite",
                "icon": 14,
                "documentation": "The MATWRITE statement transfers the entire contents of a dimensioned array to a specified record on disc. array should be a previously dimensioned and initialized array.  f specified, variable should be a previously opened file variable (i.e. the subject of an OPEN statement). If variable is not specified the default file variable is used. expression should evaluate to the name of the record in the file. If the SETTING clause is specified and the write succeeds, setvar will be set to the number of attributes read into array. If the SETTING clause is specified and the write fails, setvar will be assigned an Incremental File Error code. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the Incremental File Errors except error 128. The compiler will check that the variable specified is indeed an array and has been dimensioned before its use in the statement.",
                "detail": "MATWRITE array ON { variable,}expression {SETTING setvar} {ON ERROR statements}",
                "snippet": "MATWRITE ${1:array} ON ${2:expression}"
            },
            {
                "key": "Matwriteu",
                "icon": 14,
                "documentation": "The MATWRITEU statement transfers the entire contents of a dimensioned array to a specified record on file, in the same manner as the MATWRITE statement. An existing record lock will be preserved. array should be a previously dimensioned and initialized array. If specified, variable should be a previously opened file variable (i.e. the subject of an OPEN statement). If variable is not specified the default file variable is used. expression should evaluate to the name of the record in the file. If the SETTING clause is specified and the write succeeds, setvar will be set to the number of attributes read into array. If the SETTING clause is specified and the write fails, setvar will be assigned an Incremental File Error code. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the Incremental File Errors except error 128. The compiler will check that the variable specified is indeed an array and has been dimensioned before its use in the statement.",
                "detail": "MATWRITEU array ON { variable,}expression {SETTING setvar} {ON ERROR statements}",
                "snippet": "MATWRITEU ${1:array} ON ${2:expression}"
            },
            {
                "key": "Maximum",
                "icon": 3,
                "documentation": "The MAXIMUM function is used to return the element of a dynamic array with the highest numerical value. DynArr should evaluate to a dynamic array. Null dynamic array elements are treat as zero. Non-numeric dynamic array elements are ignored.",
                "detail": "MAXIMUM(DynArr)",
                "snippet": "MAXIMUM(${1:DynArr})"
            },
            {
                "key": "Minimum",
                "icon": 3,
                "documentation": "The MINIMUM function is used to return the element of a dynamic array with the lowest numerical value. DynArr should evaluate to a dynamic array. Null dynamic array elements are treat as zero. Non-numeric dynamic array elements are ignored.",
                "detail": "MINIMUM(DynArr)",
                "snippet": "MINIMUM(${1:DynArr})"
            },
            {
                "key": "Mod",
                "icon": 3,
                "documentation": "The MOD and REM functions return the arithmetic modulo (remainder) of two numeric expressions. Both expression1 and expression2 should evaluate to numeric expressions or a runtime error will occur. The modulo is calculated as the remainder of expression1 divided by expression2. If expression2 evaluates to 0, then the value of expression1 is returned.",
                "detail": "MOD(expression1, expression2)",
                "snippet": "MOD(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Mods",
                "icon": 3,
                "documentation": "The MODS function creates a dynamic array of the remainder after the integer division of the corresponding elements of two dynamic arrays. The MODS function calculates each element according to the following formula: \tXY.element = X ??(INT (X \/ Y) * Y) X is an element of array1 and Y is the corresponding element of array2. The resulting element is returned in the corresponding element of a new dynamic array. If an element of one dynamic array has no corresponding element in the other dynamic array, 0 is returned. If an element of array2 is 0, 0 is returned. If either of a corresponding pair of elements is null, null is returned for that element.",
                "detail": "MODS(array1, array2)",
                "snippet": "MODS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Msleep",
                "icon": 14,
                "documentation": "Allows the program to pause execution for a specified number of milliseconds. milliseconds must be an integer which specifies the number of milliseconds to sleep. If no parameter is supplied then a default time period of 1 millisecond is assumed. If the debugger is invoked while a program is sleeping and then execution continued, the user will be prompted: \tContinue with SLEEP (Y\/N) ? If \"N\" is the response, the program will continue at the next statement after the MSLEEP.",
                "detail": "MSLEEP {milliseconds}",
                "snippet": "MSLEEP(${1:milliseconds})"
            },
            {
                "key": "Muls",
                "icon": 3,
                "documentation": "The MULS function returns a dynamic array, the content of which is derived by multiplying the corresponding elements of two dynamic arrays passed as arguments. DynArr1 and DynArr2 represent dynamic arrays. Null elements of argument arrays are treated as zero. Otherwise, a non-numeric element in an argument array will cause a run-time error.",
                "detail": "MULS(DynArr1, DynArr2)",
                "snippet": "MULS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Neg",
                "icon": 3,
                "documentation": "The NEG function is used to invert the arithmetic value of an expression. expression may evaluate to any numeric value.",
                "detail": "NEG(expression)",
                "snippet": "NEG(${1:expression})"
            },
            {
                "key": "Negs",
                "icon": 3,
                "documentation": "The NEGS function is used to return the negative values of all the elements in a dynamic array. If the value of the element is negative, the returned value is positive. If array evaluates to null, null is returned. If any element is null, null is returned for that element.",
                "detail": "NEGS(array)",
                "snippet": "NEGS(${1:DynArr})"
            },
            {
                "key": "Nes",
                "icon": 3,
                "documentation": "The NES function determines whether elements of one dynamic array are equal to the elements of another dynamic array. Each element of array1 is compared with the corresponding element of array2. If the two elements are equal, a 0 is returned in the corresponding element of a new dynamic array. If the two elements are not equal, a 1 is returned. If an element of one dynamic array has no corresponding element in the other dynamic array, a 1 is returned. If either of a corresponding pair of elements is null, null is returned for that element.",
                "detail": "NES(array1, array2)",
                "snippet": "NES(${1:array1}, ${2:array2})"
            },
            {
                "key": "Next",
                "icon": 14,
                "documentation": "The NEXT statement terminates a FOR loop. Control is passed back to the FOR statement and the variable is incremented or decremented.",
                "detail": "NEXT variable",
                "snippet": "NEXT ${1:variable}"
            },
            {
                "key": "Nobuf",
                "icon": 14,
                "documentation": "The NOBUF statement turns off buffering for a file previously opened for sequential processing. jBASE can buffer for sequential input and output operations. The NOBUF statement turns off this behavior and causes all writes to the file to be performed immediately. The NOBUF statement should be used in conjunction with a successful OPENSEQ statement and before any input or output is performed on the record. If the NOBUF operation is successful, it executes the THEN statements otherwise, executes the ELSE statements. If file.variable is not a valid file descriptor then NOBUF statement fails and the program enters the debugger.",
                "detail": "NOBUF file.variable {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "NOBUF ${1:file_variable} THEN \n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Not",
                "icon": 3,
                "documentation": "The NOT function is used to invert the Boolean value of an expression. It useful for explicitly testing for a false condition. expression may evaluate to any Boolean result. The NOT function will return Boolean TRUE if the expression returned a Boolean FALSE. It will return Boolean FALSE of the expression returned a Boolean TRUE. The NOT function is useful for explicitly testing for the false condition of some test and can clarify the logic of such a test.",
                "detail": "NOT(Expression)",
                "snippet": "NOT(${1:expression})"
            },
            {
                "key": "Nots",
                "icon": 3,
                "documentation": "The NOTS function is used to return a dynamic array of the logical complements of each element of a dynamic array. If the value of the element is true, the NOTS function returns a value of false (0) in the corresponding element of the returned array. If the value of the element is false, the NOTS function returns a value of true (1) in the corresponding element of the returned array.r A numeric expression that evaluates to 0 has a logical value of false. A numeric expression that evaluates to anything else, other than the null value, is a logical true. An empty string is logically false. All other string expressions, including strings, which consist of an empty string, spaces, or the number 0 and spaces, are logically true. If any element in array is null, it returns null for that element.",
                "detail": "NOTS(array)",
                "snippet": "NOTS(${1:DynArr})"
            },
            {
                "key": "Null",
                "icon": 14,
                "documentation": "The NULL statement performs no function but can be useful in clarifying syntax and where the language requires a statement but the programmer does not wish to perform any actions.",
                "detail": "NULL",
                "snippet": "NULL"
            },
            {
                "key": "Num",
                "icon": 3,
                "documentation": "The NUM function is used to test arguments for numeric values. expression may evaluate to any data type. If every character in expression is found to be numeric then NUM returns a value of Boolean TRUE. If any character in expression is found not to be numeric then a value of Boolean FALSE is returned. Note that to execute user code migrated from older systems correctly, the NUM function will accept both a null string and the single characters \".\", \"+\", and \"-\" as being numeric The aforementioned single characters will not be considered numeric if 'dot_not_numeric' is set to 'true' in the Config_EMULATE file. CHAR(0) is also considered numeric, therefore NUM(CHAR(0)) returns TRUE. If running jBC in ros emulation, the \".\" , \"+\" and \"-\" characters would not be considered numeric.",
                "detail": "NUM(expression)",
                "snippet": "NUM(${1:expression})"
            },
            {
                "key": "Nums",
                "icon": 3,
                "documentation": "The NUMS function is used to determine whether the elements of a dynamic array are numeric. If an element is numeric, a numeric string, or an empty string, it evaluates to true, and returns a value of 1 to the corresponding element in a new dynamic array. If the element is a nonnumeric string, it evaluates to false, and returns a value of 0. The NUMS of a numeric element with a decimal point ( . ) evaluates to true; the NUMS of a numeric element with a comma ( , ) or dollar sign ( $ ) evaluates to false. If dynamic.array evaluates to null, it returns null. If an element of dynamic.array is null, it returns null for that element. When using the NUMS function in International Mode, the statement will use the Unicode Standard to determine whether an expression is numeric.",
                "detail": "NUMS(dynamic.array)",
                "snippet": "NUMS(${1:DynArr})"
            },
            {
                "key": "Objexcallback",
                "icon": 14,
                "documentation": "The OBJEXCALLBACK statement allows communication between the subroutine and the calling OBjEX program. expression1 and expression2 can contain any data. They are passed back to the OBjEX program where they are defined as variants. If the subroutine containing the OBJEXCALLBACK statement is not called from an OBjEX program (using the Call Method) then the ELSE clause will be taken. The OBJEXCALLBACK statement is designed to allow jBC subroutines to temporarily return to the calling environment to handle exception conditions or prompt for additional information. After servicing this event the code should return control to the jBC program to ensure that the proper clean-up operations are eventually made. The two parameters can be used to pass data between the jBC and OBjEX environments in both directions. They are defined as Variants in the OBjEX environment and as normal variables in the jBC environment.",
                "detail": "OBJEXCALLBACK expression1, expression2 THEN|ELSE statements",
                "snippet": "OBJEXCALLBACK ${1:expression1}, ${2:expression2} THEN ${3:statements}"
            },
            {
                "key": "Oconv",
                "icon": 3,
                "documentation": "The OCONV function is used to convert internal representations of data to their external form. expression1 may evaluate to any data type but must be be relevant to the conversion code. expression2 should evaluate to a conversion code from the list below. Alternatively, expression2 may evaluate to a user exit known to the jBC language or supplied by the user (see external interfaces documentation). OCONV will return the result of the conversion of expression1 by expression2. It is also possible to create customized conversion codes that can be used in a jBASE application.",
                "detail": "OCONV(expression1, expression2)",
                "snippet": "OCONV(${1:subject}, ${2:conversion})"
            },
            {
                "key": "Oconvs",
                "icon": 3,
                "documentation": "The OCONVS function is used to convert the elements of a dynamic array to a specified format for external output. Converts the elements to the external output format specified by conversion and returned in a dynamic array conversion must evaluate to one or more conversion codes separated by value marks (ASCII 253). If multiple codes are used, they are applied from left to right as follows: the left-most conversion code is applied to the element, the next conversion code to the right is then applied to the result of the first conversion, and so on. If dynamic.array evaluates to null, it returns null. If any element of dynamic.array is null, it returns null for that element. If conversion evaluates to null, the OCONVS function fails and the program terminates with a run-time error message. The STATUS function reflects the result of the conversion.",
                "detail": "OCONVS(dynamic.array, conversion)",
                "snippet": "OCONVS(${1:DynArr}, ${2:conversion})"
            },
            {
                "key": "On",
                "icon": 3,
                "documentation": "The ON...GOSUB and ON...GOTO statements are used to transfer program execution to a label based upon a calculation. expression should evaluate to an integer numeric value. Labels should be defined somewhere in the current source file. ON GOTO will transfer execution to the labeled source code line in the program. ON GOSUB will transfer execution to the labeled subroutine within the source code. The value of expression is used as an index to the list of labels supplied. If the expression evaluates to 1 then the first label will be jumped to, 2 then the second label will be used and so on. If the program was compiled when the emulation included the setting 'generic_pick = true', then no validations are performed on the index. Therefore, if the index is out of range, this instruction will take no action and report no error. If the program was compiled for other emulations then the index will be range checked. If the index is found to be less than 1 it is assumed to be 1 and a warning message is issued. If the index is found to be too big, then the last label in the list will be used to transfer execution and a warning message issued.",
                "detail": "ON expression GOTO label{, label...}\nON expression GOSUB label{, label...}",
                "snippet": "ON ${1:expression} GOTO ${2:label}"
            },
            {
                "key": "Open",
                "icon": 14,
                "documentation": "The OPEN statement is used to open a file or device to a descriptor variable. The combination of expression1 and expression2 should evaluate to a valid file name of a file type that has been installed in the jBASE system. If the file has a dictionary section and this is to be opened by the statement then this may be specified by the literal string \"DICT\" being specified in expression1. If specified, the variable will be used to hold the descriptor for the file. It should then be used to access the file via READ and WRITE. If no file descriptor variable is supplied, then the file will be opened to the default file descriptor. Specific data sections of a multi level file may specified by separating the section name from the file name by a \",\" char in expression2. If the OPEN statement fails it will execute any statements associated with an ELSE clause. If the OPEN is successful it will execute any statements associated with a THEN clause. Note that the syntax requires either one or both of the THEN and ELSE clauses. If the SETTING clause is specified and the open fails, setvar will be set to an Incremental File Error code. The OPEN statement uses the environment variable JEDIFILEPATH to search for the file named. If this is not defined then the current working directory is used, followed by the home directory of the current process. See the documentation on environment variables for more details. The file that is the subject of the OPEN statement can be of any type known to the jBASE system. Its type will be determined and correctly opened transparently to the application, which need not be aware of the file type. There is no limit to the number of files that may be opened by a jBC program.",
                "detail": "OPEN {expression1,}expression2 TO {variable} {SETTING setvar} THEN|ELSE statements",
                "snippet": "OPEN ${1:filename} TO ${2:variable} ELSE ${3:else_statements}"
            },
            {
                "key": "Opendev",
                "icon": 14,
                "documentation": "Opens a device (or file) for sequential writing and\/or reading. Device specifies the target device or file  FileVar contains the file descriptor of the file when the open was successful Statements conditional jBC statements If the device does not exist or cannot be opened then the ELSE clause is executed. Once open, a lock is taken on the device. If the lock cannot be taken then the LOCKED clause is executed,if it exists, otherwise the ELSE clause is executed. The specified device can be a regular file, pipe or special device file. Locks are only taken on regular file types. Once open the file pointer is set to the first line of sequential data.",
                "detail": "OPENDEV Device TO FileVar { LOCKED statements } THEN | ELSE statements",
                "snippet": "OPENDEV ${1:Device} TO ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Openindex",
                "icon": 14,
                "documentation": "The OPENINDEX statement is used to open a particular index definition for a particular file. This index file variable can later be used with the SELECT statement. filename should correspond to a valid file which has at least one index. indexname should correspond to an index created for the filename. indexvar is the variable that holds the descriptor for the index. If the OPEN statement fails it will execute any statements associated with an ELSE clause. If the OPEN is successful it will execute any statements associated with a THEN clause. Note that the syntax requires either one or both of the THEN and ELSE clauses. If the SETTING clause is specified and the open fails, setvar will be set to an Incremental File Error code.",
                "detail": "OPENINDEX filename,indexname TO indexvar {SETTING setvar} THEN|ELSE statements",
                "snippet": "OPENINDEX ${1:filename},${2:indexname} TO ${3:indexvar} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Openpath",
                "icon": 14,
                "documentation": "The OPENPATH statement is used to open a file (given an absolute or relative path) to a descriptor variable within jBC. See also the OPEN statement. Expression1 should be an absolute or relative path to the file including the name of the file to be opened. If specified, variable will be used to hold the descriptor for the file. It should then be used to access the file via READ and WRITE. If no file descriptor variable is supplied, then the file will be opened to the default file descriptor. If the OPENPATH statement fails it will execute any statements associated with an ELSE clause. If the OPENPATH is successful it will execute any statements associated with a THEN clause. Note that the syntax requires either one or both of the THEN and ELSE clauses. If the SETTING clause is specified and the open fails, setvar will be set to an Incremental File Error code. The path specified may be either a relative or absolute path and must include the name of the jBASE file being opened. The file that is the subject of the OPENPATH statement can be of any type known to the jBASE system. Its type will be determined and correctly opened transparently to the application, which need not be aware of the file type. There is no limit to the number of files that may be opened by a jBC program.",
                "detail": "OPENPATH expression1 TO {variable} {SETTING setvar} THEN|ELSE statements",
                "snippet": "OPENPATH ${1:expression1} TO ${2:variable} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Openseq",
                "icon": 14,
                "documentation": "Opens a file for sequential writing and\/or reading. Path specifies the relative or absolute path of the target directory or file File specifies additional path information of the target file FileVar contains the file descriptor of the file when the open was successful Statements conditional jBC statements If the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the above Incremental File Errors except error 128. If the file does not exist or cannot be opened then the ELSE clause is executed. However if JBCEMULATE is set for Sequoia (use value \"seq\") emulation then OPENSEQ will create the file if it does not exist. This behavior can also be achieved by specifying \"openseq_creates = true\" in Config_EMULATE for the emulation being used. Alternatively, the CREATE statement can be used, which eliminates the need for the 'openseq_creates = true' Config_EMULATE option. Once open a lock is taken on the file. If the lock cannot be taken then the LOCKED clause is executed, if it exists, otherwise the ELSE clause is executed. If READONLY is specified then the process takes a read lock on the file otherwise a write lock is taken. The specified file can be a regular, pipe or special device file. Locks are only taken on regular file types. Once open the file pointer is set to the first line of sequential data.",
                "detail": "OPENSEQ Path{,File} {READONLY} TO FileVar {SETTING setvar} {ON ERROR statements} { LOCKED statements } THEN | ELSE statements",
                "snippet": "OPENSEQ ${1:Path} ${2:READONLY} TO ${3:FileVar} THEN ${4:statements}"
            },
            {
                "key": "Openser",
                "icon": 14,
                "documentation": "Opens a serial device for sequential writing and\/or reading. Path is the pathname of the required device. DevInfo consists of Baud, Flow and Parity codes. PIPE specifies the file is to be opened to a PIPE for reading.",
                "detail": "OPENSER Path,DevInfo| PIPE TO FileVar THEN | ELSE Statements",
                "snippet": "OPENSER ${1:Path},${2:DevInfo} TO ${3:FileVar} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Ors",
                "icon": 3,
                "documentation": "The ORS function creates a dynamic array with the logical OR from the corresponding elements of two dynamic arrays. Each element of the new dynamic array is the logical OR of the corresponding elements of array1 and array2. If an element of one dynamic array has no corresponding element in the other dynamic array, it assumes a false for the missing element. If both corresponding elements of array1 and array2 are null, it returns null for those elements. If one element is the null value and the other is 0 or an empty string, it returns null. If one element is the null value and the other is any value other than 0 or an empty string, it returns true.",
                "detail": "ORS(array1, array2)",
                "snippet": "ORS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Osbread",
                "icon": 14,
                "documentation": "Reads an OS file from a file opened. Variable specifies the variable to contain the data from the read. FileVar specifies the file descriptor of the file opened (via OSOPEN). AT ByteExpr Specifies a location in the file from which to begin reading data. If ByteExpr is 0, the read begins at the beginning of the file. LENGTH LengthExpr Specifies a length of data to read from the file, starting at ByteExpr. LengthExpr cannot be longer than the maximum string length determined by your system configuration. ON ERROR Statements Conditional jBC statements to execute if a fatal error occurs (if the file is not open, or if the file is a read-only file). If an ON ERROR clause is not specified, the program terminates under such fatal error conditions. The jBC OSBREAD command reads data from a file starting at a specified byte location (ByteExpr) for a certain length of bytes (LengthExpr), and assigns the data to a variable. OSBREAD performs an operating system block read on a UNIX or Windows file. jBC uses the ASCII 0 character (CHAR(0)) as a string-end delimiter. Therefore, ASCII 0 cannot be used in any string variable within jBC. OSBREAD converts CHAR(0) to CHAR(128) when reading a block of characters. jBC begins reading from the file at the offset specified by ByteExpr. After successful execution of OSBREAD against a file, the file pointer remains at the next byte after the data read. Reminder - The file must be opened using the OSOPEN command before using OSBREAD.",
                "detail": "OSBREAD Variable FROM FileVar AT ByteExpr LENGTH LengthExpr {ON ERROR Statements}",
                "snippet": "OSBREAD ${1:var} FROM ${2:filevar} LENGTH ${3:length_expr}"
            },
            {
                "key": "Osbwrite",
                "icon": 14,
                "documentation": "Writes an OS file to an file opened. Variable Specifies the variable to contain the data from the read. FileVar Specifies the file descriptor of the file opened (via OSOPEN). AT ByteExpr Specifies a location in the file from which to begin writing data. If ByteExpr is 0, the write begins at the beginning of the file. ON ERROR Statements Conditional jBC statements to execute if the OSBWRITE statement fails with a fatal error because the file is not open, an I\/O error occurs, or jBASE cannot find the file. If an ON ERROR clause is not specified and a fatal error occurs, the program terminates. The jBC OSBWRITE command writes an expression to a OS file starting at a specified byte location. OSBWRITE immediately writes a file segment out to the UNIX or Windows file. jBC begins writing to the file at the offset specified by ByteExpr. After successful execution of OSBWRITE, the file pointer remains at the next byte after the data is written. A length expression need not be specified as the number of bytes in Variable is written to the file. Reminder - The file must first be opened using the OSOPEN command. jBC uses the ASCII 0 character (CHAR(0)) as a string-end delimiter. Therefore, ASCII 0 cannot be used in any string variable within jBC. If jBC reads a string that contains CHAR(0) characters using OSBREAD, those characters are converted to CHAR(128). OSBWRITE converts CHAR(128) back to CHAR(0) when writing a block of characters.",
                "detail": "OSBWRITE Variable ON | TO FileVar AT ByteExpr {ON ERROR Statements}",
                "snippet": "OSBWRITE ${1:expression} TO ${2:filevar}"
            },
            {
                "key": "Osclose",
                "icon": 14,
                "documentation": "Closes a previously opened OS file. FileVar Specifies the file to close. ON ERROR Statements Conditional jBC statements to execute if the OSCLOSE statement fails with a fatal error because the file is not open, an I\/O error occurs, or jBASE cannot find the file. If an ON ERROR clause is not specified and a fatal error occurs, the program terminates. The jBC OSCLOSE command closes a sequential file that was opened with an OSOPEN statement.",
                "detail": "OSCLOSE FileVar {ON ERROR Statements}",
                "snippet": "OSCLOSE ${1:filevar}"
            },
            {
                "key": "Osdelete",
                "icon": 14,
                "documentation": "Deletes an OS file. expression Specifies the full file path. If the file resides in JEDIFILEPATH then just the file name is required. ON ERROR Statements Conditional jBC statements to execute if the OSDELETE statement fails with a fatal error because the file is not open, an I\/O error occurs, or jBASE cannot find the file. If an ON ERROR clause is not specified and a fatal error occurs, the program terminates. The jBC OSDELETE command deletes an NTFS or UNIX sequential file. This command is intended for use on OS-type files and not jBASE hashed files. This command should NEVER be used on Hashed files (see DELETE-FILE to remove Hashed files).",
                "detail": "OSDELETE expression {ON ERROR Statements}",
                "snippet": "OSDELETE ${1:filename}"
            },
            {
                "key": "Osopen",
                "icon": 14,
                "documentation": "The OSOPEN statment opens an OS file for processing. expression Specifies the full file path. If the file resides in JEDIFILEPATH then just the file name is required. READONLY Directs jBASE to open the file for reading only. If the program attempts to write to a file opened in READONLY mode, jBASE displays a runtime error message and does not update the file. FileVar Specifies the variable to be used to hold the descriptor for the file. This can then be used to access the file via OSBREAD and OSBWRITE. If no file descriptor variable is supplied, then the file will be opened to the default file descriptor. ON ERROR Statements Conditional jBC statements to execute if the OSOPEN statement fails with a fatal error because an I\/O error occurs or jBASE cannot find the file. If an ON ERROR clause is not specified and a fatal error occurs, the program terminates. THEN | ELSE\tIf the OSOPEN statement fails it will execute any statements associated with an ELSE clause. \tIf the OSOPEN is successful it will execute any statements associated with a THEN clause. Note that the syntax requires either one or both of the THEN and ELSE clauses. The jBC OSOPEN command opens a sequential file which does not use CHAR(10) as the line delimiter. Read\/write access mode is the default. After opening a sequential file with OSOPEN, use OSBREAD to read a block of data from the file or OSBWRITE to write a block of data to the file.",
                "detail": "OSOPEN expression {READONLY} {TO FileVar} {ON ERROR Statements} {THEN | ELSE} Statements {END}",
                "snippet": "OSOPEN ${1:filename} TO ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Osread",
                "icon": 14,
                "documentation": "Reads an OS file. Variable Specifies the variable to contain the data from the read. expression Specifies the full file path. If the file resides in JEDIFILEPATH then just the file name is required. ON ERROR Statements Conditional jBC statements to execute if the OSREAD statement fails with a fatal error because the file is not open, an I\/O error occurs, or jBASE cannot find the file. If an ON ERROR clause is not specified and a fatal error occurs, the program terminates. THEN | ELSE\tIf the OSREAD statement fails it will execute any statements associated with an ELSE clause.\tIf the OSREAD is successful it will execute any statements associated with a THEN clause. Note that the syntax requires either one or both of the THEN and ELSE clauses. The jBC OSREAD command reads an entire sequential file and assigns the contents of the file to a variable. Do not use OSREAD on large files. If the file is too large for the program\u2019s memory, the program aborts and a runtime error message is generated. On large files, use OSBREAD or READSEQ. jBASE uses the ASCII 0 character (CHAR(0)) as a string-end delimiter. ASCII 0 cannot be used in any string variable within jBC. This command converts CHAR(0) to CHAR(128) when reading a block of data.",
                "detail": "OSREAD Variable FROM expression {ON ERROR Statements} {THEN | ELSE} Statements {END}",
                "snippet": "OSREAD ${1:Variable} FROM ${2:expression} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Oswrite",
                "icon": 14,
                "documentation": "Writes an OS file. Variable Specifies the variable to contain the data from the read. expression Specifies the full file path. If the file resides in JEDIFILEPATH then just the file name is required. ON ERROR Statements Conditional jBC statements to execute if the OSWRITE statement fails with a fatal error because the file is not open, an I\/O error occurs, or jBASE cannot find the file. If an ON ERROR clause is not specified and a fatal error occurs, the program terminates. The jBC OSWRITE command writes the contents of an expression to a sequential file. jBASE uses the ASCII 0 character (CHAR(0)) as a string-end delimiter. For this reason, ASCII 0 cannot be used in any jBC string variable. If jBC reads a string with a CHAR(0) character, and then the character is converted to CHAR(128), this command converts CHAR(128) to CHAR(0) when writing a block of characters.",
                "detail": "OSWRITE Variable ON |TO expression {ON ERROR Statements}",
                "snippet": "OSWRITE ${1:Variable} TO ${2:expression}"
            },
            {
                "key": "Out",
                "icon": 14,
                "documentation": "The OUT statement is used to send raw characters to the current output device (normally the terminal). expression should evaluate to a numeric integer in the range 0 to 255, being the entire range of ASCII characters. The numeric expression is first converted to the raw ASCII character specified and then sent directly to the output advice.",
                "detail": "OUT expression",
                "snippet": "OUT ${1:expression}"
            },
            {
                "key": "Page",
                "icon": 14,
                "documentation": "Prints any FOOTING statement, throws a page and prints any heading statement on the current output device. If expression is specified it should evaluate to a numeric integer, which will cause the page number after the page throw to be set to this value.",
                "detail": "PAGE {ON channel} {expression}",
                "snippet": "PAGE ${1:expression}"
            },
            {
                "key": "Pause",
                "icon": 14,
                "documentation": "The PAUSE statement allows processing to be suspended until an external event triggered by a WAKE statement from another process or a timeout occurs. expression may evaluate to a timeout value, which is the maximum number of seconds to suspend the process. If expression is omitted then the PAUSE statement will cause the process to suspend until woken by the WAKE statement. If a timeout value is specified and the suspended process is not woken by a WAKE statement, then the process will continue once the timeout period has expired. If a WAKE statement is executed for the process before the process executes the PAUSE statement then the PAUSE will be ignored and processing will continue until a subsequent PAUSE statement.",
                "detail": "PAUSE {expression}",
                "snippet": "PAUSE ${1:expression}"
            },
            {
                "key": "Perform",
                "icon": 14,
                "documentation": "The EXECUTE or PERFORM statement allows the currently executing program to pause and execute any other UNIX\/NT program, including another jBC program or a jBASE command. The PERFORMed expression can be formed from any jBASE construct. The system will not verify that the command exists before executing it. The command is executed by a new Bourne Shell (sh) by default. The shell type can be changed by preceding the command with a CHAR(255) (or equivalently, @IM) concatenated with either \"k\", \"c\", or \"s\" to signify the Korn shell, C shell or Bourne Shell. Variables used to pass data to the executed program should have been assigned a value before they are used. Any variable name may be used to receive data.  CAPTURING variable The capturing clause will capture any output that the executing program would normally send to the terminal screen and place it in the variable specified. Every newline normally sent to the terminal is replaced with a field mark in the variable. RETURNING variable or SETTING variable The returning and setting clauses are identical. Both clauses will capture the output associated with any error messages the executing program issues. The first field of the variable will be set to the exit code of the program. PASSLIST variable The PASSLIST clause allows jBASE programs to exchange lists or dynamic arrays between them. The variable should contain the list that the program wishes to pass to the jBASE program it is executing. The program to be executed should be able to process lists, otherwise the list will just be ignored. If the variable name is not specified then the clause will pass the default select list to the executing program. RTNLIST variable If the program executed sets up a list then the RTNLIST clause may be used to place that list into a specified variable. If the variable is omitted then the list is placed in the default list variable. PASSDATA variable The data in the specified variable is passed to another jBC program. The executing jBC program should retrieve the data using the COLLECTDATA statement. RTNDATA variable The RTNDATA statement returns any data passed from an executing jBC program in the specified variable. The executing jBC program should use the RTNDATA statement to pass data back to the calling program. The clauses may be specified in any order within the statement but only one of each clause may exist.",
                "detail": "PERFORM expression {CAPTURING variable} {RETURNING|SETTING variable}\n{PASSLIST expression} {RTNLIST {variable}}\n{PASSDATA variable} {RTNDATA variable}",
                "snippet": "PERFORM ${1:expression}"
            },
            {
                "key": "Precision",
                "icon": 14,
                "documentation": "The PRECISION statement informs jBASE as to the number of digits of precision it uses after the decimal point in numbers. integer should be in the range 0 to 9. If the program contains no PRECISION statement then is it is set with a default precision of 4. If there is one (or more) PRECISION statements then the first one encountered is taken as the PRECISION of the program. During the runtime of the program the precision will changed as it encounters any subsequent PRECISION statements. A PRECISION statement can be specified any number of times in a source file. Only the most recently defined precision will be active at any one time. Calling programs and external subroutines do not have to be compiled at the same degree of precision, however, any changes to precision in a subroutine will not persist when control returns to the calling program. jBASE uses the maximum degree of precision allowed on the host machine in all mathematical calculations to ensure maximum accuracy. It then uses the defined precision to format the number.",
                "detail": "PRECISION integer",
                "snippet": "PRECISION ${1:integer}"
            },
            {
                "key": "Print",
                "icon": 14,
                "documentation": "The PRINT statement sends data directly to the current output device, which will either be the terminal or the printer. Channel is the report channel number in the range 0 to 127. An expression can evaluate to any data type. The PRINT statement will convert the result to a string type for printing. Expressions separated by commas will be sent to the output device separated by a tab character. The PRINT statement will append a newline sequence to the final expression unless it is terminated with a colon \":\" character. As the expression can be any valid expression, it may have output formatting applied to it. If a PRINTER ON statement is currently active then output will be sent to the currently assigned printer form queue, (see also SP-ASSIGN command).",
                "detail": "PRINT {ON Channel} expression {, expression...} {:}",
                "snippet": "PRINT ${1:expression}"
            },
            {
                "key": "Printer Close",
                "icon": 14,
                "documentation": "PRINTER CLOSE will act as PRINTER OFF but in addition will close all currently active spool jobs created by the active PRINTER ON statement. If the optional ON channel_number is specified then only the print job created on that channel number will be closed.",
                "detail": "PRINTER CLOSE {ON channel_number}",
                "snippet": "PRINTER CLOSE"
            },
            {
                "key": "Printer Off",
                "icon": 14,
                "documentation": "PRINTER OFF will cause all subsequent output from the PRINT statement to be redirected to the terminal device.",
                "detail": "PRINTER OFF",
                "snippet": "PRINTER OFF"
            },
            {
                "key": "Printer On",
                "icon": 14,
                "documentation": "PRINTER ON will cause all subsequent output from the PRINT statement to be redirected to the print spooler.",
                "detail": "PRINTER ON",
                "snippet": "PRINTER ON"
            },
            {
                "key": "Printerr",
                "icon": 14,
                "documentation": "Used to print standard jBASE error messages. Field 1 of the expression should evaluate to the numeric or string name of a valid error message in the jBASE error message file.\bIf the error message requires parameters then these can be passed to the message as subsequent fields of the expression. When the PRINTERR statement is used in International Mode, the error message file to be used, i.e. the default \u201cjBASICmessages\u201d or other as configured via the error message environment variable, will be suffixed with the current locale. For example, if the currently configured locale is \u201cfr_FR\u201d, then the statement will attempt to find the specified error message record id in the \u201cjBASICmessages_fr_FR\u201d error message file. If the file cannot be found then the country code will be discarded and just the language code used. i.e. the file \u201cjBASICmessages_fr\u201d will be used. If this file is also not found then the error message file \u201cjBASICmessages\u201d will be used. The PRINTERR statement is most useful for user defined messages that have been added to the standard set.",
                "detail": "PRINTERR expression",
                "snippet": "PRINTERR ${1:expression}"
            },
            {
                "key": "Procread",
                "icon": 14,
                "documentation": "Used to retrieve data passed to programs from a jCL program. variable is a valid jBC identifier, which will be used to store the contents of the primary input buffer of the last jCL program called. If the program was not initiated by a jCL program then the PROCREAD will fail and any statements associated with an ELSE clause will be executed. If the program was initiated by a jCL program then the PROCREAD will succeed, the jCL primary input buffer will be assigned to variable and any statements associated with a THEN clause will be executed. It is recommended that the use of jCL and therefore the PROCREAD statement should be not be expanded within your application and gradually replaced with more sophisticated methods such as UNIX scripts or jBC programs.",
                "detail": "PROCREAD variable THEN|ELSE statements",
                "snippet": "PROCREAD ${1:variable} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Procwrite",
                "icon": 14,
                "documentation": "Used to pass data back to the primary input buffer of a calling jCL program. expression may evaluate to any valid data type.",
                "detail": "PROCWRITE expression",
                "snippet": "PROCWRITE ${1:expression}"
            },
            {
                "key": "Program",
                "icon": 14,
                "documentation": "Performs no function other than to document the source code. Progname can be any string of characters.",
                "detail": "PROGRAM progname",
                "snippet": "PROGRAM ${1:progname}"
            },
            {
                "key": "Prompt",
                "icon": 14,
                "documentation": "Used to change the prompt character used by terminal input commands. expression can evaluate to any printable string. The entire string is used as the prompt. The default prompt character is the question mark \"?\" character.",
                "detail": "PROMPT expression",
                "snippet": "PROMPT ${1:expression}"
            },
            {
                "key": "Putenv",
                "icon": 3,
                "documentation": "Used to set environment variables for the current process. expression should evaluate to a string of the form: \tEnvVarName=value where EnvVarName is the name of a valid environment variable and value is any string that makes sense to variable being set. If PUTENV function succeeds it returns a Boolean TRUE value, if it fails it will return a Boolean FALSE value. PUTENV only sets environment variables for the current process and processes spawned (say by EXECUTE) by this process. These variables are known as export only variables.",
                "detail": "PUTENV(expression)",
                "snippet": "PUTENV(${1:expression})"
            },
            {
                "key": "Pwr",
                "icon": 3,
                "documentation": "The PWR function raises a number to the n'th power. Both expression1 and expression2 should evaluate to numeric arguments. The function will return the value of expression1 raised to the value of expression2. If expression1 is negative and expression2 is not an integer then a maths library error is displayed and the function returns the value 0. The error message displayed is: \tpow: DOMAIN error All calculations are performed at the maximum precision supported on the host machine and truncated to the compiled precision on completion.",
                "detail": "PWR(expression1, expression2)\nor\nexpression1 ^ expression2",
                "snippet": "PWR(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Quote",
                "icon": 3,
                "documentation": "The function will put double quotation mark at the beginning and end of a string. expression may be any expression that is valid in the JBC language.",
                "detail": "QUOTE(Expression)",
                "snippet": "QUOTE(${1:expression})"
            },
            {
                "key": "Randomize",
                "icon": 14,
                "documentation": "Use the RANDOMIZE statement with an expression to make the RND function generate the same sequence of random numbers each time the program is run.",
                "detail": "RANDOMIZE $expression",
                "snippet": "RANDOMIZE ${1:expression}"
            },
            {
                "key": "Raise",
                "icon": 3,
                "documentation": "The RAISE function raises system delimiters in a string to the next highest delimiter. The expression is a string containing one or more delimiters which are raised.",
                "detail": "RAISE(Expression)",
                "snippet": "RAISE(${1:expression})"
            },
            {
                "key": "Read",
                "icon": 14,
                "documentation": "The READ statement allows a program to read a record from a previously opened file into a variable. variable1 is the identifier into which the record will be read. variable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable2 is not specified then the default file is assumed. The expression should evaluate to a valid record key for the file. If the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for anyIncremental File Error except error 128. If you wish to set a lock on a record you should do so explicitly with the READU statement. An attempt to access a 'null' item-id in a directory will take the ELSE clause, i.e. treated as 'item does not exist'.",
                "detail": "READ variable1 FROM { variable2,} expression {SETTING setvar} {ON ERROR statements} THEN|ELSE statements",
                "snippet": "READ ${1:var} FROM ${2:filevar},${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Readblk",
                "icon": 14,
                "documentation": "The READBLK statement reads a block of data of a specified length from a file opened for sequential processing and assigns it to a variable. READBLK variable FROM file.variable, blocksize {THEN statemente [ELSE statements]|ELSE statements } The READBLK statement reads a block of data beginning at the current position in the file and continuing for blocksize bytes and assigns it to variable. The current position is reset to just beyond the last readable byte. file.variable specifies a file previously opened for sequential processing. If the data can be read from the file, the THEN statements are executed; any ELSE statements are ignored. If the file is not readable or if the end of file is encountered, the ELSE statements are executed and the THEN statements are ignored. If the ELSE statements are executed, variable is set to an empty string. If either file.variable or blocksize evaluates to null, the READBLK statement fails and the program enters the debugger. NOTE: A new line in UNIX files is one byte long, whereas in Windows it is two bytes long. This means that for a file with newlines, the same READBLK statement may return a different set of data depending on the operating system the file is stored under. The difference between the READSEQ statement and the READBLK statement is that the READBLK statement reads a block of data of a specified length, whereas the READSEQ statement reads a single line of data. When using the READBLK statement in International Mode, care must be taken to ensure that the input variable is handled properly subsequent to the READBLK statement. The READBLK statement requires that a \u201cbytecount\u201d be specified, however when manipulating variables in International Mode, character length rather than byte lengths are usually used and hence possible confusion or program malfunction can occur. If requiring character data convert the input variable from \u2018binary\/latin1\u2019 to UTF-8 byte sequence via the UTF8  function. It is recommended that the READBLK\/WRITEBLK statements not be used when executing in International Mode. Similar functionality can be obtained via the READSEQ\/WRITESEQ statement, which can be used to read\/write characters a line at a time from a file.",
                "detail": "READBLK variable FROM file.variable, blocksize {THEN statemente [ELSE statements] | ELSE statements}",
                "snippet": "READBLK ${1:variable} FROM ${2:filevariable}, ${3:blocksize} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Readl",
                "icon": 14,
                "documentation": "The READL statement allows a process to read a record from a previously opened file into a variable and takes a read-only shared lock on the record. It respects all records locked with the READU statement but allows other processes using READL to share the same lock. variable1 is the identifier into which the record will be read. variable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable2 is not specified then the default file is assumed. The expression should evaluate to a valid record key for the file. If the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the above Incremental File Errors except error 128. READL takes a read-only shared record lock whereas READU takes an exclusive lock. What this basically means is that any record which is read using READL can also be read by another process using a READL. In other words, the lock on the record is 'shared' in that no READU lock against the same record can be taken. Similarly, if a READU takes a lock then READL will respect that lock. By comparison, a READU takes an exclusive lock in that the one process retains control over the record. The usage of READU is already well documented and hopefully understood. The usage of READL allows for an application to present a record to one or more users such that its integrity is ensured, i.e. the user(s) viewing the record can be assured that 'wysiwyg' and that no updates to that record have been made whilst viewing the record. While it is permissible to WRITE a record that has a READL lock, the intent of READL is to permit a 'read-only' shared lock and the act of WRITEing this record would not be considered good programming practice. READ takes no lock at all and does not respect any lock taken with READU or READL. In other words, a READ can be performed at any time and on any record regardless of any existing locks. Due to limitations on Windows platforms, the READL statement behaves the same as the READU statement, in other words they both take exclusive locks. If the record could not be read because another process already had a READU lock on the record then one of two actions is taken. If the LOCKED clause was specified in the statement then the statements dependant on it are executed. If no LOCKED clause was specified then the statement blocks (hangs) until the lock is released by the other process. The SYSTEM(43) function can be used to determine which port has the lock. If the statement fails to read the record then any statements associated with the ELSE clause will be executed. If the statement successfully reads the record then the statements associated with any THEN clause are executed. Either or both of THEN and ELSE clauses must be specified with the statement. The lock taken by the READL statement will be released by any of the following events however, be aware that the record will not be fully released until all shared locks have been released: * The record is written to by the same program with WRITE, WRITEV or MATWRITE statements. * The record is deleted by the same program with the DELETE statement. * The record lock is released explicitly using the RELEASE statement. * The program stops normally or abnormally. * When a file is OPENed to a local file variable in a subroutine then the file is closed when the subroutine RETURNS so all locks taken on that file are released, including locks taken in a calling program. Files that are opened to COMMON variables are not closed so the locks remain intact.",
                "detail": "READL variable1 FROM {variable2,} expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN|ELSE statements",
                "snippet": "READL ${1:var} FROM ${2:filevar},${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Readlist",
                "icon": 14,
                "documentation": "READLIST allows the program to retrieve a previously stored list (perhaps created with the SAVE-LIST command), into a jBC variable. variable1 is the variable into which the list will be read. expression should evaluate to the name of a previously stored list to retrieve. If specified, variable2 will be set to the number of elements in the list. If the statement succeeds in retrieving the list, then the statements associated with any THEN clause will be executed. If the statement fails to find the list, then the statements associated with any ELSE clause will be executed. The READLIST statement is identical in function to the GETLIST statement.",
                "detail": "READLIST variable1 FROM expression {SETTING variable2} THEN|ELSE statements",
                "snippet": "READLIST ${1:variable1} FROM ${2:expression} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "ReadNext",
                "icon": 14,
                "documentation": "READNEXT retrieves the next element in a list variable. variable1 is the variable into which the next element of the list will be read. variable2 is used when the list has been retrieved externally from a SSELECT or similar jBASE command that has used an exploding sort directive. When specified, this variable will be set to the multi-value reference of the current element. For example, if the SSELECT used a BY-EXP directive on field 3 of the records in a file, the list will contain each record key in the file as many times as there are multi-values in the field. Each READNEXT instance will set variable2 to the multi-value in field 3 that the element refers to. This allows the multi-values in field 3 to be retrieved in sorted order. If variable3 is specified with the FROM clause, the READNEXT operates on the list contained in variable3. If variable3 is not specified, the default select list variable will be assumed. If the SETTING clause is specified and the read (to build the next portion of the list) fails, setvar will be set to an Incremental File Error code. READNEXT can be used as an expression returning a Boolean TRUE or FALSE value. If an element is successfully read from the list, TRUE is returned. If the list was empty, FALSE is returned.",
                "detail": "READNEXT variable1, variable2 {FROM variable3} {SETTING setvar} {THEN|ELSE statements}",
                "snippet": "READNEXT ${1:variable} FROM ${2:list}"
            },
            {
                "key": "ReadNext Key",
                "icon": 14,
                "documentation": "The READNEXT statement is extended in two ways. Firstly it can accept an index variable create with an OPENINDEX statement. Secondly, you can use the KEY modifier. In this format the READNEXT KEY statement will return the actual index key. The select used use MUST have been created with the OPENINDEX statement. You can optionally return the associated record key and the multi-value number associated with it.",
                "detail": "READNEXT KEY index.key{,record.key{,vmcount}} {FROM select-def} THEN\/ELSE",
                "snippet": "READNEXT KEY ${1:indexkey},${2:recordkey},${3:vmcount} FORM ${4:selectdef} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "ReadPrev Key",
                "icon": 14,
                "documentation": "This statement is syntactically similar to the READNEXT KEY but it works in reverse order. This statement is syntactically similar to the READNEXT but it works in reverse order. There are some considerations when the direction is changed from a forward search to a backward search or vice-versa. When a SELECT statement is first executed a forward direction is assumed. Therefore if a SELECT is immediately followed by a READPREV, then a change of direction is assumed. During the READNEXT or READPREV sequence a next-key pointer is kept up to date. This is the record key, or index key to use should a READNEXT be executed. During a change of direction from forward (READNEXT) to backward (READPREV) then the next record key or index key read in by the READPREV will be the one preceding the next-key pointer. When the select list is exhausted it will either point one before the start of the select list (if READPREVs have been executed) or one past the end of the select list (if READNEXTs have been executed). Thus in the event of a change of direction the very first or very last index key or record key will be used.",
                "detail": "READPREV KEY index.key{,record.key{,vmcount}} {FROM select-def} THEN\/ELSE",
                "snippet": "READPREV KEY ${1:indexkey} THEN ${2:statements}"
            },
            {
                "key": "Readseq",
                "icon": 14,
                "documentation": "The READSEQ statement allows a program to read from a file opened for sequential access. Variable specifies the variable to contain next record from sequential file. FileVar specifies the file descriptor of the file opened for sequential access. SETTING if specified and the read fails, setvar will be set to one an Incremental File Errors code. ON ERROR statements are executed upon any error condition, i.e. the READSEQ fails (this is usually used in conjuction with the SETTING clause) Statements conditional jBC statements. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any Incremental File Error except error 128. Each READSEQ reads a line of data from the sequentially opened file. After each READSEQ the file pointer moves forward to the next line of data. The variable contains the line of data less the new line character from the sequential file. The default buffer size for a READSEQ is 1024 bytes. This can be changed using the IOCTL() function with the JIOCTL_COMMAND_SEQ_CHANGE_RECORDSIZE Sequential File Extensions.",
                "detail": "READSEQ Variable FROM FileVar {SETTING setvar} {ON ERROR statements} THEN | ELSE statements\nVariable: specifies the variable to contain next record from sequential file.\nFileVar: specifies the file descriptor of the file opened for sequential access.\nSETTING: if specified and the read fails, setvar will be set to an Incremental File Error code.\nON ERROR: statements are executed upon any error condition, i.e. the READSEQ fails (this is usually used in conjuction with the SETTING clause)\nStatements: conditional jBC statements",
                "snippet": "READSEQ ${1:Variable} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Readt",
                "icon": 14,
                "documentation": "The READT statement is used to read from a range of tape devices 0-9. variable is the variable that will receive any data read from the tape device. expression should evaluate to an integer value in the range 0-9 and specifies from which tape channel to read data. If the FROM clause is not specified the READT will assume channel 0. If the READT fails then the statements associated with any ELSE clause will be executed. SYSTEM(0) will return the reason for the failure.",
                "detail": "READT variable {FROM expression} THEN|ELSE statements",
                "snippet": "READT ${1:variable} FROM ${2:expression} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Readu",
                "icon": 14,
                "documentation": "The READU statement allows a program to read a record from a previously opened file into a variable. It respects record locking and locks the specified record for update. variable1 is the identifier into which the record will be read. variable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable2 is not specified, then the default file is assumed. The expression should evaluate to a valid record key for the file. If the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any of the Incremental File Error except error 128.",
                "detail": "READU variable1 FROM {variable2,} expression {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN|ELSE statements",
                "snippet": "READU ${1:var} FROM ${2:filevar},${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Readv",
                "icon": 14,
                "documentation": "The READV statement allows a program to read a specific field from a record in a previously opened file into a variable. variable1 is the identifier into which the record will be read. variable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable2 is not specified, the default file is assumed. expression1 should evaluate to a valid record key for the file. expression2 should evaluate to a positive integer. If the number is invalid or greater than the number of fields in the record, a NULL string will be assigned to variable1. If the number is 0 then the value returned in variable1 is controlled by the readv0 emulation setting. If a non-numeric argument is evaluated, a run time error will occur. If the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any Incremental File Errors except error 128.",
                "detail": "READV variable1 FROM { variable2,} expression1, expression2 {SETTING setvar} {ON ERROR statements} THEN|ELSE statements",
                "snippet": "READV ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Readvu",
                "icon": 14,
                "documentation": "The READVU statement allows a program to read a specific field in a record in a previously opened file into a variable. It also respects record locking and locks the specified record for update. variable1 is the identifier into which the record will be read. variable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable2 is not specified then the default file is assumed. expression1 should evaluate to a valid record key for the file. expression2 should evaluate to a positive integer. If the number is invalid or greater than the number of fields in the record, then a NULL string will be assigned to variable1. If the number is 0 then the value returned in variable1 is controlled by the readv0 emulation setting. If a non-numeric argument is evaluated a run time error will occur. If the SETTING clause is specified and the read fails, setvar will be set to an Incremental File Error code. If ON ERROR is specified, the statements following the ON ERROR clause will be executed for any Incremental File Error except error 128.",
                "detail": "READVU variable1 FROM { variable2,} expression1, expression2 {SETTING setvar} {ON ERROR statements} {LOCKED statements} THEN|ELSE statements",
                "snippet": "READVU ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Readxml",
                "icon": 14,
                "documentation": "The READXML statement reads a record from a file using the style sheet held in DICT->@READXML to transform the data into XML format.",
                "detail": "READXML rec FROM file, id ELSE STOP 202, id",
                "snippet": "READXML ${1:xml} FROM ${2:file},${3:id} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Recordlocked",
                "icon": 3,
                "documentation": "The RECORDLOCKED function can be called to ascertain the status of a record lock. filevar is a file variable from a previously executed OPEN statement. recordkey is an expression for the record id that will be checked. The function returns an integer value to indicate the record lock status of the specified record id. If the return value is negative, then the  SYSTEM(43) and STATUS function calls can be used to determine the port number of the program that holds the lock. If -1 is returned, more than 1 port could hold the lock and so the port number returned will be the first port number found.",
                "detail": "RECORDLOCKED(filevar, recordkey)",
                "snippet": "RECORDLOCKED(${1:filevar}, ${2:recordkey})"
            },
            {
                "key": "Regexp",
                "icon": 3,
                "documentation": "The REGEXP function is a powerful function that allows pattern matching using UNIX regular expressions. REGEXP is not supported on Windows. variable can be any type of jBC variable and is the variable upon which pattern matching will be performed. expression should evaluate to a standard UNIX regular expression as defined in the UNIX documentation. The function returns a numeric integer value being the first character in variable that failed to match the specified regular expression. If a match is not found or the regular expression was invalid then the function returns 0.",
                "detail": "REGEXP(variable, expression)",
                "snippet": "REGEXP(${1:variable}, ${2:expression})"
            },
            {
                "key": "Release",
                "icon": 14,
                "documentation": "The RELEASE statement explicitly releases record locks without updating the records using a WRITE or DELETE and it also clears all execution locks without issuing an UNLOCK. If variable is specified it should be a valid file descriptor variable (i.e. it should have been the subject of an OPEN statement). If an expression is supplied it should evaluate to the key of a record whose lock the program wishes to free. If variable was specified, the record lock on the file described by it is released. If variable was not specified the record lock on the file described by the default file variable is released. If RELEASE is called without arguments then all record locks in all files that were set by the current program will be released. It also releases all execution locks that were set in the current program with the LOCK statement.",
                "detail": "RELEASE {{variable,} expression}",
                "snippet": "RELEASE ${1:filevar}, ${2:expression}"
            },
            {
                "key": "Rem",
                "icon": 3,
                "documentation": "The MOD and REM functions return the arithmetic modulo (remainder) of two numeric expressions. Both expression1 and expression2 should evaluate to numeric expressions or a runtime error will occur. The modulo is calculated as the remainder of expression1 divided by expression2. If expression2 evaluates to 0, then the value of expression1 is returned.",
                "detail": "REM(expression1, expression2)",
                "snippet": "REM(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Remove",
                "icon": 3,
                "documentation": "The REMOVE function will successively extract delimited strings from a dynamic array. variable is the variable which is to receive the extracted string. array is the dynamic array from which the string is to be extracted. setvar is set by the system during the extraction to indicate the type of delimiter found. The first time the REMOVE statement is used with a particular array, it will extract the first delimited string and set the special \"remove pointer\" to the start of the next string (if any). The next time REMOVE is used on the same array, the pointer will be used to retrieve the next string and so on. The array is not altered. The variable named in the SETTING clause is used to record the type of delimiter that was found - so that you can tell whether the REMOVE statement extracted a field, a value or a subvalue for example. Delimiters are defined as characters between xF9 and xFF only. Once the end of the array has been reached, the string variable will not be updated and the SETTING clause will always return 0. You can reset the \"remove pointer\" by assigning the variable to itself - for example REC = REC.",
                "detail": "REMOVE variable FROM array SETTING setvar",
                "snippet": "REMOVE ${1:variable} FROM ${2:array} SETTING ${3:setvar}"
            },
            {
                "key": "Repeat",
                "icon": 14,
                "documentation": "REPEAT causes the loop to start again with the first statement following the LOOP statement.",
                "detail": "REPEAT",
                "snippet": "REPEAT"
            },
            {
                "key": "Replace",
                "icon": 3,
                "documentation": "This is an obsolete way to assign to dynamic arrays via a function. var is the dynamic array that the REPLACE function will use to assign expression4. Unless the same var is assigned the result of the function it will be unchanged. expression1 specifies into which field assignment will be made and should evaluate to a numeric. expression2 is only specified when multi-value assignment is to be done and should evaluate to a numeric. expression3 is only specified when sub-value assignment is to be done and should evaluate to a numeric. expression4 can evaluate to any data type and is the actual data that will be assigned to the array. The function returns a copy of var with the specified replacement carried out. This value may be assigned to the original var, in which case the jBC compiler will optimise the assignment.",
                "detail": "REPLACE(var, expression1{, expression2{, expression3}}; expression4)",
                "snippet": "REPLACE(${1:var}, ${2:attr}, ${3:value}, ${4:subvalue}; ${5:replace})"
            },
            {
                "key": "Return",
                "icon": 14,
                "documentation": "The RETURN statement transfers program execution to the caller of a subroutine\/function or to a specific label in the program. label must reference an existing label within the source of the program. expression evaluates to the value that is returned by a user-written function. The RETURN statement will transfer program execution to the statement after the GOSUB that called the current internal subroutine. If the RETURN statement is executed in an external SUBROUTINE and there are no outstanding GOSUBs, then the program will transfer execution to the CALL'ing program. The program will enter the debugger with an appropriate message should a RETURN be executed with no GOSUB or CALL outstanding. The second form of the RETURN statement is used to return a value from a user-written function. ",
                "detail": "RETURN {TO label}\nRETURN(expression)",
                "snippet": "RETURN"
            },
            {
                "key": "Rewind",
                "icon": 14,
                "documentation": "The REWIND statement will issue a rewind command to the device attached to the specified channel. expression, if specified, should evaluate to an integer in the range 0 to 9. Default is 0. If the statement fails to issue the rewind then any statements associated with the ELSE clause are executed. If the statement successfully issues the rewind command then the statements associated with any THEN clause are executed. Either or both of the THEN and ELSE clauses must be specified with the statement. If the statement fails then the reason for failure can be determined via the value of SYSTEM(0).",
                "detail": "REWIND {ON expression} THEN|ELSE statements",
                "snippet": "REWIND THEN\n\t${1:then_statements}\nEND ELSE\n\t${2:else_statements}\nEND"
            },
            {
                "key": "Right",
                "icon": 3,
                "documentation": "The RIGHT function returns a sub-string composed of the last n characters of a specified string. expression evaluates to the string from which the sub string is extracted. length is the number of characters that are extracted. If length is less than 1, RIGHT() returns null. The RIGHT() function is equivalent to sub-string extraction for the last n characters, i.e. expression[n]",
                "detail": "RIGHT(expression, length)",
                "snippet": "RIGHT(${1:expression}, ${2:length})"
            },
            {
                "key": "Rnd",
                "icon": 3,
                "documentation": "The RND function allows the generation of random numbers by a program. expression should evaluate to a numeric integer value or a runtime error will occur. The absolute value of expression is used by the function (see ABS). The highest number expression can be on Windows is PWR(2,15) - 1. The highest number on UNIX is PWR(2,31) - 1. The function will return a random integer number between 0 and the value of expression-1.",
                "detail": "RND(expression)",
                "snippet": "RND(${1:expression})"
            },
            {
                "key": "Rqm",
                "icon": 14,
                "documentation": "Allows the program to pause execution for a specified time period. Synonymous with SLEEP. expression may evaluate to one of two forms: * Numeric in which case the statement will sleep for the specified number of seconds or fractions of a second. * \"nn:nn{:nn}\" in which case the statement will sleep until the time specified. If expression is not supplied then a default time period of 1 second is assumed.",
                "detail": "RQM {expression}",
                "snippet": "RQM ${1:seconds}"
            },
            {
                "key": "Rtndata",
                "icon": 14,
                "documentation": "The RTNDATA statement allows a jBC program to return specific data to the RTNDATA clause of another program's EXECUTE statement. expression may evaluate to any data type. When a jBC program executes another jBC program using the EXECUTE statement, it may specify a variable to pick up data in using the RTNDATA clause. The data picked up will be that specified by the executed program using the RTNDATA statement. The data will be discarded if the program is not executed by an EXECUTE statement in another program.",
                "detail": "RTNDATA expression",
                "snippet": "RTNDATA ${1:expression}"
            },
            {
                "key": "Reuse",
                "icon": 3,
                "documentation": "The REUSE() function causes the previous field, value or subvalue to be reused in place of this default value where array structures do not match. The REUSE() function applies only to values in expressions; its effect cannot be assigned to a variable but it can be used to qualify an argument in a subroutine or function call.",
                "detail": "REUSE(dynamic.array)",
                "snippet": "REUSE(${1:dynarr})"
            },
            {
                "key": "Sadd",
                "icon": 3,
                "documentation": "The SADD function performs string addition of two base 10 string numbers. expr1 and expr2 are strings consisting of numeric characters, optionally including a decimal part. The SADD function can be used with numbers that may exceed a valid range with standard arithmetic operators. The  PRECISION declaration has no effect on the value returned by this function.",
                "detail": "SADD(expr1, expr2)",
                "snippet": "SADD(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Sdiv",
                "icon": 3,
                "documentation": "The SDIV function performs string division of two base 10 string numbers. The result is rounded to 14 decimal places. expr1 and expr2 are strings consisting of numeric characters, with either optionally including a decimal part. The SDIV function can be used with numbers that may exceed a valid range with standard arithmetic operators. The  PRECISION declaration has no effect on the value returned by this function.",
                "detail": "SDIV(expr1, expr2)",
                "snippet": "SDIV(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Seek",
                "icon": 14,
                "documentation": "The SEEK statement moves a file pointer by an offset specified in bytes, relative to the current position, the beginning of the file, or the end of the file. file.variable specifies a file previously opened for sequential access. offset is the number of bytes before or after the reference position. A negative offset results in the pointer being moved before the position specified by relto. If offset is not specified, 0 is assumed. On Windows systems, line endings in files are denoted by the character sequence RETURN + LINEFEED rather than the single LINEFEED used in UNIX files. The value of offset should take into account this extra byte on each line in Windows file systems. If relto is not specified, 0 is assumed. If the pointer is moved, the THEN statements are executed and the ELSE statements are ignored. If the THEN statements are not specified, program execution continues with the next statement. If the file cannot be accessed or does not exist the ELSE statements are executed; any THEN statements are ignored. If file.variable, offset, or relto evaluates to null, the SEEK statement fails and the program terminates with a run-time error message.",
                "detail": "SEEK file.variable [ , offset [ , relto] ] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "SEEK ${1:filevar}, ${2:offset}, ${3:relto} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Select",
                "icon": 14,
                "documentation": "The SELECT statement creates a select list of elements in a specified variable for use with the READNEXT statement. variable1 can be an OPENed file descriptor, in which case the record keys in the specified file will be selected, or an ordinary variable in which case each field in the variable will become a list element. variable1 may also be an existing list in which case the elements in the list will be selected. If variable1 is not specified in the statement then the default file variable is assumed. If variable2 is specified then the newly created list will be placed in the variable. Alternatively, a select list number in the range 0 to 10 can be specified with listnum. If neither variable2 nor listnum is specified then the default list variable will be assumed. If the SETTING clause is specified and the select fails, setvar will be set to an Incremental File Error code. When a list is being built from record keys in a file, the list is not created immediately by scanning the file for all the record keys. Instead, only the first few keys will be extracted. When these keys have been taken from the list, the next few keys will be obtained and so on. This means that the list could contain records that are written to the file after the SELECT command is started. If a variable is used to hold the select list, then it should be unassigned or null prior to the SELECT. If it contains a number in the range 0 to 10 then the corresponding select list number will be used to hold the list, although you can still reference the list with the variable name. When variable1 is a dynamic array (not a file descriptor) the result of variable2 is NOT a copy of variable1.",
                "detail": "SELECT {variable1} {TO variable2 | listnum} {SETTING setvar}",
                "snippet": "SELECT ${1:variable1} TO ${2:variable2} SETTING ${3:setvar}"
            },
            {
                "key": "Select",
                "icon": 14,
                "documentation": "This form of the SELECT statement allows you to use the index data in conjunction with an index definition variable created with an OPENINDEX statement. This form of the SELECT statement allows the index data to be used in conjunction with an index definition variable created with an OPENINDEX statement. The normal 'TO select-def' can be used to perform the selection to a numbered list or a variable instead of to the default select list. The use of the 'ATKEY index-key{,record-key{,vmcount}}' is optional and allows positioning at a specific point in the index. In its minimal form, the index key at which to start selection is specified. As each index key may contain many record keys, it is possible to sub-specify at which record key within that index to use as the starting position Finally, as each record may be multi-valued with the same index data, it is possible to sub-position at which value mark within the record key. The SELECT .. ATKEY statement uses raw data whereas the key-select and query-index programs assume the index specification is in external representation and pass it though any defined lookup code.",
                "detail": "SELECT indexvariable {TO select-def} {ATKEY index-key{,record-key{,vmcount}}}",
                "snippet": "SELECT ${1:indexvariable}"
            },
            {
                "key": "Selecte",
                "icon": 14,
                "documentation": "The SELECTE statement allows the contents of select list 0 to be assigned to a list variable. list.num is a select list number in the range 0 to 10",
                "detail": "SELECTE TO list.num",
                "snippet": "SELECTE TO ${1:list}"
            },
            {
                "key": "Selectindex",
                "icon": 14,
                "documentation": "This statement will create a dynamic array of record keys based on a single selection of a single index key value. It is more efficient to use a combination of OPENINDEX and READNEXT statements rather than the SELECTINDEX. index-name must correspond to the name of a valid index created on the file that has been opened to the file descriptor file-var. If index-key is specified it must correspond the the an indexed value within the index specified by index-name. If select-var is specified it is used to hold the select list created by the SELECTINDEX statement. Given an opened file descriptor this statement will select all the record keys in this file, sorted by the index definition 'index-name'. An optional variable 'index-key' can be used to restrict this selection to a single index key value. The value of 'index-key' will be the raw value of the index data - no lookup code processing will be done on this value.",
                "detail": "SELECTINDEX index-name{,index-key} FROM file-var {TO select-var}",
                "snippet": "SELECTINDEX ${1:indexname},${2:indexkey} FROM ${3:filevar} TO ${4:selectvar}"
            },
            {
                "key": "Selectn",
                "icon": 14,
                "documentation": "The SELECTN statement creates a select list of elements in a specified list number for use with the READNEXT statement. variable1 can be an OPENed file descriptor, in which case the record keys in the specified file will be selected, or an ordinary variable in which case each field in the variable will become a list element. variable1 may also be an existing list in which case the elements in the list will be selected. If variable1 is not specified in the statement then the default file variable is assumed. A select list number in the range 0 to 10 can be specified with listnum. If listnum is not specified then the default list variable will be assumed. If the SETTING clause is specified and the select fails, setvar will be set to an Incremental File Error code.",
                "detail": "SELECTN {variable1} {TO listnum} {SETTING setvar} {ON ERROR statements}",
                "snippet": "SELECTN ${1:variable1}"
            },
            {
                "key": "Selectv",
                "icon": 14,
                "documentation": "The SELECTV statement creates a select list of elements in a specified variable for use with the READNEXT statement. variable1 can be an OPENed file descriptor, in which case the record keys in the specified file will be selected, or an ordinary variable in which case each field in the variable will become a list element. variable1 may also be an existing list in which case the elements in the list will be selected. If variable1 is not specified in the statement then the default file variable is assumed. If variable2 is specified then the newly created list will be placed in the variable. If the SETTING clause is specified and the select fails, setvar will be set to an Incremental File Error code.",
                "detail": "SELECTV {variable1} {TO variable2} {SETTING setvar} {ON ERROR statements}",
                "snippet": "SELECTV ${1:variable1}"
            },
            {
                "key": "Send",
                "icon": 14,
                "documentation": "The SEND statement sends a block of data directly to a device. The output is an expression evaluating to a string that will be sent to the output device (specified by FileVar). It is expected that the device has already been opened with OPENSER or OPENSEQ. The SEND statement will append a newline sequence to the final output expression unless it is terminated with a colon. As the expression can be any valid expression, it may have output formatting applied to it. The SEND syntax requires that either a THEN or ELSE clause, or both, be specified. If the data is sent without error, the THEN clause is executed. If the data cannot be sent, the ELSE clause is executed.",
                "detail": "SEND output {:} TO FileVar THEN | ELSE statements",
                "snippet": "SEND ${1:output} TO ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Sendx",
                "icon": 14,
                "documentation": "The SENDX statement sends a block of data (in hexadecimal) directly to a device. The output is an expression evaluating to a string that will be sent to the output device (specified by FileVar). It is expected that the device has already been opened with OPENSER or OPENSEQ. The SENDX statement will append a newline sequence to the final output expression unless it is terminated with a colon. As the expression can be any valid expression, it may have output formatting applied to it. The SENDX syntax requires that either a THEN or ELSE clause, or both, be specified. If the data is sent without error, the THEN clause is executed. If the data cannot be sent, the ELSE clause is executed.",
                "detail": "SENDX output {:} TO FileVar THEN | ELSE statements",
                "snippet": "SENDX ${1:output} TO ${2:FileVar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Sentence",
                "icon": 3,
                "documentation": "The SENTENCE function allows a program to find out the command used to invoke it and the arguments it was given. If expression is specified it should evaluate to a positive integer value. A negative value will return a null string. A value of null will return the entire command line. An integer value of expression will return a specific element of the command line with the command itself being returned by SENTENCE(0), the first parameter being returned by SENTENCE(1) and so on. The command line arguments are assumed to be space separated and when the entire command line is returned they are returned as such. The SYSTEM(1000) function will return the command line attribute mark delimited.",
                "detail": "SENTENCE({expression})",
                "snippet": "SENTENCE(${1:expression})"
            },
            {
                "key": "Seq",
                "icon": 3,
                "documentation": "The SEQ function returns numeric ASCII value of a character. expression may evaluate to any data type. However the SEQ function will convert the expression to a string and operate on the first character of that string. The function operates on any character in the integer range 0 to 255",
                "detail": "SEQ(expression)",
                "snippet": "SEQ(${1:expression})"
            },
            {
                "key": "Seqs",
                "icon": 3,
                "documentation": "The SEQS function converts a dynamic array of ASCII characters to their numeric string equivalents. dynamic.array specifies the ASCII characters to be converted. If dynamic.array evaluates to null, it returns null. If any element of dynamic.array is null, it returns null for that element. If the subroutine syntax is used, the resulting dynamic array is returned as return.array. By using the function to convert a character outside its range results in a run-time message, and the return of an empty string.",
                "detail": "SEQS(dynamic.array)",
                "snippet": "SEQS(${1:DynArr})"
            },
            {
                "key": "Sin",
                "icon": 3,
                "documentation": "The SIN function returns the mathematical sine value of a numeric expression. expression should evaluate to a numeric value and is interpreted as a number of degrees between 0 and 360. The function will calculate the sine of the angle specified by the expression as accurately as the host system will allow. It will then truncate the value according to the PRECISION of the program.",
                "detail": "SIN(expression)",
                "snippet": "SIN(${1:expression})"
            },
            {
                "key": "Sleep",
                "icon": 3,
                "documentation": "Allows the program to pause execution for a specified time period. See also MSLEEP to sleep for a specified number of milliseconds. expression may evaluate to one of two forms: * Numeric in which case the statement will sleep for the specified number of seconds or fractions of a second. * 'nn:nn{:nn}' in which case the statement will sleep until the time specified. If expression is not supplied then a default time period of 1 second is assumed.",
                "detail": "SLEEP {expression}",
                "snippet": "SLEEP ${1:seconds}"
            },
            {
                "key": "Smul",
                "icon": 3,
                "documentation": "The SMUL function performs string multiplication of two base 10 string numbers. expr1 and expr2 are strings consisting of numeric characters, with either optionally including a decimal part. The SMUL function can be used with numbers that may exceed a valid range with standard arithmetic operators. The  PRECISION declaration does not affect the value returned by he function.",
                "detail": "SMUL(expr1, expr2)",
                "snippet": "SMUL(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Sort",
                "icon": 3,
                "documentation": "The SORT function sorts all elements of a dynamic array in ascending left-justified order. expression may evaluate to any data type but will only be useful if it evaluates to a dynamic array. The dynamic array can contain any number and combination of system delimiters. The SORT() function will return an attribute delimited array of the sorted elements. Note that all system delimiters in expression will be converted to an attribute mark '0xFE' in the sorted result. The SORT function is implemented using the quick sort algorithm, which sorts in situ and is very fast.",
                "detail": "SORT(expression)",
                "snippet": "SORT(${1:expression})"
            },
            {
                "key": "Soundex",
                "icon": 3,
                "documentation": "The SOUNDEX function allows phonetic conversions of strings. expression may evaluate to any data type, but the function will only return meaningful results for English words. The phonetic equivalent of a string is calculated as the first alphabetic character in the string followed by a 1 to 3 digit representation of the rest of the word.",
                "detail": "SOUNDEX(expression)",
                "snippet": "SOUNDEX(${1:expression})"
            },
            {
                "key": "Space",
                "icon": 3,
                "documentation": "The SPACE function is a convenient way to generate a specific number of ASCII space characters. expression should evaluate to a positive integer value. The SPACE function will return the specified number of ASCII space characters and is useful for padding strings. It should not be used to position output on the terminal screen however as this is inefficient and should be accomplished using the @( ) function.",
                "detail": "SPACE(expression)",
                "snippet": "SPACE(${1:int})"
            },
            {
                "key": "Spaces",
                "icon": 3,
                "documentation": "The SPACES function returns a dynamic array with elements composed of blank spaces. dynamic.array specifies the number of spaces in each element. If dynamic.array or any element of dynamic.array evaluates to null, the SPACES function will enter the debugger.",
                "detail": "SPACES(dynamic.array)",
                "snippet": "SPACES(${1:DynArr})"
            },
            {
                "key": "Splice",
                "icon": 3,
                "documentation": "The SPLICE function returns a dynamic array of the element by element concatenation of two dynamic arrays. Each element of array1 is concatenated with expression and with the corresponding element of array2. The result is returned in the corresponding element of a new dynamic array. If an element of one dynamic array has no corresponding element in the other dynamic array, the element is returned properly concatenated with expression. If either element of a corresponding pair is null, null is returned for that element. If expression evaluates to null, null is returned for the entire dynamic array.",
                "detail": "SPLICE(array1, expression, array2)",
                "snippet": "SPLICE(${1:array1}, ${2:expression}, ${3:array2})"
            },
            {
                "key": "Spooler",
                "icon": 3,
                "documentation": "The SPOOLER function returns information from the jBASE spooler. n specifies the information that is returned Port limits the information returned to the specified port User limits the information returned to the specified user.",
                "detail": "SPOOLER(n{, Port|User})",
                "snippet": "SPOOLER(${1:n}, ${2:port_user})"
            },
            {
                "key": "Sqrt",
                "icon": 3,
                "documentation": "The SQRT function returns the mathematical square root of a value. The expression should evaluate to a positive numeric value as the authors did not want to introduce a complex number type within the language. Negative values will cause a math error. The function calculates the result at the highest precision available and then truncates the answer to the required PRECISION.",
                "detail": "SQRT(expression)",
                "snippet": "SQRT(${1:expression})"
            },
            {
                "key": "Squote",
                "icon": 3,
                "documentation": "The function will put single quotation mark at the beginning and end of a string. expression may be any expression that is valid in the JBC language. The SQUOTE function will enclose the value in single quotation marks.",
                "detail": "SQUOTE(Expression)",
                "snippet": "SQUOTE(${1:expression})"
            },
            {
                "key": "Sselect",
                "icon": 14,
                "documentation": "The SSELECT statement allows the creation of numbered select list of record IDs in sorted order from a jBASE file or from a dynamic array. A select list of record IDs from a dynamic array is not in sorted order. variable can specify a dynamic array or a file variable. If it specifies a dynamic array, the record IDs must be separated by field marks (ASCII 254).  If variable specifies a file variable, the file variable must have previously been opened. If variable is not specified, the default file is assumed. If the file is neither accessible nor open, or if variable evaluates to null, the SSELECT statement fails and the program enters the debugger with a run-time error message. The TO clause specifies the select list that is to be used. list.number is an integer from 0 through 10. If no list.number is specified, select list 0 is used. The record IDs of all the records in the file forms the list. The record IDs are listed in ascending order Each record ID is one entry in the list. The ON ERROR clause is optional in SSELECT statement and allows an alternative to be specified for program termination when a fatal error is encountered during processing of a SSELECT statement.",
                "detail": "SSELECT [variable] [TO list.number] [ON ERROR statements]",
                "snippet": "SSELECT ${1:variable} TO ${2:list} ON ERROR ${3:statements}"
            },
            {
                "key": "Sselectn",
                "icon": 14,
                "documentation": "The SSELECTN statement allows the creation of numbered select list of record IDs from a jBASE file or dynamic array and stores the select list in a numbered list variable. A select list of record IDs from a dynamic array is not in sorted order. variable can specify a dynamic array or a file variable. If it specifies a dynamic array, the record IDs must be separated by field marks (ASCII 254).  If variable specifies a file variable, the file variable must have previously been opened. If variable is not specified, the default file is assumed. If the file is neither accessible nor open, or if variable evaluates to null, the SSELECT statement fails and the program enters the debugger with a run-time error message. The TO clause specifies the select list number that is to be used, weher list.number is an integer from 0 through 10. If no list.number is specified, select list 0 is used. The record IDs of all the records in the file forms the list. The record IDs are listed in ascending order Each record ID is one entry in the list. The ON ERROR clause is optional in SSELECT statement and allows an alternative to be specified for program termination when a fatal error is encountered during processing of a SSELECT statement.",
                "detail": "SSELECTN [variable] [TO list.number] [ON ERROR statements]",
                "snippet": "SSELECTN ${1:variable}"
            },
            {
                "key": "Sselectv",
                "icon": 14,
                "documentation": "The SSELECTV statement allows the creation of select list of record IDs from a jBASE file or dynamic array and stores the select list in a named list variable. A select list of record IDs from a dynamic array is not in sorted order. variable can specify a dynamic array or a file variable. If it specifies a dynamic array, the record IDs must be separated by field marks (ASCII 254).  If variable specifies a file variable, the file variable must have previously been opened. If variable is not specified, the default file is assumed. If the file is neither accessible nor open, or if variable evaluates to null, the SSELECT statement fails and the program enters the debugger with a run-time error message. The TO clause specifies the select list that is to be used. list.variable is an expression that evaluates to a valid variable name. The record IDs of all the records in the file forms the list. The record IDs are listed in ascending order Each record ID is one entry in the list. The ON ERROR clause is optional in SSELECT statement and allows an alternative to be specified for program termination when a fatal error is encountered during processing of a SSELECT statement.",
                "detail": "SSELECTV [variable] TO list.variable [ON ERROR statements]",
                "snippet": "SSELECTV ${1:variable} TO ${2:listvar}"
            },
            {
                "key": "Ssub",
                "icon": 3,
                "documentation": "The SSUB function performs string subtraction of two base 10 string numbers. expr1 and expr2 are strings consisting of numeric characters, optionally including a decimal part. The SSUB function can be used with numbers that may exceed a valid range with standard arithmetic operators. The  PRECISION declaration has no effect on the value returned by the function.",
                "detail": "SSUB(expr1, expr2)",
                "snippet": "SSUB(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Status",
                "icon": 3,
                "documentation": "Use the STATUS function after an OPENPATH statement to find the cause of a file open failure (that is, for a statement in which the ELSE clause is used).",
                "detail": "STATUS()",
                "snippet": "STATUS ${1:array} FROM ${2:variable} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Status",
                "icon": 14,
                "documentation": "Use the STATUS statement to determine the status of an open file. variable specifies an open file. If variable evaluates to the null value, the STATUS statement fails and the program terminates with a run-time error message. If the STATUS is assigned to an array, the THEN statements are executed and the ELSE statements are ignored. If no THEN statements are present, program execution continues with the next statement. If the attempt to assign the array fails, the ELSE statements are executed; any THEN statements are ignored.",
                "detail": "STATUS array FROM variable THEN statements ELSE statements|ELSE statements",
                "snippet": "STATUS ${1:array} FROM ${2:variable} THEN ${3:then_statements} ELSE ${4:else_statements}"
            },
            {
                "key": "Stop",
                "icon": 3,
                "documentation": "The STOP statement is virtually identical in function to the ABORT statement except that a calling jCL program will not be terminated. The optional message.number provided with the statement must be a numeric value, which corresponds to a record key in the jBASE error message file. A single expression or a list of expressions may follow the message.number. Where more than one expression is listed, they must be delimited by use of the comma character. The expression(s) correspond to the parameters that need to be passed to the error file record to display it. The optional message.number and expression(s) given with the command are parameters or resultants provided as variables, literal strings, expressions, or functions.",
                "detail": "STOP {message.number{, expression ...}}",
                "snippet": "STOP"
            },
            {
                "key": "Stope",
                "icon": 3,
                "documentation": "The STOPE statement simply uses a message in the jbcmessages file whose item id is the first 'Expression', so in fact it operates exactly the same as STOP.",
                "detail": "STOPE {expression{, expression ...}}",
                "snippet": "STOPE ${1:expression}"
            },
            {
                "key": "Stopm",
                "icon": 3,
                "documentation": "The STOPM statement uses the STOPM item in the jBASE error message file $JBCRELEASEDIR\/jbcmessages.",
                "detail": "STOPM {expression{, expression ...}}",
                "snippet": "STOPM ${1:expression}"
            },
            {
                "key": "Str",
                "icon": 3,
                "documentation": "The STR function allows the duplication of a string a number of times. expression1 will evaluate to the string to duplicate and may be of any length. expression2 should evaluate to a numeric integer, which specifies the number of times the string will be duplicated.",
                "detail": "STR(expression1, expression2)",
                "snippet": "STR(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Strs",
                "icon": 3,
                "documentation": "The STRS function produces a dynamic array containing the specified number of repetitions of each element of a dynamic array. dynamic.array is an expression that evaluates to the strings to be generated. repeat is an expression that evaluates to the number of times the elements are to be repeated. If it does not evaluate to a value that can be truncated to a positive integer, an empty string is returned for dynamic.array. If dynamic.array evaluates to null, it returns null. If any element of dynamic.array is null, null is returned for that element. If repeat evaluates to null, the function fails and the program enters the debugger.",
                "detail": "STRS(dynamic.array, repeat)",
                "snippet": "STRS(${1:DynArr}, ${2:repeat})"
            },
            {
                "key": "Subroutine",
                "icon": 14,
                "documentation": "The SUBROUTINE statement is used at the start of any program that will be called externally by the CALL statement. It also declares any parameters to the compiler. Name is the identifier by which the subroutine will be known to the compilation process. It should always be present as this name (not the source file name), will be used to call it by. However, if the name is left out, the compiler will name subroutine as the source file name (without suffixes). Default naming is not encouraged as it can cause problems if source files are renamed. Each comma separated variable in the optional parenthesized list is used to identify parameters to the compiler. These variables will be assigned the values passed to the subroutine by a CALL statement. The SUBROUTINE statement must be the first code line in a subroutine.",
                "detail": "SUB{ROUTINE} Name {({MAT} variable{,{MAT} variable...})}",
                "snippet": "SUBROUTINE ${1:name}(${2:args})"
            },
            {
                "key": "Subs",
                "icon": 3,
                "documentation": "The SUBS function returns a dynamic array, the content of which is derived by subtracting each element of the second dynamic array argument from the corresponding element of the first dynamic array argument. DynArr1 and DynArr2 represent dynamic arrays. Null elements of argument arrays are treated as zero. Otherwise, a non-numeric element in an argument array will cause a run-time error.",
                "detail": "SUBS(DynArr1, DynArr2)",
                "snippet": "SUBS(${1:DynArr1}, ${2:DynArr2})"
            },
            {
                "key": "Substrings",
                "icon": 3,
                "documentation": "The SUBSTRINGS function returns a dynamic array of elements which are sub-strings of the corresponding elements in a supplied dynamic array. DynArr should evaluate to a dynamic array. Start specifies the position from which characters are extracted from each array element. It should evaluate to an integer greater than zero. Length specifies the number of characters to extract from each dynamic array element. If the length specified exceeds the number of characters remaining in an array element, then all characters from the Start position are extracted.",
                "detail": "SUBSTRINGS(DynArr, Start, Length)",
                "snippet": "SUBSTRINGS(${1:DynArr}, ${2:start}, ${3:length})"
            },
            {
                "key": "Sum",
                "icon": 3,
                "documentation": "The SUM function sums numeric elements in a dynamic array. expr is a dynamic array. Non-numeric sub-values, values and attributes are ignored.",
                "detail": "SUM(DynaArr)",
                "snippet": "SUM(${1:DynArr})"
            },
            {
                "key": "Swap",
                "icon": 3,
                "documentation": "The SWAP function operates on a variable and replaces all occurrences of one string with another. expression1 may evaluate to any result and is the string of characters that will be replaced. expression2 may also evaluate to any result and is the string of characters that will replace expression1. The variable may be any previously assigned variable in the program. Either string can be of any length and is not required to be the same length. This function is provided for compatibility with older systems. See also the CHANGE() function.",
                "detail": "SWAP( variable, expression1, expression2 )",
                "snippet": "SWAP(${1:subject}, ${2:search}, ${3:replace})"
            },
            {
                "key": "System",
                "icon": 3,
                "documentation": "The SYSTEM functions return information about the current user and processes",
                "detail": "SYSTEM(integer)",
                "snippet": "SYSTEM(${1:int})"
            },
            {
                "key": "Tan",
                "icon": 3,
                "documentation": "The TAN function returns the mathematical tangent of an angle. expression should evaluate to a numeric type. The function calculates the result at the highest precision available on the host system. The result is truncated to the current PRECISION after calculation.",
                "detail": "TAN(expression)",
                "snippet": "TAN(${1:expression})"
            },
            {
                "key": "Time",
                "icon": 3,
                "documentation": "The TIME() function returns the current system time in internal format (as the number of seconds past midnight).",
                "detail": "TIME()",
                "snippet": "TIME()"
            },
            {
                "key": "Timedate",
                "icon": 3,
                "documentation": "The TIMEDATE() function returns the current time and date as a printable string. The function returns a string of the form: hh:mm:ss dd mmm yyyy , or in the appropriate format for the international date setting on the system.",
                "detail": "TIMEDATE()",
                "snippet": "TIMEDATE()"
            },
            {
                "key": "Timediff",
                "icon": 3,
                "documentation": "The TIMEDIFF function returns the interval between two timestamp values as a dynamic array. The function returns the interval between two timestamp values by subtracting the value of Timestamp2 from Timestamp1. The interval is returned as an attribute delimited array of the time difference. The Mask is an integer from 0 to 7.",
                "detail": "TIMEDIFF(Timestamp1, Timestamp2,Mask)",
                "snippet": "TIMEDIFF(${1:Timestamp1}, ${2:Timestamp2}, ${3:Mask})"
            },
            {
                "key": "Timeout",
                "icon": 14,
                "documentation": "The TIMEOUT statement terminates a READBLK or READSEQ statement. file.variable specifies a file opened for sequential access. time is an expression that evaluates to the number of seconds the program should wait before terminating the READSEQ statement. TIMEOUT causes subsequent READSEQ and READBLK statements to terminate and execute ELSE statements if the number of seconds specified by time elapses while waiting for data. If either file.variable or time evaluates to null, the TIMEOUT statement fails and the program enters the debugger.",
                "detail": "TIMEOUT file.variable, time",
                "snippet": "TIMEOUT ${1:filevar}, ${2:time}"
            },
            {
                "key": "Timestamp",
                "icon": 3,
                "documentation": "The TIMESTAMP function returns a UTC timestamp value as decimal seconds. The TIMESTAMP function returns a Universal Coordinated Time (UTC) value as decimal seconds, i.e. seconds with tenths and hundredths specified after the decimal point. The value is returned as a variable with as many decimal places as the current precision allows. However, successive calls may return the same value a number of times before the operating system updates the underlying timer.",
                "detail": "TIMESTAMP()",
                "snippet": "TIMESTAMP()"
            },
            {
                "key": "Trans",
                "icon": 3,
                "documentation": "The TRANS function will return the data value of a field, given the name of the file, the record key, the field number, and an action code. DICT is the literal string to be placed before the file name in the event it is desired to open the dictionary portion of the file, rather than the data portion. filename is a string containing the name of the file to be accessed.  Note that it is the actual name of the file, and not a file unit variable. This function requires the file name, regardless of whether or not the file has been opened to a file unit variable. key  is an expression that evaluates to the record key, or item ID, of the record from which data is to be accessed. field#  is the field number to be retrieved from the record. action.code  a literal which indicates what should happen if the field is null, or the if record is not found.",
                "detail": "TRANS ([DICT] filename, key, field#, action.code)",
                "snippet": "TRANS(${1:filename}, ${2:key}, ${3:field}, ${4:actioncode})"
            },
            {
                "key": "Transabort",
                "icon": 14,
                "documentation": "This statement is used to abort the current transaction and reverse any updates to the database. abort-text specifies an optional text string to save in the transaction abort record. A THEN or ELSE (or both) statement is required. The THEN clause will be be executed if the transaction is successfully aborted. The ELSE clause will be executed if the transaction abort fails for any reason.",
                "detail": "TRANSABORT {abort-text} [THEN statement | ELSE statement]",
                "snippet": "TRANSABORT ${1:aborttext} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Transend",
                "icon": 14,
                "documentation": "This statement is used to mark the end of a successfully completed transaction. end-text specifies an optional text string to save with the transaction end record. A THEN or ELSE (or both) statement is required. The THEN clause will be executed if the transaction is successfully ended. The ELSE clause will be executed if the transaction end fails for any reason.",
                "detail": "TRANSEND {end-text} [THEN statement | ELSE statement]",
                "snippet": "TRANSEND ${1:endtext} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Transquery",
                "icon": 14,
                "documentation": "This function is used to detect whether or not a transaction is active on the current process. TRANSQUERY will return 1 (true) if the process is within a transaction boundary, and 0 (false) if it is not. In other words, TRANSQUERY will return true if the TRANSTART statement has been issued but a TRANSEND or TRANSABORT statement has not yet been processed.",
                "detail": "ROLLBACK",
                "snippet": "TRANSQUERY()"
            },
            {
                "key": "Transtart",
                "icon": 14,
                "documentation": "In transaction processing, this statement is used to mark the beginning of a transaction. SYNC is an option to force the updates to be flushed at transaction end or abort. start-text specifies an optional text string to save with the transaction start record. A THEN or ELSE (or both) statement is required. The THEN clause will be executed if the transaction is successfully started. The ELSE clause will be executed if the transaction start fails for any reason.",
                "detail": "TRANSTART {SYNC}{start-text} [THEN statement | ELSE statement]",
                "snippet": "TRANSTART ${1:SYNC} ${2:starttext} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Trim",
                "icon": 3,
                "documentation": "The TRIM statement allows characters to be removed from a string in a number of ways. expression1 specifies the string from which to trim characters. expression2 may optionally specify the character to remove from the string. If not specified then the space character is assumed. expression3 evaluates to a single character specifies the type of trim to perform.",
                "detail": "TRIM(expression1 {, expression2{, expression3}})",
                "snippet": "TRIM(${1:expression1}, ${2:expression2}, ${3:type})"
            },
            {
                "key": "Trimb",
                "icon": 3,
                "documentation": "The TRIMB() function is equivalent to TRIM(expression, \" \", \"T\")",
                "detail": "TRIMB(expression)",
                "snippet": "TRIMB(${1:expression})"
            },
            {
                "key": "Trimbs",
                "icon": 3,
                "documentation": "The TRIMBS function removes all trailing spaces and tabs from each element of a dynamic array. TRIMBS removes all trailing spaces and tabs from each element and reduces multiple occurrences of spaces and tabs to a single space or tab. If dynamic.array evaluates to null, null is returned. If any element of dynamic.array is null, null is returned for that value.",
                "detail": "TRIMBS(dynamic.array)",
                "snippet": "TRIMBS(${1:DynArr})"
            },
            {
                "key": "Trimf",
                "icon": 3,
                "documentation": "The TRIMF() function is equivalent to TRIM(expression, \" \", \"L\")",
                "detail": "TRIMF(expression)",
                "snippet": "TRIMF(${1:expression})"
            },
            {
                "key": "Trimfs",
                "icon": 3,
                "documentation": "The TRIMFS function removes all leading, trailing and redundant spaces and tabs from each element of a dynamic array. TRIMFS removes all leading and trailing spaces and tabs from each element and reduces multiple occurrences of spaces and tabs to a single space or tab. If dynamic.array evaluates to null, null is returned. If any element of dynamic.array is null, null is returned for that value.",
                "detail": "TRIMFS(dynamic.array)",
                "snippet": "TRIMFS(${1:DynArr})"
            },
            {
                "key": "Trims",
                "icon": 3,
                "documentation": "The TRIMS function removes redundant spaces and tabs from each element of a dynamic array. Tdynamic.array specifies the elements to be scanned. If dynamic.array evaluates to null, it returns null. If any element of dynamic.array is null, it returns null for that element. If the subroutine syntax is used, the resulting dynamic array is returned as return.array. ",
                "detail": "TRIMS(dynamic.array)",
                "snippet": "TRIMS(${1:dynarr})"
            },
            {
                "key": "Unassigned",
                "icon": 3,
                "documentation": "The UNASSIGNED function allows a program to determine whether a variable has been assigned a value. variable is the name of variable used elsewhere in the program. The function returns Boolean TRUE if variable has not yet been assigned a value and Boolean FALSE if variable has already been assigned a value.",
                "detail": "UNASSIGNED(variable)",
                "snippet": "UNASSIGNED(${1:variable})"
            },
            {
                "key": "Uniquekey",
                "icon": 3,
                "documentation": "The UNIQUEKEY function returns a unique 16-byte character key. The UNIQUEKEY() function will generate a unique 16-byte character key on each call to the function. The key contains characters from the set A-Z a-z 0-9 ^ and _ (base64). Based on the current UTC time and the process number, the key is unique on a single computer system providing that the system clock is not turned back.",
                "detail": "UNIQUEKEY()",
                "snippet": "UNIQUEKEY()"
            },
            {
                "key": "Unlock",
                "icon": 14,
                "documentation": "The UNLOCK statement releases a previously LOCKed execution lock. If expression is specified it should evaluate to the number of a held execution lock, which will then be released. If expression is omitted then all execution locks held by the current program will be released. No action is taken if the program attempts to release an execution lock that it had not taken.",
                "detail": "UNLOCK {expression}",
                "snippet": "UNLOCK(${1:expression})"
            },
            {
                "key": "Until",
                "icon": 14,
                "documentation": "The UNTIL statement terminates a FOR or LOOP loop when the specified expression is true. The optional DO is required in a LOOP",
                "detail": "UNTIL expr {DO}",
                "snippet": "UNTIL ${1:expr} DO"
            },
            {
                "key": "Upcase",
                "icon": 3,
                "documentation": "UPCASE converts all lowercase characters in an expression to uppercase characters. expression in a string containing alphabetic characters.",
                "detail": "UPCASE(expression)",
                "snippet": "UPCASE(${1:expression})"
            },
            {
                "key": "Utf8",
                "icon": 3,
                "documentation": "The UTF8 function converts a latin1 or binary string into the UTF-8 equivalent byte sequence. The expression is expected to be a binary\/latin1code page string. The function converts the binary string into a UTF-8 encoded byte sequence, used to represent the Unicode values for each byte in the expression. This function is useful for converting binary or latin1 code page data into internal format when in International Mode",
                "detail": "UTF8(expression)",
                "snippet": "UTF8(${1:expression})"
            },
            {
                "key": "Wake",
                "icon": 14,
                "documentation": "The WAKE statement is used to wake a suspended process which has executed a PAUSE statement. PortNumber is a reference to the target port to be awoken. The WAKE statement has no effect on processes which do not execute the PAUSE statement.",
                "detail": "WAKE PortNumber",
                "snippet": "WAKE ${1:portnumber}"
            },
            {
                "key": "Weof",
                "icon": 14,
                "documentation": "The WEOF statement allows the program to write an EOF mark on an attached tape device. expression specifies the device channel to use, which should evaluate to a numeric integer argument in the range 0-9. Default value is 0. f the WEOF fails then the statements associated with any ELSE clause will be executed. SYSTEM(0) will return a reason code for the failure. A \"tape\" not only refers to magnetic tape devices but to any device that has been described to jBASE. If no tape device has been assigned to the channel specified then the jBASE debugger is entered with an appropriate message.",
                "detail": "WEOF {ON expression}",
                "snippet": "WEOF"
            },
            {
                "key": "Weofseq",
                "icon": 14,
                "documentation": "Write end of file on file opened for sequential access. FileVar specifies the file descriptor of the file opened for sequential access. Statements are conditional jBC statements WEOFSEQ forces the file to be truncated at the current file pointer. Nothing is actually 'written' to the sequential file.",
                "detail": "WEOFSEQ FileVar { THEN | ELSE Statements}",
                "snippet": "WEOFSEQ ${1:filevar} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "While",
                "icon": 14,
                "documentation": "The WHILE statement terminates a FOR or LOOP loop when the specified expression is true. The optional DO is required in a LOOP.",
                "detail": "WHILE expr {DO}",
                "snippet": "WHILE ${1:expr} DO"
            },
            {
                "key": "Write",
                "icon": 14,
                "documentation": "The WRITE statement allows a program to write a record into a previously opened file. variable1 is the identifier containing the record to write. variable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable2 is not specified then the default file is assumed.r The expression should evaluate to a valid record key for the file. If the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code. If a lock was being held on the record by this process it will be released by the WRITE. If a lock should be retained on a record, it should be done so explicitly with the WRITEU statement. A 'WRITE' of a null item-id to a directory will take the 'ON ERROR' clause, if it exists.",
                "detail": "WRITE variable1 ON|TO { variable2,} expression {SETTING setvar} {ON ERROR statements}",
                "snippet": "WRITE ${1:var} TO ${2:filevar},${3:recordkey}"
            },
            {
                "key": "Writeblk",
                "icon": 14,
                "documentation": "The WRITEBLK statement writes a block of data to a file opened for sequential processing. Each WRITEBLK statement writes the value of expression starting at the current position in the file. The current position is incremented to beyond the last byte written. WRITEBLK does not add a new line at the end of the data. file.variable specifies a file opened for sequential processing. The value of expression is written to the file, and the THEN statements are executed. If no THEN statements are specified, program execution continues with the next statement. If the file is neither accessible or does not exist, it executes the ELSE statements; and ignores any THEN statements. If either expression or file.variable evaluates to null, the WRITEBLK statement fails and the program enters the debugger with a run-time error message.",
                "detail": "WRITEBLK expression ON file.variable {THEN statements [ELSE statements]|ELSE statements}",
                "snippet": "WRITEBLK ${1:expression} ON ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Writelist",
                "icon": 14,
                "documentation": "WRITELIST allows the program to store a list held in a jBC variable to the global list file. variable is the variable in which the list is held. expression should evaluate to the required list name. If expression is null, the list will be written to the default external list. If the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code.",
                "detail": "WRITELIST variable ON|TO expression {SETTING setvar} {ON ERROR statements}",
                "snippet": "WRITELIST ${1:var} TO ${2:expression}"
            },
            {
                "key": "Writeseq",
                "icon": 14,
                "documentation": "Write to a file opened for sequential access. Variable specifies the variable to contain next record from sequential file. FileVar specifies the file descriptor of the file opened for sequential access. Statements conditional jBC statements. Each WRITESEQ writes the data on a line of the sequentially opened file. Each line of data is suffixed with a new line character. After each WRITESEQ the file pointer moves forward to the end of line. The APPEND option forces each WRITESEQ to advance to the end of the file before writing the next data line.",
                "detail": "WRITESEQ Expression {APPEND} ON|TO FileVar THEN | ELSE statements",
                "snippet": "WRITESEQ ${1:expression} ${2:APPEND} TO ${3:filevar} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Writeseqf",
                "icon": 14,
                "documentation": "Write to a file opened for sequential access and force each data line to be flushed to the file when it is written. Variable specifies the variable to contain next record from sequential file. FileVar specifies the file descriptor of the file opened for sequential access. Statements conditional jBC statements. Each WRITESEQ writes the data on a line of the sequentially opened file. Each line of data is suffixed with a new line character. After each WRITESEQ the file pointer moves forward to the end of line. The WRITESEQF statement forces each data line to be flushed to the file when it is written. The APPEND option forces each WRITESEQ to advance to the end of the file before writing the next data line.",
                "detail": "WRITESEQF Expression {APPEND} ON|TO FileVar THEN | ELSE statements",
                "snippet": "WRITESEQF ${1:expression} TO ${2:filevar} ON ERROR ${3:error_statements} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Writet",
                "icon": 14,
                "documentation": "The WRITET statement enables data to be written to a range of tape devices between 0-9. variable holds the data for writing to the tape device. expression should evaluate to an integer value in the range 0-9 and specifies which tape channel to read data from. If the ON clause is not specified the WRITET will assume channel 0. If the WRITET fails then the statements associated with any ELSE clause will be executed. SYSTEM(0) will return the reason code for the failure. A \"tape\" not only refers to magnetic tape devices but also any device that has been described to jBASE. If no tape device has been assigned to the channel specified then the jBASE debugger is entered with an appropriate message.",
                "detail": "WRITET variable {ON|TO expression} THEN|ELSE statements",
                "snippet": "WRITET ${1:var} TO ${2:expression} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Writeu",
                "icon": 14,
                "documentation": "The WRITEU statement allows a program to write a record into a previously opened file. An existing record lock will be preserved. variable1 is the identifier holding the record to be written. variable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable2 is not specified then the default file is assumed. The expression should evaluate to a valid record key for the file. If the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code. If the statement fails to write the record then any statements associated with the ON ERROR clause are executed. The lock maintained by the WRITEU statement will be released by any of the following events: * the record is written to by the same program with WRITE, WRITEV or MATWRITE statements. * the record lock is released explicitly using the RELEASEstatement. * the program stops normally or abnormally.",
                "detail": "WRITEU variable1 ON|TO { variable2,} expression {SETTING setvar} {ON ERROR statements}",
                "snippet": "WRITEU ${1:var} TO ${2:filevar},${3:recordkey}"
            },
            {
                "key": "Writev",
                "icon": 14,
                "documentation": "The WRITEV statement allows a program to write a specific field of a record in a previously opened file. variable1 is the identifier holding the record to be written. variable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable2 is not specified then the default file is assumed. expression1 should evaluate to a valid record key for the file. expression2 should evaluate to a positive integer number. If the number is greater than the number of fields in the record, null fields will be added to variable1. If expression2 evaluates to a non-numeric argument, a run time error will be generated. If the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code. The WRITEV statement will cause any lock held on the record by this program to be released. If a lock on the record should be retained, that should be done so explicitly with the WRITEVU statement.",
                "detail": "WRITEV variable1 ON|TO {variable2,} expression1, expression2 {SETTING setvar} {ON ERROR statements}",
                "snippet": "WRITEV ${1:var} TO ${2:filevar},${3:recordkey},${4:attr}"
            },
            {
                "key": "Writevu",
                "icon": 14,
                "documentation": "The WRITEVU statement allows a program to write a specific field on a record in a previously opened file. An existing record lock will be preserved. variable1 is the identifier holding the record to be written. variable2, if specified, should be a jBC variable that has previously been opened to a file using the OPEN statement. If variable2 is not specified then the default file is assumed. expression1 should evaluate to a valid record key for the file. expression2 should evaluate to a positive integer number. If the number is greater than the number of fields in the record, null fields will be added to variable1. If expression2 evaluates to a non-numeric argument, a run time error will be generated. If the SETTING clause is specified and the write fails, setvar will be set to an Incremental File Error code. If the statement fails to write the record then any statements associated with the ON ERROR clause are executed. The lock taken by the WRITEVU statement will be released by any of the following events: * The record is written to by the same program with WRITE, WRITEV or MATWRITE statements. * The record lock is released explicitly using the RELEASE statement. * The program stops normally or abnormally.",
                "detail": "WRITEVU variable1 ON|TO { variable2,} expression1, expression2 {SETTING setvar} {ON ERROR statements}",
                "snippet": "WRITEVU ${1:var} TO ${2:filevar},${3:recordkey},${4:attr}"
            },
            {
                "key": "Writexml",
                "icon": 14,
                "documentation": "The WRITEXML statement writes a dynamic array to a hashed file in XML format, using a style sheet from the DICT. The XML is transformed into a dynamic array before being written to the file. The transformation takes place using the stylesheet in DICT->@WRITEXML.",
                "detail": "WRITEXML rec ON file,id ELSE STOP 201,id",
                "snippet": "WRITEXML ${1:rec} ON ${2:filevar},${3:recordkey} ON ERROR ${4:error_statements} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Xlate",
                "icon": 3,
                "documentation": "The XLATE function will return the data value of a field, given the name of the file, the record key, the field number, and an action code.DICT is the literal string to be placed before the file name in the event it is desired to open the dictionary portion of the file, rather than the data portion. filename is a string containing the name of the file to be accessed.  Note that it is the actual name of the file, and not a file unit variable. This function requires the file name, regardless of whether or not the file has been opened to a file unit variable. key  is an expression that evaluates to the record key, or item ID, of the record from which data is to be accessed. field#  is the field number to be retrieved from the record. action.code  a literal which indicates what should happen if the field is null, or the if record is not found. XLATE is a synonym of the TRANS function.",
                "detail": "XLATE ([DICT] filename, key, field#, action.code)",
                "snippet": "XLATE(${1:filename}, ${2:recordkey}, ${3:field}, ${4:actioncode})"
            },
            {
                "key": "Xmltodyn",
                "icon": 3,
                "documentation": "The XMLTODYN function converts an XML expression to a dynamic array, using an optional XSL to transform. Array = XMLTODYN(XML,XSL,result) If result = 0 Array will contain a dynamic array built from the xml \/ xsl. If result <> 0, Array will contain an error message.",
                "detail": "XMLTODYN(XML, XSL, result)",
                "snippet": "XMLTODYN(${1:xml}, ${2:xsl}, ${3:result})"
            },
            {
                "key": "Xmltoxml",
                "icon": 3,
                "documentation": "The XMLTOXML function transforms an XML expression using an XSL. newxml=XMLTOXML(XML, XSL, result) If result = 0, newxml  will contain a transformed version of XML using XSL. If result = 1, newxml will contain an error message.",
                "detail": "XMLTOXML(XML, XSL, result)",
                "snippet": "XMLTOXML(${1:xml}, ${2:xsl}, ${3:result})"
            },
            {
                "key": "Xtd",
                "icon": 3,
                "documentation": "The XTD() function converts hexadecimal number into its decimal equivalent. expression should evaluate to a valid hexadecimal string. The conversion process will halt at the first character that is not a valid base 16 character in the set [0-9, A-F or a-f].",
                "detail": "XTD(expression)",
                "snippet": "XTD(${1:expression})"
            },
            {
                "key": "$Option",
                "icon": 14,
                "documentation": "The $OPTION directive allows dynamic objects options\/parameters to be specified. keyword is currently one or more of the following:  arrow|auto|case|debug|jabba|keywords|object|period|self|stats|tokens|trace|universe|uv|uvcase|warning|warnings , commas separated.",
                "detail": "$option keyword",
                "snippet": "${1:option} keyword"
            }
        ]
    }
}
