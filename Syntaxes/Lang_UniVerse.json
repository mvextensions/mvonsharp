{
    "Language": {
        "Type": "UniVerse Basic",
        "Keywords": [
            {
                "key": "#Include",
                "icon": 14,
                "documentation": "Inserts and compiles UniVerse BASIC source code from another program into the program being compiled. Same as the $INCLUDE and INCLUDE statements.",
                "detail": "#INCLUDE [filename] program\n#INCLUDE program FROM filename ",
                "snippet": "#INCLUDE ${1:filename} ${2:program}"
            },
            {
                "key": "$Chain",
                "icon": 14,
                "documentation": "Inserts and compiles UniVerse BASIC source code from another program into the program being compiled.",
                "detail": "$CHAIN [filename] progam",
                "snippet": "$CHAIN ${1:filename} ${2:program}"
            },
            {
                "key": "$Copyright",
                "icon": 14,
                "documentation": "Inserts comments into the object code header. (UniVerse supports this statement for compatibility with existing software.)",
                "detail": "$COPYRIGHT \"copyright notice\"",
                "snippet": "$COPYRIGHT ${1:str}"
            },
            {
                "key": "$Define",
                "icon": 14,
                "documentation": "Defines a compile time symbol.",
                "detail": "$DEFINE identifier [replacementText]",
                "snippet": "$DEFINE ${1:identifier} ${2:text}"
            },
            {
                "key": "$Eject",
                "icon": 14,
                "documentation": "Begins a new page in the listing record. (UniVerse supports this statement for compatibility with existing software.) Same as the $PAGE statement.",
                "detail": "$EJECT",
                "snippet": "$EJECT"
            },
            {
                "key": "$Ifdef",
                "icon": 14,
                "documentation": "Tests for the definition of a compile time symbol.",
                "detail": "$IFDEF identifier\n   [statements]\n[[$ELSE]]\n   [statements]\n$ENDIF",
                "snippet": "$IFDEF ${1:identifier} ${2:statements} \\${3:ELSE}\\n\t${4:else_statements}\\n\\${5:ENDIF}"
            },
            {
                "key": "$Ifndef",
                "icon": 14,
                "documentation": "Tests for the definition of a compile time symbol.",
                "detail": "$IFNDEF identifier\n   [statements]\n[[$ELSE]]\n   [statements]\n$ENDIF",
                "snippet": "$IFNDEF ${1:identifier} ${2:statements} \\${3:ELSE}\\n\t${4:else_statements}\\n\\${5:ENDIF}"
            },
            {
                "key": "$Include",
                "icon": 14,
                "documentation": "The $INCLUDE\\$INSERT directive inserts the program\/code snippet specified into the current source code. If the optional filename is specified the code is read from that file.",
                "detail": "$INCLUDE [filename]  program\n$INCLUDE program FROM filename ",
                "snippet": "$INCLUDE ${1:filename} ${2:program}"
            },
            {
                "key": "$Insert",
                "icon": 14,
                "documentation": "Performs the same operation as $INCLUDE; the only difference is in the syntax. (UniVerse supports this statement for compatibility with existing software.)",
                "detail": "$INSERT [filename] program\n$INSERT program FROM filename ",
                "snippet": "$INSERT ${1:primospathname}"
            },
            {
                "key": "$Map",
                "icon": 14,
                "documentation": "In NLS mode, specifies the map for the source code.",
                "detail": "$MAP mapname",
                "snippet": "$MAP ${1:mapname}"
            },
            {
                "key": "$Options",
                "icon": 14,
                "documentation": "Sets compile time emulation of UniVerse flavors.",
                "detail": "$OPTIONS [flavor] [optons]",
                "snippet": "$OPTIONS ${1:flavor} ${2:options}"
            },
            {
                "key": "$Page",
                "icon": 14,
                "documentation": "Begins a new page in the listing record. (UniVerse supports this statement for compatibility with existing software.) Same as the $EJECT statement.",
                "detail": "$PAGE",
                "snippet": "$PAGE"
            },
            {
                "key": "$Undefine",
                "icon": 14,
                "documentation": "Removes the definition for a compile time symbol.",
                "detail": "$UNDEFINE identifier",
                "snippet": "$UNDEFINE ${1:identifier}"
            },
            {
                "key": "@Abort.Code",
                "icon": 12,
                "documentation": "A numeric value indicating the type of condition that caused the ON.ABORT paragraph to execute. The values are: 1 An ABORT statement was executed. 2 An abort was requested after pressing the Break key followed by option A. 3 An internal or fatal error occurred. 4 An AUTO.LOGOUT event occurred.",
                "detail": "@ABORT.CODE"
            },
            {
                "key": "@Account",
                "icon": 12,
                "documentation": "User login name. Same as @LOGNAME. Non-stacked.",
                "detail": "@ACCOUNT"
            },
            {
                "key": "@Am",
                "icon": 21,
                "documentation": "Inserts an attribute mark CHAR(254)",
                "detail": "@AM"
            },
            {
                "key": "@Ans ",
                "icon": 12,
                "documentation": "Last I-type answer, value indeterminate.",
                "detail": "@ANS variable"
            },
            {
                "key": "@Authorization ",
                "icon": 12,
                "documentation": "Current effective user name.",
                "detail": "@AUTHORIZATION variable"
            },
            {
                "key": "@Command ",
                "icon": 12,
                "documentation": "Last command executed or entered at the UniVerse prompt.",
                "detail": "@COMMAND"
            },
            {
                "key": "@Command.Stack ",
                "icon": 12,
                "documentation": "Dynamic array containing the last 99 TCL commands executed.",
                "detail": "@COMMAND.STACK"
            },
            {
                "key": "@Conv ",
                "icon": 1,
                "documentation": "For future use.",
                "detail": "@CONV variable"
            },
            {
                "key": "@Crthigh ",
                "icon": 12,
                "documentation": "Number of lines on the terminal.",
                "detail": "@CRTHIGH"
            },
            {
                "key": "@Crtwide ",
                "icon": 12,
                "documentation": "Number of columns on the terminal.",
                "detail": "@CRTWIDE"
            },
            {
                "key": "@Data.Pending ",
                "icon": 12,
                "documentation": "Dynamic array containing input generated by the DATA statement. Values in the dynamic array are separated by field marks.",
                "detail": "@DATA.PENDING"
            },
            {
                "key": "@Date ",
                "icon": 12,
                "documentation": "Internal date when the program was invoked.",
                "detail": "@DATE"
            },
            {
                "key": "@Day ",
                "icon": 12,
                "documentation": "Day of month from @DATE.",
                "detail": "@DAY"
            },
            {
                "key": "@Dict ",
                "icon": 12,
                "documentation": "For future use.",
                "detail": ""
            },
            {
                "key": "@False ",
                "icon": 12,
                "documentation": "Compiler replaces the value with 0.",
                "detail": "@FALSE"
            },
            {
                "key": "@File.Name ",
                "icon": 12,
                "documentation": "Current file name. When used in a virtual field index, @FILENAME reflects the current file name being used in a RetrieVe or UniVerse SQL statement. Same as @FILENAME.",
                "detail": "@FILE.NAME"
            },
            {
                "key": "@Filename ",
                "icon": 12,
                "documentation": "Current file name. When used in a virtual field index, @FILENAME reflects the current file name being used in a RetrieVe or UniVerse SQL statement. Same as @FILE.NAME.",
                "detail": "@FILENAME"
            },
            {
                "key": "@Fm ",
                "icon": 12,
                "documentation": "Field mark: CHAR(254). Same as @AM.",
                "detail": "@FM"
            },
            {
                "key": "@Format ",
                "icon": 12,
                "documentation": "For future use.",
                "detail": ""
            },
            {
                "key": "@Hdbc ",
                "icon": 12,
                "documentation": "ODBC connection environment on the local UniVerse server. Non-stacked.",
                "detail": "@HDBC"
            },
            {
                "key": "@Header ",
                "icon": 12,
                "documentation": "For future use.",
                "detail": ""
            },
            {
                "key": "@Henv ",
                "icon": 12,
                "documentation": "ODBC environment on the local UniVerse server. Non stacked.",
                "detail": "@HENV"
            },
            {
                "key": "@Hstmt ",
                "icon": 12,
                "documentation": "ODBC statement environment on the local UniVerse server. Non-stacked.",
                "detail": "@HSTMT"
            },
            {
                "key": "@Id ",
                "icon": 12,
                "documentation": "Current record ID.",
                "detail": "@ID variable"
            },
            {
                "key": "@Idx.Filepath ",
                "icon": 12,
                "documentation": "Can be used within an indexed subroutine. Contains the full path of the UniVerse file being updated that caused the indexed subroutine to fire.",
                "detail": "@IDX.FILEPATH"
            },
            {
                "key": "@Idx.Iotype ",
                "icon": 12,
                "documentation": "Specifies the type of operation being performed. Can be integrated in the indexed subroutine to determine they type of database operation that caused the indexed subroutine to fire. The following values are associated with the @IDX.IOTYPE: 0 - The value returned when @IDX.IOTYPE is used outside the context of an indexed subroutine. 1 - The value returned when the SUBR is called because an INSERT operation is performed. 2 - The value returned when the SUBR is called because a DELETE operation is performed. 3 - The value returned when the SUBR is called because an UPDATE operation is used to evaluate the original value operation. 4 - The value returned when a SUBR i called because an UPDATE operation is used to evaluate the new value operation.",
                "detail": "@IDX.IOTYPE variable"
            },
            {
                "key": "@Im ",
                "icon": 12,
                "documentation": "Item mark: CHAR(255).",
                "detail": "@IM variable"
            },
            {
                "key": "@Isolation ",
                "icon": 12,
                "documentation": "Current transaction isolation level for the active transaction or the current default isolation level if no transaction exists.",
                "detail": ""
            },
            {
                "key": "@Level ",
                "icon": 12,
                "documentation": "Nesting level of execution statements. Non-stacked.",
                "detail": "@LEVEL"
            },
            {
                "key": "@Logname ",
                "icon": 12,
                "documentation": "User login name. Same as @ACCOUNT.",
                "detail": "@LOGNAME"
            },
            {
                "key": "@Lptrhigh",
                "icon": 12,
                "documentation": "Number of lines on the device to which you are printing (that is, terminal or printer).",
                "detail": "@LPTRHIGH"
            },
            {
                "key": "@Lptrwide G49",
                "icon": 12,
                "documentation": "Number of columns on the device to which you are printing (that is, terminal or printer).",
                "detail": "@LPTRWIDE "
            },
            {
                "key": "@Month ",
                "icon": 12,
                "documentation": "Current month.",
                "detail": "@MONTH "
            },
            {
                "key": "@Mv ",
                "icon": 12,
                "documentation": "Current value counter for columnar listing only. Used only in I-descriptors. Same as @NV.",
                "detail": "@MV"
            },
            {
                "key": "@Nb ",
                "icon": 12,
                "documentation": "Current BREAK level number. 1 is the lowest-level break. @NB has a value of 255 on the grand total line. Used only in I-descriptors.",
                "detail": "@NB"
            },
            {
                "key": "@Nd ",
                "icon": 12,
                "documentation": "Number of detail lines since the last BREAK on a break line. Used only in I-descriptors.",
                "detail": "@ND"
            },
            {
                "key": "@Ni ",
                "icon": 12,
                "documentation": "Current item counter (the number of items listed or selected). Used only in I-descriptors. Same as @RECCOUNT.",
                "detail": "@NI"
            },
            {
                "key": "@Ns ",
                "icon": 12,
                "documentation": "Current subvalue counter for columnar listing only. Used only in I-descriptors.",
                "detail": "@NS"
            },
            {
                "key": "@Null ",
                "icon": 12,
                "documentation": "The null value. Non-stacked.",
                "detail": "@NULL"
            },
            {
                "key": "@Nulls.Str ",
                "icon": 12,
                "documentation": "Internal representation of the null value, which is CHAR(128). Non-stacked.",
                "detail": "@NULL.STR"
            },
            {
                "key": "@Nv ",
                "icon": 12,
                "documentation": "Current value counter for columnar listing only. Used only in I-descriptors. Same as @MV.",
                "detail": "@NV"
            },
            {
                "key": "@Option ",
                "icon": 12,
                "documentation": "Value of field 5 in the VOC for the calling verb.",
                "detail": "@OPTION"
            },
            {
                "key": "@Parasentence",
                "icon": 12,
                "documentation": "Last sentence or paragraph that invoked the current process.",
                "detail": "@PARASENTENCE "
            },
            {
                "key": "@Path ",
                "icon": 12,
                "documentation": "Pathname of the current account.",
                "detail": "@PATH"
            },
            {
                "key": "@Reccount ",
                "icon": 12,
                "documentation": "Current item counter (the number of items listed or selected). Used only in I-descriptors. Same as @NI.",
                "detail": "@RECCOUNT"
            },
            {
                "key": "@Record ",
                "icon": 12,
                "documentation": "Entire current record.",
                "detail": "@RECORD"
            },
            {
                "key": "@Recur0 ",
                "icon": 1,
                "documentation": "Reserved.",
                "detail": ""
            },
            {
                "key": "@Recur1 ",
                "icon": 1,
                "documentation": "Reserved.",
                "detail": ""
            },
            {
                "key": "@Recur2 ",
                "icon": 1,
                "documentation": "Reserved.",
                "detail": ""
            },
            {
                "key": "@Recur3 ",
                "icon": 1,
                "documentation": "Reserved.",
                "detail": ""
            },
            {
                "key": "@Recur4 ",
                "icon": 1,
                "documentation": "Reserved.",
                "detail": ""
            },
            {
                "key": "@Schema ",
                "icon": 12,
                "documentation": "Schema name of the current UniVerse account. Non stacked. When users create a new schema, @SCHEMA is not set until the next time they log in to UniVerse.",
                "detail": "@SCHEMA"
            },
            {
                "key": "@Selected ",
                "icon": 21,
                "documentation": "Number of elements selected from the last select list. Non-stacked.",
                "detail": "@SELECTED"
            },
            {
                "key": "@Sentence ",
                "icon": 12,
                "documentation": "Sentence that invoked the current BASIC program. Any EXECUTE statement updates @SENTENCE.",
                "detail": "@SENTENCE"
            },
            {
                "key": "@Sm ",
                "icon": 21,
                "documentation": "Subvalue mark: CHAR(252). Same as @SVM.",
                "detail": "@SM"
            },
            {
                "key": "@SQL.Code ",
                "icon": 1,
                "documentation": "For future use.",
                "detail": "@SQL.CODE variable"
            },
            {
                "key": "@SQL.Date ",
                "icon": 12,
                "documentation": "Current system date. Use in trigger programs. Non stacked.",
                "detail": "@SQL.DATE"
            },
            {
                "key": "@SQL.Error ",
                "icon": 1,
                "documentation": "For future use.",
                "detail": "@SQL.ERROR variable"
            },
            {
                "key": "@SQL.State ",
                "icon": 1,
                "documentation": "For future use.",
                "detail": "@SQL.STATE variable"
            },
            {
                "key": "@SQL.Time ",
                "icon": 12,
                "documentation": "Current system time. Use in trigger programs. Non stacked.",
                "detail": "@SQL.TIME"
            },
            {
                "key": "@SQL.Warning ",
                "icon": 1,
                "documentation": "For future use.",
                "detail": "@SQL.WARNING variable"
            },
            {
                "key": "@SQLProc.Name ",
                "icon": 12,
                "documentation": "Name of the current SQL procedure.",
                "detail": "@SQLPROC.NAME"
            },
            {
                "key": "@SQLProc.Tx.Level",
                "icon": 12,
                "documentation": "Transaction level at which the current SQL procedure began.",
                "detail": "@SQLPROC.TX.LEVEL"
            },
            {
                "key": "@Stdfil ",
                "icon": 12,
                "documentation": "Default file variable.",
                "detail": "@STDFIL variable"
            },
            {
                "key": "@Svm",
                "icon": 21,
                "documentation": "Inserts a subvalue mark CHAR(252)",
                "detail": "@SVM"
            },
            {
                "key": "@System.Return.Code",
                "icon": 12,
                "documentation": "Status codes returned by system processes. Same as @SYSTEM.SET.",
                "detail": "@SYSTEM.RETURN.CODE"
            },
            {
                "key": "@System.Set ",
                "icon": 12,
                "documentation": "Status codes returned by system processes. Same as @SYSTEM.RETURN.CODE.",
                "detail": "@SYSTEM.SET"
            },
            {
                "key": "@Term.Type ",
                "icon": 12,
                "documentation": "Terminal type. Non-stacked.",
                "detail": "@TERM.TYPE variable"
            },
            {
                "key": "@Time ",
                "icon": 12,
                "documentation": "Internal time when the program was invoked.",
                "detail": ""
            },
            {
                "key": "@Tm ",
                "icon": 21,
                "documentation": "Inserts a text mark CHAR(251)",
                "detail": "@TM"
            },
            {
                "key": "@Transaction ",
                "icon": 12,
                "documentation": "A numeric value. Any nonzero value indicates that a transaction is active; the value 0 indicates that no transaction exists.",
                "detail": "@TRANSACTION"
            },
            {
                "key": "@Transaction.ID ",
                "icon": 12,
                "documentation": "Transaction number of the active transaction. An empty string indicates that no transaction exists.",
                "detail": "@TRANSACTION.ID"
            },
            {
                "key": "@Transaction.Level",
                "icon": 12,
                "documentation": "Transaction nesting level of the active transaction. A 0 indicates that no transaction exists.",
                "detail": "@TRANSACTION.LEVEL"
            },
            {
                "key": "@True ",
                "icon": 21,
                "documentation": "Compiler replaces the value with 1.",
                "detail": ""
            },
            {
                "key": "@Tty ",
                "icon": 21,
                "documentation": "Terminal device name. If the process is a phantom, @TTY returns the value 'phantom'. If the process is a UniVerse API, it returns 'uvcs'. Note: In PI\/Open flavor, @TTY returns an empty string for PHANTOM processes.",
                "detail": "@TTY"
            },
            {
                "key": "@User.No ",
                "icon": 21,
                "documentation": "User number. Non-stacked. Same as @USERNO.",
                "detail": "@USER.NO"
            },
            {
                "key": "@User.Return.Code",
                "icon": 12,
                "documentation": "Status codes created by the user.",
                "detail": ""
            },
            {
                "key": "@User0",
                "icon": 12,
                "documentation": "User-defined.",
                "detail": "@USER0 variable"
            },
            {
                "key": "@User1 ",
                "icon": 12,
                "documentation": "User-defined.",
                "detail": "@USER1 variable"
            },
            {
                "key": "@User2",
                "icon": 12,
                "documentation": "User-defined.",
                "detail": "@USER2 variable"
            },
            {
                "key": "@User3 ",
                "icon": 12,
                "documentation": "User-defined.",
                "detail": "@USER3 variable"
            },
            {
                "key": "@User4 ",
                "icon": 12,
                "documentation": "User-defined.",
                "detail": "@USER4 variable"
            },
            {
                "key": "@Userno ",
                "icon": 12,
                "documentation": "User number. Non-stacked. Same as @USER.NO.",
                "detail": "@USERNO"
            },
            {
                "key": "@Vm ",
                "icon": 21,
                "documentation": "Inserts a value mark CHAR(253)",
                "detail": "@VM"
            },
            {
                "key": "@Who ",
                "icon": 21,
                "documentation": "Name of the current UniVerse account directory. Non stacked.",
                "detail": "@WHO"
            },
            {
                "key": "@Year ",
                "icon": 21,
                "documentation": "Current year (2 digits).",
                "detail": "@YEAR variable"
            },
            {
                "key": "@Year4 ",
                "icon": 21,
                "documentation": "Current year (4 digits).",
                "detail": "@YEAR4 variable"
            },
            {
                "key": "Abort",
                "icon": 14,
                "documentation": "Terminates all programs and returns to the UniVerse command level.",
                "detail": "ABORT [expression]",
                "snippet": "ABORT ${1:expression}"
            },
            {
                "key": "Aborte",
                "icon": 14,
                "documentation": "Terminates all programs and returns to the UniVerse command level. Behaves as if $OPTIONS STOP.MSG were in force.",
                "detail": "ABORTE [expression]",
                "snippet": "ABORTE ${1:expression}"
            },
            {
                "key": "Abortm",
                "icon": 14,
                "documentation": "Terminates all programs and returns to the UniVerse command level. Behaves as if $OPTIONS-STOP.MSG were in force.",
                "detail": "ABORTM [expression ]",
                "snippet": "ABORTM ${1:expression}"
            },
            {
                "key": "Abs",
                "icon": 3,
                "documentation": "The ABS function will return the mathematical absolute of the ()expression.",
                "detail": "ABS( expression )",
                "snippet": "ABS(${1:math_expression})"
            },
            {
                "key": "Abss",
                "icon": 3,
                "documentation": "Creates a dynamic array containing the absolute values of a dynamic array.",
                "detail": "ABSS( dynamicarray )",
                "snippet": "ABSS(${1:DynArr})"
            },
            {
                "key": "acceptConnection",
                "icon": 3,
                "documentation": "Accepts an incoming connection attempt on the server side socket.",
                "detail": "acceptConnection(svr_socket, blocking_mode, timeout, in_addr, in_name,\nacceptConnection(svr_socket, blocking_mode, timeout, in_addr, in_name,socket_handle)",
                "snippet": "acceptConnection(${1:svr_socket}, ${2:blocking_mode}, ${3:timeout}, ${4:in_addr}, ${5:in_name}, ${6:socket_handle})"
            },
            {
                "key": "Acos",
                "icon": 3,
                "documentation": "Calculates the trigonometric arc-cosine of an expression.",
                "detail": "ACOS( expression ) ",
                "snippet": "ACOS(${1:expr})"
            },
            {
                "key": "Activatekey",
                "icon": 14,
                "documentation": "Activates a key. ",
                "detail": "ACTIVATEKEY ,  [ON ]",
                "snippet": "ACTIVATEKEY ${1:keyid}, ${2:password} ON ${3:host}"
            },
            {
                "key": "addAuthenticationRule",
                "icon": 3,
                "documentation": "Adds an authentication rule to a security context. UniVerse uses the authentication rules during SSL negotiation to determine whether or not the peer is to be trusted.",
                "detail": "addAuthenticationRule(context, ServerOrClient, Rule, RuleString)",
                "snippet": "addAuthenticationRule(context, ServerOrClient, Rule, RuleString)"
            },
            {
                "key": "addCertificate",
                "icon": 3,
                "documentation": "Loads a certificate (or multiple certificates) into a security context to be used as a UniVerse server or client certificate. Alternatively, it can specify a directory which contains the certificates that are either used as CA (Certificate Authority) certificates to authenticate incoming certificates, or act as a Revocation list to check against expired or revoked certificates.",
                "detail": "addCertificate(certPath, usedAs, format, algorithm, context, p12pass)",
                "snippet": "addCertificate(${1:certPath}, ${2:usedAs}, ${3:format}, ${4:algorithm}, ${5:context}, ${6:p12pass})"
            },
            {
                "key": "addRequestParameter",
                "icon": 3,
                "documentation": "Adds a parameter to the request.",
                "detail": "addRequestParameter(request_handle, parameter_name, parameter_value,content_handling)",
                "snippet": "addRequestParameter(${1:request_handle}, ${2:parameter_name}, ${3:parameter_value}, ${4:content_handling})"
            },
            {
                "key": "Adds",
                "icon": 3,
                "documentation": "Adds elements of two dynamic arrays.",
                "detail": "ADDS( array1, array2 ) ",
                "snippet": "ADDS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Alpha",
                "icon": 3,
                "documentation": "Determines whether the expression is an alphabetic or nonalphabetic string.",
                "detail": "ALPHA( expression )",
                "snippet": "ALPHA(${1:value})"
            },
            {
                "key": "amInitialize",
                "icon": 3,
                "documentation": "Creates and opens an AMI session.",
                "detail": "amInitialize(hSession, appName, policyName, reasonCode)",
                "snippet": "amInitialize(${1:hSession}, ${2:appName}, ${3:policyName}, ${4:reasonCode})"
            },
            {
                "key": "amReceiveMsg",
                "icon": 3,
                "documentation": "Receives a message sent by the amSendMsg function.",
                "detail": "amReceiveMsg(hSession, receiverName, policyName, selMsgName, maxMsgLen, dataLen, data, rcvMsgName, reasonCode[,recMsgOption])",
                "snippet": "amReceiveMsg(${1:hSession}, ${2:receiverName}, ${3:policyName}, ${4:selMsgName}, ${5:maxMsgLen}, ${6:dataLen}, ${7:data}, ${8:rcvMsgName}, ${9:reasonCode}, ${10:recMsgOption})"
            },
            {
                "key": "amReceiveRequest",
                "icon": 3,
                "documentation": "Receives a request message.",
                "detail": "amReceiveRequest(hSession, receiverName, policyName, maxMsgLen, dataLen, data, rcvMsgName, senderName, reasonCode [,recReqOption])",
                "snippet": "amReceiveRequest(${1:hSession}, ${2:receiverName}, ${3:policyName}, ${4:maxMsgLen}, ${5:dataLen}, ${6:data}, ${7:rcvMsgName}, ${8:senderName}, ${9:reasonCode})"
            },
            {
                "key": "amSendMsg",
                "icon": 3,
                "documentation": "Sends a datagram (send and forget) message",
                "detail": "amSendMsg(hSession, senderName, policyName, data, sndMsgName, reasonCode)",
                "snippet": "amSendMsg(${1:hSession}, ${2:senderName}, ${3:policyName}, ${4:data}, ${5:sndMsgName}, ${6:reasonCode})"
            },
            {
                "key": "amSendRequest",
                "icon": 3,
                "documentation": "Sends a request message.",
                "detail": "amSendRequest(hSession, senderName, policyName, responseName, data, sndMsgName, reasonCode)",
                "snippet": "amSendRequest(${1:hSession}, ${2:senderName}, ${3:policyName}, ${4:responseName}, ${5:data}, ${6:sndMsgName}, ${7:reasonCode})"
            },
            {
                "key": "amSendResponse",
                "icon": 3,
                "documentation": "Sends a request message.",
                "detail": "amSendResponse(hSession, senderName, policyName, rcvMsgName, data sndMsgName, reasonCode)",
                "snippet": "amSendResponse(${1:hSession}, ${2:senderName}, ${3:policyName}, ${4:rcvMsgName}, ${5:data}, ${6:sndMsgName}, ${7:reasonCode})"
            },
            {
                "key": "amTerminate",
                "icon": 3,
                "documentation": "Closes a session.",
                "detail": "amTerminate(hSession, policyName, reasonCode)",
                "snippet": "amTerminate(${1:hSession}, ${2:policyName}, ${3:reasonCode})"
            },
            {
                "key": "analyzeCertificate",
                "icon": 3,
                "documentation": "Decodes a certificate and inputs plain text into the result parameter. The result parameter then contains such information as the subject name, location, institute, issuer, public key, other extensions and the issuers signature.",
                "detail": "analyzeCertificate(cert, format, result, p12pass)",
                "snippet": "analyzeCertificate(${1:cert}, ${2:format}, ${3:result}, ${4:p12pass})"
            },
            {
                "key": "Ands",
                "icon": 3,
                "documentation": "Performs a logical AND on elements of two dynamic arrays.",
                "detail": "ANDS( array1, array2 )",
                "snippet": "ANDS(${1:array1}, ${2:array2})"
            },
            {
                "key": "ASCII",
                "icon": 3,
                "documentation": "Converts EBCDIC representation of character string data to the equivalent ASCII character code values.",
                "detail": "ASCII( expression )",
                "snippet": "ASCII(${1:expression})"
            },
            {
                "key": "Asin",
                "icon": 3,
                "documentation": "Calculates the trigonometric arc-sine of an expression.",
                "detail": "ASIN( expression )",
                "snippet": "ASIN(${1:expr})"
            },
            {
                "key": "Assigned",
                "icon": 3,
                "documentation": "Determines if a variable is assigned a value.",
                "detail": "ASSIGNED( variable ) ",
                "snippet": "ASSIGNED(${1:variable})"
            },
            {
                "key": "Atan",
                "icon": 3,
                "documentation": "Calculates the trigonometric arctangent of an expression.",
                "detail": "ATAN( expression )",
                "snippet": "ATAN(${1:expr})"
            },
            {
                "key": "AuditLog",
                "icon": 3,
                "documentation": "Create application driven audit logs.",
                "detail": "AuditLog(Originator, Action, File, Record, Info, Status, [OldData], [NewData])",
                "snippet": "AuditLog(${1:Originator}, ${2:Action}, ${3:File}, ${4:Record}, ${5:Info}, ${6:Status}, ${7:OldData}, ${8:NewData})"
            },
            {
                "key": "Authorization",
                "icon": 14,
                "documentation": "Specifies the effective run-time UID (user identification) number of the program.",
                "detail": "AUTHORIZATION \"$username\"",
                "snippet": "AUTHORIZATION \"${1:username}\""
            },
            {
                "key": "Auxmap",
                "icon": 14,
                "documentation": "Assigns the map for the auxiliary printer to print unit 0 (for example, the terminal).",
                "detail": "AUXMAP { ON|OFF|expression }",
                "snippet": "AUXMAP ${1:expr}"
            },
            {
                "key": "Begin Case",
                "icon": 14,
                "documentation": "The CASE structure is bounded by the BEGIN CASE and END CASE statements.",
                "detail": "BEGIN CASE\n...\nEND CASE",
                "snippet": "BEGIN CASE\\n\tCASE $1\\n\t\t$2\\nEND CASE"
            },
            {
                "key": "Begin transaction",
                "icon": 14,
                "documentation": "Indicates the beginning of a set of statements that make up a single transaction.",
                "detail": "BEGIN TRANSACTION [ISOLATION LEVEL level]\n[statements]",
                "snippet": "BEGIN TRANSACTION \n${1:statements}\nEND TRANSACTION"
            },
            {
                "key": "Bitand",
                "icon": 3,
                "documentation": "Performs a bitwise AND of two integers.",
                "detail": "BITAND( expression1, expression2 )",
                "snippet": "BITAND(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Bitnot",
                "icon": 3,
                "documentation": "Performs a bitwise NOT of two integers.",
                "detail": "BITNOT( expression [, bit#] )",
                "snippet": "BITNOT(${1:expression}, ${2:bitnum})"
            },
            {
                "key": "Bitor",
                "icon": 3,
                "documentation": "Performs a bitwise OR of two integers.",
                "detail": "BITOR( expression1, expression2 ) ",
                "snippet": "BITOR(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Bitreset",
                "icon": 3,
                "documentation": "Resets one bit of an integer.",
                "detail": "BITRESET( expression, bit# )",
                "snippet": "BITRESET(${1:expression}, ${2:bit})"
            },
            {
                "key": "Bitset",
                "icon": 3,
                "documentation": "Sets one bit of an integer.",
                "detail": "BITSET( expression, bit# )",
                "snippet": "BITSET(${1:expr}, ${2:bit})"
            },
            {
                "key": "Bittest",
                "icon": 3,
                "documentation": "Tests one bit of an integer.",
                "detail": "BITTEST( expression, bit# )",
                "snippet": "BITTEST(${1:expression}, ${2:bit})"
            },
            {
                "key": "Bitxor",
                "icon": 3,
                "documentation": "Performs a bitwise XOR of two integers.",
                "detail": "BITXOR( expression1, expression2 ) ",
                "snippet": "BITXOR(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Break",
                "icon": 14,
                "documentation": "Enables or disables the Break key on the keyboard.",
                "detail": "BREAK [KEY] { ON|OFF|expression }",
                "snippet": "BREAK $1"
            },
            {
                "key": "Bscan",
                "icon": 14,
                "documentation": "Scans the leaf-nodes of a B-tree file (type 25) or a secondary index.",
                "detail": "BSCAN ID.variable [, rec.variable] [FROM file.variable [, record]] [USING indexname] [RESET] [BY seq] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "BSCAN ${1:idVar}, ${2:recVar}, FROM ${3:filevar}, ${4:record} USING ${5:indexname} RESET BY ${6:seq} THEN\n\t${7:then_statements}\nEND ELSE\n\t${8:else_statements}\nEND"
            },
            {
                "key": "Byte",
                "icon": 3,
                "documentation": "Generates a string made up of a single byte.",
                "detail": "BYTE( expression )",
                "snippet": "BYTE(${1:expr})"
            },
            {
                "key": "Bytelen",
                "icon": 3,
                "documentation": "Generates the number of bytes contained in the string value in an expression.",
                "detail": "BYTELEN( expression ) ",
                "snippet": "BYTELEN(${1:expression})"
            },
            {
                "key": "Bytetype",
                "icon": 3,
                "documentation": "Determines the function of a byte in a character.",
                "detail": "BYTETYPE( value )",
                "snippet": "BYTETYPE(${1:val})"
            },
            {
                "key": "Byteval",
                "icon": 3,
                "documentation": "Retrieves the value of a byte in a string value in an expression.",
                "detail": "BYTEVAL( expression ) ",
                "snippet": "BYTEVAL(${1:expr}, ${2:n})"
            },
            {
                "key": "Call",
                "icon": 3,
                "documentation": "The CALL statement transfers program execution to an external subroutine.",
                "detail": "CALL NAME [ ) [MAT] argument [, [MAT] argument ...] ) ]\nCALL [@]subroutine.name [(argument [, argument ... ])]",
                "snippet": "CALL ${1:subroutine_name}(${2:arguments})"
            },
            {
                "key": "Case",
                "icon": 3,
                "documentation": "The CASE statement allows the programmer to execute a particular sequence of instructions based upon the results of a series of test expressions.",
                "detail": "BEGIN CASE\nCASE expression\nstatement(s)\nCASE expression\nstatement(s)\n.....\nEND CASE",
                "snippet": "BEGIN CASE\n\tCASE ${1:expression}\n\t\t${2:statement}\nEND CASE"
            },
            {
                "key": "Cats",
                "icon": 3,
                "documentation": "Concatenates elements of two dynamic arrays.",
                "detail": "CATS( array1, array2 )",
                "snippet": "CATS(${1:arr1}, ${2:arr2})"
            },
            {
                "key": "Century.Pivot",
                "icon": 3,
                "documentation": "Use the CENTURY.PIVOT function to override the system-wide century pivot year defined in the uvconfig file.",
                "detail": "CENTURY.PIVOT( year|nn )",
                "snippet": "CENTURY.PIVOT(${1:n})"
            },
            {
                "key": "Chain",
                "icon": 14,
                "documentation": "Terminates a BASIC program and executes a UniVerse command.",
                "detail": "CHAIN command",
                "snippet": "CHAIN ${1:expression}"
            },
            {
                "key": "Change",
                "icon": 3,
                "documentation": "The CHANGE function operates on a variable and replaces all occurrences of one string with another.",
                "detail": "CHANGE (expression, substring, replacement [,occurrence [,begin]] )",
                "snippet": "CHANGE(${1:string}, ${2:old}, ${3:new}, ${4:occurrence}, ${5:start})"
            },
            {
                "key": "Char",
                "icon": 3,
                "documentation": "The CHAR function returns the  ASCII character specified by the expression.",
                "detail": "CHAR( expression )",
                "snippet": "CHAR(${1:expression})"
            },
            {
                "key": "Chars",
                "icon": 3,
                "documentation": "Converts numeric elements of a dynamic array to their ASCII character string equivalents.",
                "detail": "CHARS( dynamic.array )",
                "snippet": "CHARS(${1:DynArr})"
            },
            {
                "key": "Checksum",
                "icon": 3,
                "documentation": "Returns a cyclical redundancy code (a checksum value).",
                "detail": "CHECKSUM( string ) ",
                "snippet": "CHECKSUM(${1:str})"
            },
            {
                "key": "Clear",
                "icon": 14,
                "documentation": "Assigns a value of 0 to specified variables.",
                "detail": "CLEAR [ COMMON ]",
                "snippet": "CLEAR"
            },
            {
                "key": "Clearcommon",
                "icon": 14,
                "documentation": "Set all variables in a named common area to zero.",
                "detail": "CLEARCOMMON [\/common.labe\/]",
                "snippet": "CLEARCOMMON $1"
            },
            {
                "key": "Cleardata",
                "icon": 14,
                "documentation": "Clears all data previously stored by the DATA statement.",
                "detail": "CLEARDATA",
                "snippet": "CLEARDATA"
            },
            {
                "key": "Clearfile",
                "icon": 14,
                "documentation": "Erases all records from a file.",
                "detail": "CLEARFILE [file.variable] [ON ERROR statements] [LOCKED statements]",
                "snippet": "CLEARFILE ${1:variable} ON ERROR ${2:err_statements} LOCKED ${3:lock_statements}"
            },
            {
                "key": "Clearprompts",
                "icon": 14,
                "documentation": "Clears the value of the in-line prompt.",
                "detail": "CLEARPROMPTS",
                "snippet": "CLEARPROMPTS"
            },
            {
                "key": "Clearselect",
                "icon": 14,
                "documentation": "Sets a select list to empty.",
                "detail": "CLEARSELECT [ALL | list.number]",
                "snippet": "CLEARSELECT ${1:listNum}"
            },
            {
                "key": "Close",
                "icon": 14,
                "documentation": "Writes data written to the file physically on the disk and releases any file or update locks.",
                "detail": "CLOSE [file.variable] [ON ERROR statements]",
                "snippet": "CLOSE ${1:variable} ON ERROR ${2:err}"
            },
            {
                "key": "Closeseq",
                "icon": 14,
                "documentation": "Writes an end-of-file mark at the current location in the record and then makes the record available to other users.",
                "detail": "CLOSESEQ file.variable [ON ERROR statements]",
                "snippet": "CLOSESEQ ${1:filevar} ON ERROR ${2:err}"
            },
            {
                "key": "closeSocket",
                "icon": 3,
                "documentation": "Closes a socket connection.",
                "detail": "closeSocket(socket_handle)",
                "snippet": "closeSocket(${1:socket_handle})"
            },
            {
                "key": "CloseXMLData",
                "icon": 3,
                "documentation": "After you finish using an XML document, use CloseXMLData to close the dynamic array variable.",
                "detail": "Status=CloseXMLData(xml_data_handle)",
                "snippet": "CloseXMLData(${1:xml_data_handle})"
            },
            {
                "key": "Col1",
                "icon": 3,
                "documentation": "Returns the column position immediately preceding the selected substring after a BASIC FIELD function is executed.",
                "detail": "COL1()",
                "snippet": "COL1()"
            },
            {
                "key": "Col2",
                "icon": 3,
                "documentation": "Returns the column position immediately following the selected substring after a BASIC FIELD function is executed.",
                "detail": "COL2()",
                "snippet": "COL2()"
            },
            {
                "key": "Command.Editor",
                "icon": 14,
                "documentation": "Enables or disables the command editor in PI\/Open.",
                "detail": "COMMAND.EDITOR [{ON | OFF} [INSERT | OVERLAY] [VERBS | ALL] 'prompt'}]\nCOMMAND.EDITOR [OFF]",
                "snippet": "COMMAND.EDITOR ${1:expr}"
            },
            {
                "key": "Commit",
                "icon": 14,
                "documentation": "Commits all changes made during a transaction, writing them to disk.",
                "detail": "COMMIT [WORK] [THEN statements] [ELSE statements ]",
                "snippet": "COMMIT ${1:WORK} THEN $2 ELSE $3"
            },
            {
                "key": "Common",
                "icon": 14,
                "documentation": "The COMMON statement declares a list of variables and matrices that can be shared among various programs. There can be many common areas including a default, unnamed common area.",
                "detail": "COMMON [\/CommonName\/] variable[, variable ... ]",
                "snippet": "COMMON $1"
            },
            {
                "key": "Compare",
                "icon": 3,
                "documentation": "Compares two strings for sorting.",
                "detail": "COMPARE (string1, string2 [, justification])",
                "snippet": "COMPARE(${1:str1}, ${2:str2}, ${3:justification})"
            },
            {
                "key": "Continue",
                "icon": 14,
                "documentation": "The CONTINUE statement is the complimentary statement to the BREAK statement without arguments. The statement is used within a loop to skip the remaining code in the current iteration and proceed directly to the next iteration.",
                "detail": "CONTINUE",
                "snippet": "CONTINUE"
            },
            {
                "key": "Convert",
                "icon": 14,
                "documentation": "The CONVERT statement converts one or more characters (searchString) in a string to their corresponding replacementString characters.",
                "detail": "CONVERT searchString TO replacementString IN string",
                "snippet": "CONVERT ${1:searchString} TO ${2:replacementString} IN ${3:string}"
            },
            {
                "key": "Convert",
                "icon": 3,
                "documentation": "Replaces every occurrence of specified characters in a variable with other specified characters.",
                "detail": "CONVERT (searchString, replacementString, string )",
                "snippet": "CONVERT(${1:searchString}, ${2:replacementString}, ${3:subject})"
            },
            {
                "key": "COS",
                "icon": 3,
                "documentation": "Calculates the trigonometric cosine of an angle.",
                "detail": "COS( expression )",
                "snippet": "COS(${1:expr})"
            },
            {
                "key": "COSH",
                "icon": 3,
                "documentation": "Calculates the hyperbolic cosine of an expression.",
                "detail": "COSH( expression )",
                "snippet": "COSH(${1:expression})"
            },
            {
                "key": "Count",
                "icon": 3,
                "documentation": "Evaluates the number of times a substring is repeated in a string.",
                "detail": "COUNT ( string, substring )",
                "snippet": "COUNT(${1:expression}, ${2:delimiter})"
            },
            {
                "key": "Counts",
                "icon": 3,
                "documentation": "Evaluates the number of times a substring is repeated in each element of a dynamic array.",
                "detail": "COUNTS (dynamic.array, substring)",
                "snippet": "COUNTS(${1:dynamic_array}, ${2:substring})"
            },
            {
                "key": "Create",
                "icon": 14,
                "documentation": "Creates a record in a UniVerse type 1 or type 19 file or establishes a path.",
                "detail": "CREATE file.variable {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "CREATE ${1:filevar} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "createCertification",
                "icon": 3,
                "documentation": "Generates a certificate. The certificate can either be a self signed certificate as a root CA that can then be used later to sign other certificates, or it can be a CA signed certificate. The generated certificate conforms to X509V3 standard.",
                "detail": "createCertificate(action, req, signKey, keyPass, CAcert, days, extensions, certOut, signAlg)",
                "snippet": "createCertificate(${1:action}, ${2:req}, ${3:signKey}, ${4:keyPass}, ${5:CAcert}, ${6:days}, ${7:extensions}, ${8:certOut}, ${9:signAlg})"
            },
            {
                "key": "createCertRequest",
                "icon": 3,
                "documentation": "Generates a PKCS #10 certificate request from a private key in PKCS #8 form and a set of user specified data. The request can be sent to a CA or used as a parameter to the createCertificate() function to obtain an X.509 public key certificate.",
                "detail": "createCertRequest(key, inFormat, keyLoc, algorithm, digest, passPhrase,subjectData, outFile, outFormat)",
                "snippet": "createCertificate(${1:action}, ${2:req}, ${3:signKey}, ${4:keyPass}, ${5:CAcert}, ${6:days}, ${7:extensions}, ${8:certOut}, ${9:signAlg})"
            },
            {
                "key": "createRequest",
                "icon": 3,
                "documentation": "Creates an HTTP request and returns a handle to the request.",
                "detail": "createRequest(URL, http_method, request_handle)",
                "snippet": "createRequest(${1:URL}, ${2:http_method}, ${3:request_handle})"
            },
            {
                "key": "createSecureRequest",
                "icon": 3,
                "documentation": "Behaves exactly the same as the createRequest() function, except for the fourth parameter, a handle to a security context, which is used to associate the security context with the request.",
                "detail": "createSecureRequest(URL, http_method, request_handle, security_context)",
                "snippet": "createSecureRequest(${1:URL}, ${2:http_method}, ${3:request_handle}, ${4:security_context})"
            },
            {
                "key": "createSecurityContext",
                "icon": 3,
                "documentation": "Creates a security context and returns a handle to the context.",
                "detail": "createSecurityContext(context, protocol version:[rule],...)",
                "snippet": "createSecurityContext(${1:context}, ${2:protocolVersion})"
            },
            {
                "key": "Crt",
                "icon": 14,
                "documentation": "The CRT statement sends data directly to the terminal, even if a PRINTER ON statement is currently active. If the optional ':' is appended, no carriage return is appended to the text",
                "detail": "CRT | DISPLAY expression [, expression..] [:]",
                "snippet": "CRT ${1:expression}"
            },
            {
                "key": "Crt @",
                "icon": 14,
                "documentation": "The CRT statement sends data directly to the terminal, even if a PRINTER ON statement is currently active. If the optional ':' is appended, no carriage return is appended to the text",
                "detail": "CRT | DISPLAY expression [, expression..] [:]",
                "snippet": "CRT @(${1:col}, ${2:row}):${3:expression}"
            },
            {
                "key": "Data",
                "icon": 14,
                "documentation": "Stores values to be used in subsequent requests for data input.",
                "detail": "DATA expression [,expression ]",
                "snippet": "DATA ${1:expression}"
            },
            {
                "key": "Date",
                "icon": 3,
                "documentation": "The DATE( ) function returns the date in internal system form. This date is expressed as the number of days since (or before) December 31, 1967.",
                "detail": "DATE()",
                "snippet": "DATE()"
            },
            {
                "key": "DBtoXML",
                "icon": 3,
                "documentation": "Create an XML document from UniVerse data using UniVerse BASIC.",
                "detail": "DBTOXML(xml_document, doc_location, u2xmap_file, u2xmap_location,condition, status)",
                "snippet": "DBTOXML(${1:xml_document}, ${2:doc_location}, ${3:u2xmap_file}, ${4:u2xmap_location}, ${5:condition}, ${6:status})"
            },
            {
                "key": "Dcount",
                "icon": 3,
                "documentation": "The DCOUNT() function counts the number of field elements in a string that are separated by a specified delimiter.",
                "detail": "DCOUNT( string, delimiter )",
                "snippet": "DCOUNT(${1:expression}, ${2:delimiter})"
            },
            {
                "key": "Deactivatekey",
                "icon": 14,
                "documentation": "Deactivate one or mor encryption keys.",
                "detail": "DEACTIVATEKEY ,  [ON ]",
                "snippet": "DEACTIVATEKEY ${1:keyid}, ${2:password} ON ${3:hostname}"
            },
            {
                "key": "Debug",
                "icon": 14,
                "documentation": "The DEBUG statement causes the executing program to enter the UniVerse debugger.",
                "detail": "DEBUG",
                "snippet": "DEBUG"
            },
            {
                "key": "Deffun",
                "icon": 3,
                "documentation": "Defines a user-written function.",
                "detail": "DEFFUN function [([MAT] argument [, [MAT] argument ] )] [CALLING call.ID] ",
                "snippet": "DEFFUN ${1:FuncName}(${2:args})"
            },
            {
                "key": "Del",
                "icon": 14,
                "documentation": "Deletes the specified field, value, or subvalue from a dynamic array.",
                "detail": "DEL dynamic.array < field# [,value# [,subvalue#]] >",
                "snippet": "DEL ${1:dynarr}"
            },
            {
                "key": "Delete",
                "icon": 3,
                "documentation": "The DEL or DELETE statement is used to remove a specified element from a dynamic array.",
                "detail": "DEL variable\nDELETE(variable,expression1[, expression2[, expression3])",
                "snippet": "DELETE ${1:filevar},${2:recordkey} ON ERROR ${3:err} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Delete",
                "icon": 14,
                "documentation": "Use the DELETE function to erase the data contents of a specified field, value, or subvalue and its corresponding delimiter from a dynamic array. The DELETE function returns the contents of the dynamic array with the specified data removed without changing the actual value of the dynamic array.",
                "detail": "DELETE($dynarr, $attr, $val, $subval)",
                "snippet": "DELETE(${1:dynarr}, ${2:attr}, ${3:val}, ${4:subval})"
            },
            {
                "key": "Deletelist",
                "icon": 14,
                "documentation": "Deletes a select list saved in the &SAVEDLISTS& file.",
                "detail": "DELETELIST listname",
                "snippet": "DELETELIST ${1:expression}"
            },
            {
                "key": "Deleteu",
                "icon": 14,
                "documentation": "Deletes a record from a previously opened file without releasing the update lock.",
                "detail": "DELETEU [file.variable ,] record.ID [ON ERROR statements]\n[LOCKED statements]\n[THEN statements] [ELSE statements]",
                "snippet": "DELETEU ${1:filevar}, ${2:recID} THEN ${3:thenStatements} ELSE ${4:elseStatements}"
            },
            {
                "key": "Descrinfo",
                "icon": 3,
                "documentation": "Returns requested information (key) about a variable.",
                "detail": "DESCRINFO(key, variable)",
                "snippet": "DESCRINFO(${1:key}, ${2:var})"
            },
            {
                "key": "Digest",
                "icon": 3,
                "documentation": "Generates a message digest of supplied data. A message digest is the result of a one-way hash function (digest algorithm) performed on the message.",
                "detail": "DIGEST(algorithm, data, dataLoc, result)",
                "snippet": "DIGEST(${1:algorithm}, ${2:data}, ${3:dataLoc}, ${4:result})"
            },
            {
                "key": "Dim",
                "icon": 3,
                "documentation": "The DIM statement is used to declare arrays to the compiler before they are referenced.",
                "detail": "DIM[ENSION] variable(number[, number... ])[, variable(number [,number...]) ...]",
                "snippet": "DIM ${1:matrix}(${2:rows}, ${3:cols})"
            },
            {
                "key": "Dimension",
                "icon": 3,
                "documentation": "Declares the name, dimensionality, and size constraints of an array variable.",
                "detail": "DIM[ENSION] matrix (rows, columns) [, matrix (rows, columns) ]\nDIM[ENSION] vector (subscript) [, vector (subscript) ]",
                "snippet": "DIMENSION ${1:matrix}(${2:rows}, ${3:cols})"
            },
            {
                "key": "Disabledec",
                "icon": 14,
                "documentation": "Turn off decryption on field or fields specified.",
                "detail": "DISABLEDEC  [, ], {ALL |} [ON ERROR ]",
                "snippet": "DISABLEDEC ${1:filename} ON ERROR ${2:err}"
            },
            {
                "key": "Display",
                "icon": 14,
                "documentation": "Outputs data to the screen.",
                "detail": "DISPLAY string",
                "snippet": "DISPLAY ${1:expression}"
            },
            {
                "key": "Div",
                "icon": 3,
                "documentation": "Outputs the whole part of the real division of two real numbers.",
                "detail": "DIV( dividend, divisor )",
                "snippet": "DIV(${1:dividend}, ${2:divisor})"
            },
            {
                "key": "Divs",
                "icon": 3,
                "documentation": "Divides elements of two dynamic arrays.",
                "detail": "DIVS( dynArray1, dynArray2 )",
                "snippet": "DIVS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Downcase",
                "icon": 3,
                "documentation": "DOWNCASE converts all uppercase characters in an expression to lowercase characters.",
                "detail": "DOWNCASE( expression )",
                "snippet": "DOWNCASE(${1:expression})"
            },
            {
                "key": "Dquote",
                "icon": 3,
                "documentation": "The function will put double quotation mark at the beginning and end of a string",
                "detail": "DQUOTE(Expression)",
                "snippet": "DQUOTE(${1:expression})"
            },
            {
                "key": "Dtx",
                "icon": 3,
                "documentation": "Converts a decimal integer into its hexadecimal equivalent.",
                "detail": "DTX(number [,size] )",
                "snippet": "DTX(${1:expression})"
            },
            {
                "key": "EBCDIC",
                "icon": 3,
                "documentation": "Converts data from its ASCII representation to the equivalent code value in EBCDIC.",
                "detail": "EBCDIC( expression )",
                "snippet": "EBCDIC(${1:expression})"
            },
            {
                "key": "Echo",
                "icon": 14,
                "documentation": "Controls the display of input characters on the terminal screen.",
                "detail": "ECHO {ON | OFF | expression}",
                "snippet": "ECHO ${1:expr}"
            },
            {
                "key": "Enabledec",
                "icon": 14,
                "documentation": "Activate decryption on a file or fields specified.",
                "detail": "ENABLEDEC  [, ], { ALL |} [ON ERROR ]",
                "snippet": "ENABLEDEC ${1:filename} ON ERROR ${2:err}"
            },
            {
                "key": "Encode",
                "icon": 3,
                "documentation": "Performs data encoding on input data. UniVerse supports Base64 encoding only.",
                "detail": "ENCODE(algorithm, action, data, dataLoc, result, resultLoc)",
                "snippet": "ENCODE(${1:algorithm}, ${2:action}, ${3:data}, ${4:dataLoc}, ${5:result}, ${6:resultLoc})"
            },
            {
                "key": "Encrypt",
                "icon": 3,
                "documentation": "Performs symmetric encryption operations. You can call various block and stream symmetric ciphers through this function.",
                "detail": "ENCRYPT (algorithm, action, data, dataLoc,key, keyLoc, keyAction, salt, IV, result, resultLoc, signAlg)",
                "snippet": "ENCRYPT(${1:algorithm}, ${2:action}, ${3:data}, ${4:dataLoc}, ${5:key}, ${6:keyLoc}, ${7:keyAction}, ${8:salt}, ${9:IV}, ${10:result}, ${11:resultLoc})"
            },
            {
                "key": "End",
                "icon": 14,
                "documentation": "The END statement is used to terminate a program or to conclude a set of jBC statements bounded by a condition.",
                "detail": "END",
                "snippet": "END"
            },
            {
                "key": "End Case",
                "icon": 3,
                "documentation": "The END CASE statement terminates a CASE block. There should be a corresponding END CASE for each BEGIN CASE.",
                "detail": "END CASE",
                "snippet": "END CASE"
            },
            {
                "key": "End Else",
                "icon": 14,
                "documentation": "The END ELSE terminates the THEN portion and begin the ELSE portion of a code block",
                "detail": "END ELSE",
                "snippet": "END ELSE"
            },
            {
                "key": "End transaction",
                "icon": 14,
                "documentation": "Indicates where execution should continue after a transaction terminates.",
                "detail": "END TRANSACTION",
                "snippet": "END TRANSACTION"
            },
            {
                "key": "Enter",
                "icon": 14,
                "documentation": "Executes an external subroutine.",
                "detail": "ENTER subroutine\nENTER @variable",
                "snippet": "ENTER ${1:name}"
            },
            {
                "key": "Eof",
                "icon": 3,
                "documentation": "Checks whether the command line argument pointer is past the last command line argument.",
                "detail": "EOF( argument )",
                "snippet": "EOF(${1:argument})"
            },
            {
                "key": "Eqs",
                "icon": 3,
                "documentation": "Compares the equality of corresponding elements of two dynamic arrays.",
                "detail": "EQS( array1, array2 )",
                "snippet": "EQS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Equate",
                "icon": 3,
                "documentation": "EQUATE is used to declare a symbol equivalent to a literal, variable or simple expression.",
                "detail": "EQU[ATE] symbol TO expression [,symbol TO expression ]\nEQU[ATE] symbol LIT[ERALLY] string [,symbol LIT string ]",
                "snippet": "EQU ${1:symbol} TO ${2:expression}"
            },
            {
                "key": "Ereplace",
                "icon": 3,
                "documentation": "Substitutes an element of a string with a replacement element.",
                "detail": "EREPLACE (expression, substring, replacement [,occurrence [,begin]] )",
                "snippet": "EREPLACE(${1:expression}, ${2:substring}, ${3:replacement}, ${4:occurrence}, ${5:begin})"
            },
            {
                "key": "Errmsg",
                "icon": 14,
                "documentation": "Prints a formatted error message from the ERRMSG file.",
                "detail": "ERRMSG message.ID [,message.ID ]",
                "snippet": "ERRMSG ${1:msgid}"
            },
            {
                "key": "Exchange",
                "icon": 3,
                "documentation": "Replaces one character with another or deletes all occurrences of a specific character.",
                "detail": "EXCHANGE (string, xx, yy)",
                "snippet": "EXCHANGE(${1:str}, ${2:xx}, ${3:yy})"
            },
            {
                "key": "Execute",
                "icon": 3,
                "documentation": "The EXECUTE or PERFORM statement allows the currently executing program to pause and execute any other UNIX\/NT program, including another jBC program or a jBASE command.",
                "detail": "EXECUTE|PERFORM expression [CAPTURING variable] [RETURNING|SETTING variable]\n[PASSLIST expression] [RTNLIST [variable]]\n[PASSDATA variable] [RTNDATA variable]",
                "snippet": "EXECUTE ${1:expression}"
            },
            {
                "key": "Exit",
                "icon": 3,
                "documentation": "The EXIT statement is used to halt the execution of a program and return a numeric exit code to the parent process. For compatibility with older versions of the language the EXIT statement may be used without an expression. In this case it is synonymous with the BREAK statement.",
                "detail": "EXIT (expression)\nEXIT",
                "snippet": "EXIT"
            },
            {
                "key": "Exp",
                "icon": 3,
                "documentation": "Calculates the result of base \"e\" raised to the power designated by the value of the expression.",
                "detail": "EXP( expression )",
                "snippet": "EXP(${1:expression})"
            },
            {
                "key": "Extract",
                "icon": 3,
                "documentation": "Extracts the contents of a specified field, value, or subvalue from a dynamic array.",
                "detail": "EXTRACT (dynamic.array, field#[,value# [,subvalue#]] ) variable < field# [ ,value# [,subvalue#]] >",
                "snippet": "EXTRACT(${1:DynArr}, ${2:attr}, ${3:val}, ${4:subval})"
            },
            {
                "key": "Fadd",
                "icon": 3,
                "documentation": "Performs floating-point addition on two numeric values. This function is provided for compatibility with existing software.",
                "detail": "FADD( number1, number2 ) ",
                "snippet": "FADD(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Fdiv",
                "icon": 3,
                "documentation": "Performs floating-point division on two numeric values.",
                "detail": "FDIV( number1, number2 )",
                "snippet": "FDIV(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Ffix",
                "icon": 3,
                "documentation": "Converts a floating-point number to a string with a fixed precision. FFIX is provided for compatibility with existing software.",
                "detail": "FFIX( number )",
                "snippet": "FFIX(${1:num})"
            },
            {
                "key": "Fflt",
                "icon": 14,
                "documentation": "Rounds a number to a string with a precision of 14.",
                "detail": "",
                "snippet": "FFLT(${1:num})"
            },
            {
                "key": "Field",
                "icon": 3,
                "documentation": "The FIELD function will return a multi-character delimited field from within a string.",
                "detail": "FIELD (string, delimiter, occurrence [,num.substr] )",
                "snippet": "FIELD(${1:string}, ${2:delimiter}, ${3:occurrence}, ${4:numsubstr})"
            },
            {
                "key": "Fields",
                "icon": 3,
                "documentation": "Examines each element of a dynamic array for any occurrence of a specified delimiter and returns substrings that are marked by that delimiter.",
                "detail": "FIELDS (dynamic.array, delimiter, occurrence [ ,num.substr] )",
                "snippet": "FIELDS(${1:DynArr}, ${2:delimiter}, ${3:occurrence}, ${4:numsubstr})"
            },
            {
                "key": "Fieldstore",
                "icon": 3,
                "documentation": "Replaces, deletes, or inserts substrings in a specified character string.",
                "detail": "FIELDSTORE (string, delimiter, start, n, new.string)",
                "snippet": "FIELDSTORE(${1:string}, ${2:delimiter}, ${3:i}, ${4:n}, ${5:repstring})"
            },
            {
                "key": "FIELDWRITE",
                "icon": 3,
                "documentation": "The FIELDWRITE statement allows you to update the specified fields in an existing record and releases locks set by the same process. For those using replication, FIELDWRITE generates field-level replication logs. This statement is similar to WRITEV, but it is not a replacement for WRITEV.",
                "detail": "FIELDWRITE $expr ON $filevar,$recordkey,$attrexprlist ON ERROR $err LOCKED $lock THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "FIELDWRITE ${1:expr} ON ${2:filevar},${3:recordkey},${4:attrexprlist} ON ERROR ${5:err} LOCKED ${6:lock} THEN\n\t${7:then_statements}\nEND ELSE\n\t${8:else_statements}\nEND"
            },
            {
                "key": "FIELDWRITEU",
                "icon": 3,
                "documentation": "The FIELDWRITE statement allows you to update the specified fields in an existing record and releases locks set by the same process. For those using replication, FIELDWRITE generates field-level replication logs. This statement is similar to WRITEV, but it is not a replacement for WRITEV.",
                "detail": "FIELDWRITEU $expr ON $filevar,$recordkey,$attrexprlist ON ERROR $err LOCKED $lock THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "FIELDWRITEU ${1:expr} ON ${2:filevar},${3:recordkey},${4:attrexprlist} ON ERROR ${5:err} LOCKED ${6:lock} THEN\n\t${7:then_statements}\nEND ELSE\n\t${8:else_statements}\nEND"
            },
            {
                "key": "Fileinfo",
                "icon": 3,
                "documentation": "Returns information about the specified files configuration.",
                "detail": "FILEINFO (file.variable , key )",
                "snippet": "FILEINFO(${1:file_variable}, ${2:key})"
            },
            {
                "key": "Filelock",
                "icon": 14,
                "documentation": "Sets a file update lock on an entire file to prevent other users from updating the file until this program releases it.",
                "detail": "FILELOCK [file.variable] [, lock.type] [ON ERROR statements] [LOCKED statements]",
                "snippet": "FILELOCK ${1:file_variable}"
            },
            {
                "key": "Fileunlock",
                "icon": 14,
                "documentation": "Releases file locks set by the FILELOCK statement.",
                "detail": "FILEUNLOCK [file.variable] [ON ERROR statements]",
                "snippet": "FILEUNLOCK ${1:file_variable}"
            },
            {
                "key": "Find",
                "icon": 14,
                "documentation": "Locates a given occurrence of an element within a dynamic array.",
                "detail": "FIND element IN dynamic.array [,occurrence] SETTING fmc [,vmc [,smc]] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "FIND ${1:expression1} IN ${2:Var1} SETTING ${3:Var2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Findstr",
                "icon": 14,
                "documentation": "Locates a given occurrence of a substring.",
                "detail": "FINDSTR substring IN dynamic.array [,occurrence] SETTING fmc [,vmc [,smc]] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "FINDSTR ${1:expression1} IN ${2:Var1} SETTING ${3:Var2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Fix",
                "icon": 3,
                "documentation": "Rounds an expression to a decimal number having the accuracy specified by the PRECISION statement.",
                "detail": "FIX(number [,precision [,mode]] )",
                "snippet": "FIX(${1:num}, ${2:prec}, ${3:mode})"
            },
            {
                "key": "Flush",
                "icon": 14,
                "documentation": "Causes all buffers to be written simultaneously.",
                "detail": "FLUSH file.variable {THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "FLUSH ${1:file_variable} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Fmt",
                "icon": 3,
                "documentation": "Converts data from its internal representation to a specified format for output.",
                "detail": "FMT (expression, format)expressionformat",
                "snippet": "FMT(${1:var}, ${2:code})"
            },
            {
                "key": "Fmtdp",
                "icon": 3,
                "documentation": "Formats data for output in display positions rather than character lengths.",
                "detail": "FMTDP (expression, format [, mapname ] )",
                "snippet": "FMTDP(${1:expr}, ${2:format}, ${3:mapname})"
            },
            {
                "key": "Fmts",
                "icon": 3,
                "documentation": "Converts elements of a dynamic array from their internal representation to a specified format for output.",
                "detail": "FMTS (dynamic.array, format)",
                "snippet": "FMTS(${1:DynArr}, ${2:format})"
            },
            {
                "key": "Fmtsdp",
                "icon": 3,
                "documentation": "Formats elements of a dynamic array for output in display positions rather than character lengths.",
                "detail": "FMTSDP (dynamic.array, format [, mapname] )",
                "snippet": "FMTSDP(${1:dynarr}, ${2:format}, ${3:mapname})"
            },
            {
                "key": "Fmul",
                "icon": 3,
                "documentation": "Performs floating-point multiplication on two numeric values. This function is provided for compatibility with existing software.",
                "detail": "FMUL (number1, number2)",
                "snippet": "FMUL(${1:num1}, ${2:num2})"
            },
            {
                "key": "Fold",
                "icon": 3,
                "documentation": "Divides a string into a number of shorter sections.",
                "detail": "FOLD (string, length )",
                "snippet": "FOLD(${1:str}, ${2:width})"
            },
            {
                "key": "Folddp",
                "icon": 3,
                "documentation": "Divides a string into a number of substrings separated by field marks, in display positions rather than character lengths.",
                "detail": "FOLDDP (string, length [, mapname ] )",
                "snippet": "FOLDDP(${1:str}, ${2:len}, ${3:mapname})"
            },
            {
                "key": "Footing",
                "icon": 14,
                "documentation": "Specifies text to be printed at the bottom of each page.",
                "detail": "FOOTING [ON print.channel] footing",
                "snippet": "FOOTING ${1:expr}"
            },
            {
                "key": "For",
                "icon": 14,
                "documentation": "The FOR statement allows the programming of looping constructs within the program. The loop is controlled by a counting variable and may be terminated early by expressions tested after every iteration.",
                "detail": "FOR var = expression1 TO expression2 [STEP expression3]\n\n[WHILE | UNTIL expression4]\nNEXT [var]",
                "snippet": "FOR ${1:var} = ${2:expression1} TO ${3:limit}\n\t${4:statements}\nNEXT ${5:var}"
            },
            {
                "key": "FormList",
                "icon": 14,
                "documentation": "The FORMLIST statement creates an active select list from a dynamic array.",
                "detail": "FORMLIST [variable] [TO list.number] [ON ERROR statements]",
                "snippet": "FORMLIST ${1:dynarr} TO ${2:listno} ON ERROR ${3:err}"
            },
            {
                "key": "Fsub",
                "icon": 3,
                "documentation": "Performs floating-point subtraction on two numeric values.",
                "detail": "FSUB (number1, number2)",
                "snippet": "FSUB(${1:expr1}, ${2:expr2})"
            },
            {
                "key": "Function",
                "icon": 3,
                "documentation": "Identifies a user-written function.",
                "detail": "FUNCTION [name] [( [MAT] variable [, [MAT] variable ] )]",
                "snippet": "FUNCTION ${1:name}(${2:arguments})\n\t${3:statements}\nRETURN(${4:var})"
            },
            {
                "key": "generateKey",
                "icon": 3,
                "documentation": "Generates a public key cryptography key pair and encrypts the private key.",
                "detail": "generateKey(privKey, pubKey, format, keyLoc, algorithm, keyLength,passPhrase, paramFile)",
                "snippet": "generateKey(${1:privKey}, ${2:pubKey}, ${3:format}, ${4:keyLoc}, ${5:algorithm}, ${6:keyLength}, ${7:passPhrase}, ${8:paramFile})"
            },
            {
                "key": "Ges",
                "icon": 3,
                "documentation": "Indicates when elements of one dynamic array are greater than or equal to corresponding elements of another dynamic array.",
                "detail": "GES (array1, array2)",
                "snippet": "GES(${1:array1}, ${2:array2})"
            },
            {
                "key": "Get",
                "icon": 14,
                "documentation": "Reads a block of data from an input stream associated with a device, such as a serial line or terminal.",
                "detail": "GET[X] read.var[, length] [SETTING read.count] FROM device [UNTIL eop.char.list ] [RETURNING last.char.read ] [WAITING seconds ] [THEN statements ] [ELSE statements]",
                "snippet": "GET ${1:Var} SETTING ${2:readcnt} FROM device THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Get( Arg. )",
                "icon": 3,
                "documentation": "Retrieves a command line argument.",
                "detail": "GET(ARG.) variable",
                "snippet": "GET(ARG.) ${1:variable}"
            },
            {
                "key": "getCipherSuite",
                "icon": 3,
                "documentation": "Obtains information about supported cipher suites, their version, usage, strength and type for the specified security context.",
                "detail": "getCipherSuite(context,ciphers)",
                "snippet": "getCipherSuite(${1:context}, ${2:ciphers})"
            },
            {
                "key": "getHTTPDefault",
                "icon": 3,
                "documentation": "Returns the default values of the HTTP settings.",
                "detail": "getHTTPDefault(option, value)",
                "snippet": "getHTTPDefault(${1:option}, ${2:value})"
            },
            {
                "key": "getIpv",
                "icon": 3,
                "documentation": "Display the current IPv setting on the system or a particular network connection.",
                "detail": "getIpv ([networkexpr])",
                "snippet": "getIpv(${1:networkexpr})"
            },
            {
                "key": "Getlist",
                "icon": 14,
                "documentation": "Activates a saved select list so it can be used by a READNEXT statement.",
                "detail": "GETLIST listname [TO list.number] [SETTING variable] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "GETLIST ${1:listname} IN ${2:start}, ${3:end} TO ${4:variable1} SETTING ${5:variable2} THEN\n\t${6:then_statements}\nEND ELSE\n\t${7:else_statements}\nEND"
            },
            {
                "key": "Getlocale",
                "icon": 3,
                "documentation": "Retrieves the names of specified categories of the current locale.",
                "detail": "GETLOCALE (category)",
                "snippet": "GETLOCALE(${1:cat})"
            },
            {
                "key": "Getrem",
                "icon": 3,
                "documentation": "Returns the numeric value for the position of the REMOVE pointer associated with a dynamic array.",
                "detail": "GETREM (dynamic.array)",
                "snippet": "GETREM(${1:dynarr})"
            },
            {
                "key": "getSocketErrorMessage",
                "icon": 3,
                "documentation": "Translates an error code into a text error message.",
                "detail": "getSocketErrorMessage(errCode, errMsg)",
                "snippet": "getSocketErrorMessage(${1:errCode}, ${2:errMsg})"
            },
            {
                "key": "getSocketInformation",
                "icon": 3,
                "documentation": "Obtains information about a socket connection.",
                "detail": "getSocketInformation(socket_handle, self_ or_ peer, socket_info)",
                "snippet": "getSocketInformation(${1:socket_handle}, ${2:self_or_peer}, ${3:socket_info})"
            },
            {
                "key": "getSocketMap",
                "icon": 3,
                "documentation": "Gets the NLS map associated with the input socket handle.",
                "detail": "getSocketMap(aSocket, mapname)",
                "snippet": "getSocketMap(${1:aSocket}, ${2:mapname})"
            },
            {
                "key": "getSocketOptions",
                "icon": 3,
                "documentation": "Gets the current value for a socket option associated with a socket of any type.",
                "detail": "getSocketOptions(socket_handle, options)",
                "snippet": "getSocketOptions(${1:socket_handle}, ${2:options})"
            },
            {
                "key": "Getx",
                "icon": 14,
                "documentation": "Reads a block of data from an input stream associated with a device, and returns the characters in ASCII hexadecimal format.",
                "detail": "GETX",
                "snippet": "GETX ${1:Var} SETTING ${2:readcnt} FROM device THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Gosub",
                "icon": 3,
                "documentation": "The GOSUB statement causes execution of a local subroutine, after which execution will continue with the next line of code.",
                "detail": "GOSUB label[:]",
                "snippet": "GOSUB ${1:label}"
            },
            {
                "key": "Goto",
                "icon": 14,
                "documentation": "The GOTO statement causes program execution to jump to the code at a specified label.",
                "detail": "GOTO label[:]\nGO TO label[:]\nGO label[:]",
                "snippet": "GOTO $1"
            },
            {
                "key": "Group",
                "icon": 3,
                "documentation": "Returns a substring that is located between the stated number of occurrences of a delimiter.",
                "detail": "GROUP($subject, $delimiter, $occurence, $num_to_extract)",
                "snippet": "GROUP(${1:subject}, ${2:delimiter}, ${3:occurence}, ${4:num_to_extract})"
            },
            {
                "key": "Groupstore",
                "icon": 14,
                "documentation": "Modifies existing character strings by inserting, deleting, or replacing substrings that are separated by a delimiter character.",
                "detail": "GROUPSTORE $newstr IN $str USING $start, $n, $delim",
                "snippet": "GROUPSTORE ${1:newstr} IN ${2:str} USING ${3:start}, ${4:n}, ${5:delim}"
            },
            {
                "key": "Gts",
                "icon": 3,
                "documentation": "Indicates when elements of one dynamic array are greater than corresponding elements of another dynamic array.",
                "detail": "GTS (array1, array2)",
                "snippet": "GTS(${1:arr1}, ${2:arr2})"
            },
            {
                "key": "Heading",
                "icon": 14,
                "documentation": "Specifies text to be printed at the top of each page.",
                "detail": "HEADING [ON print.channel] heading",
                "snippet": "HEADING ${1:expression}"
            },
            {
                "key": "Headinge",
                "icon": 14,
                "documentation": "Specifies text to be printed at the top of each page with the $OPTIONS statement HEADER.EJECT selected.",
                "detail": "HEADINGE [ON print.channel] heading",
                "snippet": "HEADINGE ${1:heading}"
            },
            {
                "key": "Headingn",
                "icon": 14,
                "documentation": "Specifies text to be printed at the top of each page with the $OPTIONS statement -HEADER.EJECT selected.",
                "detail": "HEADINGN [ON print.channel] heading",
                "snippet": "HEADINGN ${1:heading}"
            },
            {
                "key": "Hmac",
                "icon": 3,
                "documentation": "Calculate a message authentication code (MAC) involving a cryptographic hash function in combination with a secret key.",
                "detail": "hmac= HMAC(hmacAlg, hmacKey, hmacData, [outFormat])",
                "snippet": "HMAC(${1:hmacAlg}, ${2:hmacKey}, ${3:hmacData}, ${4:outFormat})"
            },
            {
                "key": "Hush",
                "icon": 14,
                "documentation": "Suppresses all text normally sent to a terminal during processing.",
                "detail": "HUSH { ON | OFF | expression} [SETTING status ]",
                "snippet": "HUSH ${1:expression}"
            },
            {
                "key": "Icheck",
                "icon": 3,
                "documentation": "Verifies that specified data and primary keys satisfy the defined SQL integrity constraints for an SQL table.",
                "detail": "ICHECK (dynamic.array [, file.variable] , key [, column#] )",
                "snippet": "ICHECK(${1:dynarr}, ${2:filevar}, ${3:key}, ${4:col})"
            },
            {
                "key": "Iconv",
                "icon": 3,
                "documentation": "The ICONV function converts data in external form such as dates to their internal form.",
                "detail": "ICONV (string, conversion)",
                "snippet": "ICONV(${1:subject}, ${2:convcode})"
            },
            {
                "key": "Iconvs",
                "icon": 3,
                "documentation": "Converts elements of a dynamic array to internal storage format.",
                "detail": "ICONVS (dynamic.array, conversion)",
                "snippet": "ICONVS(${1:DynArr}, ${2:conversion})"
            },
            {
                "key": "If",
                "icon": 14,
                "documentation": "Determines program flow based on the evaluation of an expression.",
                "detail": "IF expression {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "IF $1 THEN $2 ELSE $3"
            },
            {
                "key": "Ifs",
                "icon": 3,
                "documentation": "Evaluates a dynamic array and creates another dynamic array on the basis of the truth or falsity of its elements.",
                "detail": "IFS (dynamic.array, true.array, false.array)",
                "snippet": "IFS(${1:dynamic_array}, ${2:true_array}, ${3:false_array})"
            },
            {
                "key": "Ilprompt",
                "icon": 3,
                "documentation": "Evaluates strings containing in-line prompts.",
                "detail": "ILPROMPT (in.line.prompt)",
                "snippet": "ILPROMPT(${1:inLinePrompt})"
            },
            {
                "key": "Include",
                "icon": 14,
                "documentation": "Inserts and includes the specified BASIC source code from another program into the program being compiled. Same as the #INCLUDE and $INCLUDE statements.",
                "detail": "INCLUDE [filename] program\nINCLUDE program FROM filename",
                "snippet": "INCLUDE ${1:prog}"
            },
            {
                "key": "index",
                "icon": 3,
                "documentation": "The INDEX function will return the position of a character or characters within another string.",
                "detail": "INDEX (string, substring, occurrence)",
                "snippet": "INDEX(${1:subject}, ${2:search}, ${3:occurrence})"
            },
            {
                "key": "Indexs",
                "icon": 3,
                "documentation": "Returns the starting column position of a specified occurrence of a particular substring within each element of a dynamic array.",
                "detail": "INDEXS (dynamic.array, substring, occurrence)",
                "snippet": "INDEXS(${1:subject}, ${2:search}, ${3:occurrence})"
            },
            {
                "key": "Indices",
                "icon": 3,
                "documentation": "Returns information about the secondary key indexes in a file.",
                "detail": "INDICES (file.variable [,indexname])",
                "snippet": "INDICES(${1:filevar}, ${2:indexname})"
            },
            {
                "key": "initSecureServerSocket",
                "icon": 3,
                "documentation": "Creates a secured connection-oriented stream server socket.",
                "detail": "initSecureServerSocket(name_or_IP, port, backlog, svr_socket, context)",
                "snippet": "initSecureServerSocket(${1:name_or_IP}, ${2:port}, ${3:backlog}, ${4:svr_socket}, ${5:context})"
            },
            {
                "key": "initServerSocket",
                "icon": 3,
                "documentation": "Creates a connection-oriented (stream) socket.",
                "detail": "initServerSocket(name_or_IP, port, backlog, svr_socket)",
                "snippet": "initServerSocket(${1:name_or_IP}, ${2:port}, ${3:backlog}, ${4:svr_socket})"
            },
            {
                "key": "Inmat",
                "icon": 3,
                "documentation": "Used with the MATPARSE, MATREAD, and MATREADU statements to return the number of array elements or with the OPEN statement to return the modulo of a file.",
                "detail": "INMAT ([array] )",
                "snippet": "INMAT(${1:array})"
            },
            {
                "key": "Input",
                "icon": 14,
                "documentation": "Allows data input from the keyboard during program execution.",
                "detail": "INPUT variable [,length] [:] [_]",
                "snippet": "INPUT ${1:var}"
            },
            {
                "key": "Input @",
                "icon": 3,
                "documentation": "Positions the cursor at a specified location and defines the length of the input field.",
                "detail": "INPUT @ (col, row) [, | :] variable [,length] [:] [format] [_]",
                "snippet": "INPUT @(${1:col}, ${2:row}): ${3:variable}"
            },
            {
                "key": "Inputclear",
                "icon": 14,
                "documentation": "Clears the type-ahead buffer.",
                "detail": "INPUTCLEAR",
                "snippet": "INPUTCLEAR"
            },
            {
                "key": "Inputdisp",
                "icon": 3,
                "documentation": "Positions the cursor at a specified location and defines a format for the variable to print.",
                "detail": "INPUTDISP [@(col, row) [, | :]] variable [format]",
                "snippet": "INPUTDISP @(${1:col}, ${2:row}) ${3:var}"
            },
            {
                "key": "Inputdp",
                "icon": 14,
                "documentation": "In NLS mode, use the INPUTDP statement to let the user enter data. The INPUTDP statement is similar to the INPUT, INPUTIF, and INPUTDISP statements, but it calculates display positions rather than character lengths.",
                "detail": "INPUTDP variable [, length] [:] [_] [THEN statements] [ELSE statements]",
                "snippet": "INPUTDP ${1:var} THEN ${2:then_statements} ELSE ${3:else_statements}"
            },
            {
                "key": "Inputerr",
                "icon": 14,
                "documentation": "Prints a formatted error message from the ERRMSG file on the bottom line of the terminal.",
                "detail": "INPUTERR [error.message]",
                "snippet": "INPUTERR ${1:errMsg}"
            },
            {
                "key": "Inputif",
                "icon": 3,
                "documentation": "Assigns the contents of the type-ahead buffer to a variable.",
                "detail": "INPUTIF @ (col, row) [, | :] variable [,length] [:] [format] [_] [THEN statements] [ELSE statements]",
                "snippet": "INPUTIF $1"
            },
            {
                "key": "Inputnull",
                "icon": 14,
                "documentation": "Defines a single character to be recognized as the empty string in an INPUT @ statement.",
                "detail": "INPUTNULL character",
                "snippet": "INPUTNULL ${1:char}"
            },
            {
                "key": "Inputtrap",
                "icon": 14,
                "documentation": "Branches to a program label or subroutine on a TRAP key.",
                "detail": "INPUTTRAP [trap.chars] {GOTO | GOSUB} label [ ,label ]",
                "snippet": "INPUTTRAP ${1:chars} GOSUB ${2:label1}"
            },
            {
                "key": "Ins",
                "icon": 14,
                "documentation": "Inserts a specified field, value, or subvalue into a dynamic array.",
                "detail": "INS expression BEFORE dynamic.array < field# [,value# [ ,subvalue#]] >",
                "snippet": "INS ${1:expression} BEFORE ${2:array}<${3:attr}, ${4:value}, ${5:subvalue}>"
            },
            {
                "key": "Insert",
                "icon": 3,
                "documentation": "Inserts a field, value, or subvalue into a dynamic array.",
                "detail": "INSERT (dynamic.array, field#, value#, subvalue#, expression)\nINSERT (dynamic.array, field# [ ,value# [,subvalue#]] ; expression)",
                "snippet": "INSERT(${1:DynArr}, ${2:attr}, ${3:value}, ${4:subvalue}; ${5:expression})"
            },
            {
                "key": "Int",
                "icon": 3,
                "documentation": "The INT function truncates a numeric value into its nearest integer form.",
                "detail": "INT(expression)",
                "snippet": "INT(${1:expression})"
            },
            {
                "key": "Isnull",
                "icon": 3,
                "documentation": "Indicates when a variable is the null value.",
                "detail": "ISNULL (variable)",
                "snippet": "ISNULL(${1:variable})"
            },
            {
                "key": "Isnulls",
                "icon": 3,
                "documentation": "Indicates when an element of a dynamic array is the null value.",
                "detail": "ISNULLS (dynamic.array)",
                "snippet": "ISNULLS(${1:dynarr})"
            },
            {
                "key": "Itype",
                "icon": 3,
                "documentation": "Returns the value resulting from the evaluation of an I-descriptor.",
                "detail": "ITYPE (i.type)",
                "snippet": "ITYPE(${1:item})"
            },
            {
                "key": "Keyedit",
                "icon": 3,
                "documentation": "Assigns specific editing functions to the keys on the keyboard to be used with the INPUT statement.",
                "detail": "KEYEDIT (function, key) [, (function, key)] ",
                "snippet": "KEYEDIT(${1:action}, ${2:key})"
            },
            {
                "key": "Keyexit",
                "icon": 3,
                "documentation": "Specifies exit traps for the keys assigned editing functions by the KEYEDIT statement.",
                "detail": "KEYEXIT (value, key) [, (value, key)] ",
                "snippet": "KEYEXIT(${1:action}, ${2:key})"
            },
            {
                "key": "Keyin",
                "icon": 3,
                "documentation": "Reads a single character from the input buffer and returns it.",
                "detail": "KEYIN ()",
                "snippet": "KEYIN()"
            },
            {
                "key": "Keytrap",
                "icon": 3,
                "documentation": "Specifies traps for the keys assigned specific functions by the KEYEDIT statement.",
                "detail": "KEYTRAP (value, key) [, (value, key)] ",
                "snippet": "KEYTRAP(${1:action}, ${2:key})"
            },
            {
                "key": "Left",
                "icon": 3,
                "documentation": "Specifies a substring consisting of the first n characters of a string.",
                "detail": "LEFT (string, n)",
                "snippet": "LEFT(${1:str}, ${2:length})"
            },
            {
                "key": "Len",
                "icon": 3,
                "documentation": "The LEN function returns the character length of the supplied expression.",
                "detail": "LEN( string )",
                "snippet": "LEN(${1:expression})"
            },
            {
                "key": "Lendp",
                "icon": 3,
                "documentation": "Returns the number of display positions in a string.",
                "detail": "LENDP (string [,mapname] )",
                "snippet": "LENDP(${1:expression}, ${2:mapname})"
            },
            {
                "key": "Lens",
                "icon": 3,
                "documentation": "Calculates the length of each element of a dynamic array.",
                "detail": "LENS (dynamic.array)",
                "snippet": "LENS(${1:dynamic_array})"
            },
            {
                "key": "Lensdp",
                "icon": 3,
                "documentation": "Returns a dynamic array of the number of display positions in each element of a dynamic array.",
                "detail": "LENSDP (dynamic.array [, mapname] )",
                "snippet": "LENSDP(${1:dynarr}, ${2:mapname})"
            },
            {
                "key": "Les",
                "icon": 3,
                "documentation": "Indicates when elements of one dynamic array are less than or equal to corresponding elements of another dynamic array.",
                "detail": "LES (array1, array2)",
                "snippet": "LES(${1:array1}, ${2:array2})"
            },
            {
                "key": "Let",
                "icon": 14,
                "documentation": "Assigns a value to a variable.",
                "detail": "[LET] variable = expression",
                "snippet": "LET ${1:var} = ${2:expr}"
            },
            {
                "key": "Ln",
                "icon": 3,
                "documentation": "Calculates the natural logarithm of an expression in base \"e\".",
                "detail": "LN (expression)",
                "snippet": "LN(${1:expression})"
            },
            {
                "key": "loadSecurityContext",
                "icon": 3,
                "documentation": "Loads a saved security context record into the current session.",
                "detail": "loadSecurityContext(context, name, passPhrase)",
                "snippet": "loadSecurityContext(${1:context}, ${2:name}, ${3:passPhrase})"
            },
            {
                "key": "Localeinfo",
                "icon": 3,
                "documentation": "Retrieves the settings of the current locale.",
                "detail": "LOCALEINFO (category)",
                "snippet": "LOCALEINFO(${1:category})"
            },
            {
                "key": "Locate",
                "icon": 14,
                "documentation": "Searches a dynamic array for a particular value or string, and returns the index of its position.",
                "detail": "LOCATE expression IN dynamic.array [< field# [, value#] >] [, start] [BY seq] SETTING variable {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "LOCATE ${1:expression} IN ${2:dynarr} SETTING ${3:variable} THEN ${4:thenStatements} ELSE ${5:elseStatements}"
            },
            {
                "key": "Locate",
                "icon": 14,
                "documentation": "Use the LOCATE statement to search dynamic.array for a field, value, or subvalue.",
                "detail": "LOCATE($search, $subject; $returnVar) THEN $statement",
                "snippet": "LOCATE(${1:search}, ${2:subject}; ${3:returnVar}) THEN ${4:statement}"
            },
            {
                "key": "Lock",
                "icon": 14,
                "documentation": "Sets an execution lock to protect user-defined resources or events from being used by more than one concurrently running program.",
                "detail": "LOCK expression [THEN statements] [ELSE statements]",
                "snippet": "LOCK ${1:expression} THEN ${2:then_statements} ELSE ${3:else_statements}"
            },
            {
                "key": "Loop",
                "icon": 14,
                "documentation": "The LOOP construct allows the programmer to specify loops with multiple exit conditions.",
                "detail": "LOOP statements1 WHILE|UNTIL expression DO statements2 REPEAT",
                "snippet": "LOOP ${1:statements1} ${2|WHILE,UNTIL|} ${3:expression} DO ${4:statements2} REPEAT"
            },
            {
                "key": "Lower",
                "icon": 3,
                "documentation": "The LOWER function lowers system delimiters in a string to the next lowest delimiter.",
                "detail": "LOWER(expression)",
                "snippet": "LOWER(${1:expression})"
            },
            {
                "key": "Lts",
                "icon": 3,
                "documentation": "Indicates when elements of one dynamic array are less than corresponding elements of another dynamic array.",
                "detail": "LTS (array1, array2)",
                "snippet": "LTS(${1:arr1}, ${2:arr2})"
            },
            {
                "key": "Mat",
                "icon": 14,
                "documentation": "The MAT command is used to either assign every element in a specified array to a single value or to assign the entire contents of one array to another.",
                "detail": "MAT Array = expression\nMAT Array1 = MAT Array2",
                "snippet": "MAT ${1:array} = ${2:expression}"
            },
            {
                "key": "Matbuild",
                "icon": 4,
                "documentation": "Builds a string by concatenating the elements of an array.",
                "detail": "MATBUILD dynamic.array FROM array [,start [,end]] [USING delimiter]",
                "snippet": "MATBUILD ${1:variable} FROM ${2:array}, ${3:startexpr}, ${4:endexpr} USING ${5:delim}"
            },
            {
                "key": "Match",
                "icon": 14,
                "documentation": "The MATCH or MATCHES function allows pattern matching to be applied to an expression.",
                "detail": "expression1 MATCH\/MATCHES expression2",
                "snippet": "${1:str} MATCH ${2:pattern}"
            },
            {
                "key": "Matchfield",
                "icon": 3,
                "documentation": "Returns the contents of a substring that matches a specified pattern or part of a pattern.",
                "detail": "MATCHFIELD (string, pattern, field)",
                "snippet": "MATCHFIELD(${1:string}, ${2:pattern}, ${3:element})"
            },
            {
                "key": "Matparse",
                "icon": 4,
                "documentation": "Assigns the elements of an array from the elements of a dynamic array.",
                "detail": "MATPARSE array FROM dynamic.array [,delimiter]\nMATPARSE array [,start [,end]] FROM dynamic.array [USING delimiter] [SETTING elements]",
                "snippet": "MATPARSE ${1:arr} FROM ${2:str}"
            },
            {
                "key": "Matread",
                "icon": 4,
                "documentation": "Assigns the data stored in successive fields of a record from a UniVerse file to the consecutive elements of an array.",
                "detail": "MATREAD array FROM [file.variable,] record.ID [ON ERROR statements]",
                "snippet": "MATREAD ${1:array} FROM ${2:filevar}, ${3:recordkey} THEN ${4:statement}"
            },
            {
                "key": "Matreadl",
                "icon": 4,
                "documentation": "Sets a shared read lock on a record, then assigns the data stored in successive fields of the record to the consecutive elements of an array.",
                "detail": "MATREADL array FROM [file.variable,] record.ID [ON ERROR statements] [LOCKED statements] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "MATREADL ${1:mat} FROM ${2:filevar}, ${3:recordkey} THEN ${4:then_statements} ELSE ${5:else_statements}"
            },
            {
                "key": "Matreadu",
                "icon": 4,
                "documentation": "Sets an exclusive update lock on a record, then assigns the data stored in successive fields of the record to the consecutive elements of an array",
                "detail": "MATREADU array FROM [file.variable,] record.ID [ON ERROR statements] [LOCKED statements] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "MATREADU ${1:mat} FROM ${2:filevar}, ${3:recordkey} THEN ${4:then_statements} ELSE ${5:else_statements}"
            },
            {
                "key": "Matwrite",
                "icon": 4,
                "documentation": "Assigns the data stored in consecutive elements of an array to the successive fields of a record in a UniVerse file.",
                "detail": "MATWRITE array ON | TO [file.variable,] record.ID [ON ERROR statements] [LOCKED statements] [THEN statements] [ELSE statements]",
                "snippet": "MATWRITE ${1:mat} TO ${2:filevar}, ${3:recordkey}"
            },
            {
                "key": "Matwriteu",
                "icon": 4,
                "documentation": "Assigns the data stored in consecutive elements of an array to the successive fields of a record in a UniVerse file, retaining any update locks set on the record.",
                "detail": "MATWRITEU array ON | TO [file.variable,] record.ID [ON ERROR statements] [LOCKED statements] [THEN statements] [ELSE statements]",
                "snippet": "MATWRITEU ${1:mat} TO ${2:filevar}, ${3:recordkey}"
            },
            {
                "key": "Maximum",
                "icon": 3,
                "documentation": "Returns the element with the highest numeric value in a dynamic array.",
                "detail": "MAXIMUM (dynamic.array)",
                "snippet": "MAXIMUM(${1:dynarr})"
            },
            {
                "key": "Minimum",
                "icon": 3,
                "documentation": "Returns the element with the lowest numeric value in a dynamic array.",
                "detail": "MINIMUM (dynamic.array)",
                "snippet": "MINIMUM(${1:dynarr})"
            },
            {
                "key": "Mod",
                "icon": 3,
                "documentation": "Calculates the modulo (the remainder) of two expressions.",
                "detail": "MOD (dividend, divisor)",
                "snippet": "MOD(${1:dividend}, ${2:divisor})"
            },
            {
                "key": "Mods",
                "icon": 3,
                "documentation": "Calculates the modulo (the remainder) of elements of two dynamic arrays.",
                "detail": "MODS (array1, array2)",
                "snippet": "MODS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Mqclose",
                "icon": 3,
                "documentation": "Close access to a queue or other object.",
                "detail": "status=MQCLOSE(hConn, hObj, options)",
                "snippet": "MQCLOSE(${1:hConn}, ${2:hObj}, ${3:options})"
            },
            {
                "key": "Mqconn",
                "icon": 3,
                "documentation": "Connects an application to a WebSphere MQ queue manager.",
                "detail": "status=MQCONN(qManager, hConn)",
                "snippet": "MQCONN(${1:qManager}, ${2:hConn})"
            },
            {
                "key": "Mqdisc",
                "icon": 3,
                "documentation": "Terminates connections to the queue manager.",
                "detail": "status=MQDISC(hConn)",
                "snippet": "MQDISC(${1:hConn})"
            },
            {
                "key": "Muls",
                "icon": 3,
                "documentation": "Multiplies elements of two dynamic arrays.",
                "detail": "MULS (array1, array2)",
                "snippet": "MULS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Nap",
                "icon": 14,
                "documentation": "Suspends execution of a BASIC program, pausing for a specified number of milliseconds.",
                "detail": "NAP [milliseconds]",
                "snippet": "NAP ${1:milliseconds}"
            },
            {
                "key": "Neg",
                "icon": 3,
                "documentation": "Returns the arithmetic additive inverse of the value of the argument.",
                "detail": "NEG (number)",
                "snippet": "NEG(${1:num})"
            },
            {
                "key": "Negs",
                "icon": 3,
                "documentation": "Returns the negative numeric values of elements in a dynamic array. If the value of an element is negative, the returned value is positive.",
                "detail": "NEGS (dynamic.array)",
                "snippet": "NEGS(${1:DynArr})"
            },
            {
                "key": "Nes",
                "icon": 3,
                "documentation": "Indicates when elements of one dynamic array are not equal to corresponding elements of another dynamic array.",
                "detail": "NES (array1, array2)",
                "snippet": "NES(${1:arr1}, ${2:arr2})"
            },
            {
                "key": "Next",
                "icon": 14,
                "documentation": "The NEXT statement terminates a FOR loop. Control is passed back to the FOR statement and the variable is incremented or decremented.",
                "detail": "NEXT [variable]",
                "snippet": "NEXT ${1:var}"
            },
            {
                "key": "Nobuf",
                "icon": 14,
                "documentation": "Turns off buffering for a sequential file.",
                "detail": "NOBUF file.variable {THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "NOBUF ${1:file_variable} THEN ${2:then_statements} ELSE ${3:else_statements}"
            },
            {
                "key": "Not",
                "icon": 3,
                "documentation": "The NOT function is used to invert the Boolean value of an expression. It useful for explicitly testing for a false condition.",
                "detail": "NOT( expression )",
                "snippet": "NOT(${1:expr})"
            },
            {
                "key": "Nots",
                "icon": 3,
                "documentation": "Returns the complement of the logical value of each element of a dynamic array.",
                "detail": "NOTS (dynamic.array)",
                "snippet": "NOTS(${1:DynArr})"
            },
            {
                "key": "Null",
                "icon": 14,
                "documentation": "Indicates that no operation is to be performed.",
                "detail": null,
                "snippet": "NULL"
            },
            {
                "key": "Num",
                "icon": 3,
                "documentation": "Returns true (1) if the argument is a numeric data type; otherwise, returns false (0).",
                "detail": "NUM (expression)",
                "snippet": "NUM(${1:expr})"
            },
            {
                "key": "Nums",
                "icon": 3,
                "documentation": "Returns true (1) for each element of a dynamic array that is a numeric data type; otherwise, returns false (0).",
                "detail": "NUMS (dynamic.array)",
                "snippet": "NUMS(${1:DynArr})"
            },
            {
                "key": "Oconv",
                "icon": 3,
                "documentation": "The OCONV statement is used to convert internal representations of data to their external form.",
                "detail": "OCONV (string, conversion)",
                "snippet": "OCONV(${1:subject}, ${2:conversion})"
            },
            {
                "key": "Oconvs",
                "icon": 3,
                "documentation": "Converts elements of a dynamic array from their internal representation to an external output format.",
                "detail": "OCONVS (dynamic.array, conversion)",
                "snippet": "OCONVS(${1:DynArr}, ${2:conversion})"
            },
            {
                "key": "On",
                "icon": 14,
                "documentation": "Transfers program control to a specified internal subroutine or to a specified statement, under specified conditions.",
                "detail": "ON expression GOSUB statement.label [:] [,statement.label [:] ]",
                "snippet": "ON ${1:expr} GOSUB ${2:label}"
            },
            {
                "key": "Open",
                "icon": 14,
                "documentation": "The OPEN statement is used to open a file or device to a descriptor variable. If the OPEN statement fails, it executes any statements associated with an ELSE clause. If the OPEN is successful it will execute any statements associated with a THEN clause. Note that either one or both of the THEN and ELSE clauses are required.",
                "detail": "OPEN [dict,] filename [TO file.variable] [ON ERROR statements] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "OPEN ${1:filename} TO ${2:filevar} ELSE ${3:else_statements}"
            },
            {
                "key": "Opencheck",
                "icon": 14,
                "documentation": "Opens an SQL table for use by BASIC programs, enforcing SQL integrity checking.",
                "detail": "OPENCHECK [dict,] filename [TO file.variable] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "OPENCHECK ${1:filename} TO ${2:filevar} THEN ${3:then_statements} ELSE ${4:else_statements}"
            },
            {
                "key": "Opendev",
                "icon": 14,
                "documentation": "Opens a device for input or output.",
                "detail": "OPENDEV device TO file.variable [LOCKED statements] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "OPENDEV ${1:Device} TO ${2:filevar} THEN ${3:then_statements} ELSE ${4:else_statements}"
            },
            {
                "key": "Openpath",
                "icon": 14,
                "documentation": "Opens a file to be used in a BASIC program.",
                "detail": "OPENPATH pathname [TO file.variable] [ON ERROR statements] {THEN statements [ELSE statements] | ELSE statements}\nstatement",
                "snippet": "OPENPATH ${1:pathname} TO ${2:filevar} THEN ${3:then_statements} ELSE ${4:else_statements}"
            },
            {
                "key": "openSecureSocket",
                "icon": 3,
                "documentation": "Opens a secure socket connection in a specified mode and return the status.",
                "detail": "openSecureSocket(name_or_IP, port, mode, timeout, socket_handle, context)",
                "snippet": "openSecureSocket(${1:name_or_IP}, ${2:port}, ${3:mode}, ${4:timeout}, ${5:socket_handle}, ${6:context})"
            },
            {
                "key": "OPENSEQ",
                "icon": 14,
                "documentation": "Prepares a UniVerse file for sequential use by the BASIC program.",
                "detail": "OPENSEQ filename, record.ID TO file.variable [USING dynamic.array] [ON ERROR statements] [LOCKED statements] {THEN statements [ELSE statements] | ELSE statements}\nOPENSEQ pathname TO file.variable [USING dynamic.array] [ON ERROR statements] [LOCKED statements] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "OPENSEQ ${1:filename}, ${2:recordid} TO ${3:filevar} THEN ${4:then_statements} ELSE ${5:else_statements}"
            },
            {
                "key": "openSocket",
                "icon": 3,
                "documentation": "Opens a socket connection in a specified mode and returns the status.",
                "detail": "openSocket(name_or_IP, port, mode, timeout, socket_handle)",
                "snippet": "openSocket(${1:name_or_IP}, ${2:port}, ${3:mode}, ${4:timeout}, ${5:socket_handle})"
            },
            {
                "key": "OpenXMLData",
                "icon": 3,
                "documentation": "Opens an XML document after it is prepared.",
                "detail": "Status=OpenXMLData(xml_handle,xml_data_extraction_rule, xml_data_handle)",
                "snippet": "OpenXMLData(${1:xml_handle}, ${2:xml_data_extraction_rule}, ${3:xml_data_handle})"
            },
            {
                "key": "Ors",
                "icon": 3,
                "documentation": "Performs a logical OR on elements of two dynamic arrays.",
                "detail": "ORS (array1, array2)",
                "snippet": "ORS(${1:arr1}, ${2:arr2})"
            },
            {
                "key": "Page",
                "icon": 14,
                "documentation": "Prints a footing at the bottom of the page, advances to the next page, and prints a heading at the top.",
                "detail": "PAGE [ON print.channel] [page#]",
                "snippet": "PAGE $1"
            },
            {
                "key": "Perform",
                "icon": 14,
                "documentation": "Executes a specified UniVerse sentence, paragraph, menu, or command from within the BASIC program, and then returns execution to the statement following the PERFORM statement.",
                "detail": "PERFORM command",
                "snippet": "PERFORM ${1:expression}"
            },
            {
                "key": "Precision",
                "icon": 14,
                "documentation": "Sets the maximum number of decimal places allowed in the conversion from the internal binary format of a numeric value to the string representation.",
                "detail": "PRECISION expression",
                "snippet": "PRECISION ${1:expression}"
            },
            {
                "key": "PrepareXML",
                "icon": 3,
                "documentation": "Allocates memory for the XML document, opens the document, determines the file structure of the document, and returns the file structure.",
                "detail": "Status=PrepareXML(xml_file,xml_handle)",
                "snippet": "PrepareXML(${1:xml_file}, ${2:xml_handle})"
            },
            {
                "key": "Print",
                "icon": 14,
                "documentation": "The PRINT statement sends data directly to the current output device, which will either be the terminal or the printer.",
                "detail": "PRINT [ON print.channel] [print.list]",
                "snippet": "PRINT ${1:expression}"
            },
            {
                "key": "Printer close ",
                "icon": 14,
                "documentation": "Print all output data stored in the printer buffer.",
                "detail": "PRINTER CLOSE [ON print.channel]",
                "snippet": "PRINTER CLOSE"
            },
            {
                "key": "Printer off ",
                "icon": 14,
                "documentation": "PRINTER OFF will cause all subsequent output from the PRINT statement to be redirected to the terminal device.",
                "detail": "PRINTER OFF",
                "snippet": "PRINTER OFF"
            },
            {
                "key": "Printer on ",
                "icon": 14,
                "documentation": "PRINTER ON will cause all subsequent output from the PRINT statement to be redirected to the print spooler.",
                "detail": "PRINTER ON",
                "snippet": "PRINTER ON"
            },
            {
                "key": "Printer reset ",
                "icon": 14,
                "documentation": "Resets the printing options.",
                "detail": "PRINTER RESET ",
                "snippet": "PRINTER RESET "
            },
            {
                "key": "Printerr",
                "icon": 14,
                "documentation": "Prints a formatted error message from the ERRMSG file on the bottom line of the terminal.",
                "detail": "PRINTERR [error.message]",
                "snippet": "PRINTERR ${1:errMsg}"
            },
            {
                "key": "Procread",
                "icon": 14,
                "documentation": "Assigns the contents of the primary input buffer of the proc to a variable.",
                "detail": "PROCREAD variable {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "PROCREAD ${1:variable} THEN ${2:then_statements} ELSE ${3:else_statements}"
            },
            {
                "key": "Procwrite",
                "icon": 14,
                "documentation": "Writes the specified string to the primary input buffer of the proc that called your BASIC program.",
                "detail": "PROCWRITE string",
                "snippet": "PROCWRITE ${1:str}"
            },
            {
                "key": "Program",
                "icon": 14,
                "documentation": "Performs no function other than to document the source code.",
                "detail": "PROG[RAM] [name]",
                "snippet": "PROGRAM ${1:progname}"
            },
            {
                "key": "Prompt",
                "icon": 14,
                "documentation": "Defines the prompt character for user input.",
                "detail": "PROMPT character",
                "snippet": "PROMPT ${1:char}"
            },
            {
                "key": "protocolLogging",
                "icon": 3,
                "documentation": "Starts or stops logging.",
                "detail": "protocolLogging(log_file, log_action, log_level)",
                "snippet": "protocolLogging(${1:log_file}, ${2:log_action}, ${3:log_level})"
            },
            {
                "key": "Pwr",
                "icon": 3,
                "documentation": "Calculates the value of an expression when raised to a specified power.",
                "detail": "PWR (expression, power)",
                "snippet": "PWR(${1:expr}, ${2:power})"
            },
            {
                "key": "Pycall",
                "icon": 3,
                "documentation": "Calls a Python callable object.",
                "detail": "pyresult = PyCall(PyCallableObject[,arg1, arg2, ...])",
                "snippet": "PyCall(PyObj, ${1:args})"
            },
            {
                "key": "Pycallfunction",
                "icon": 3,
                "documentation": "The PyCallFunction function calls a Python function on a Python module.",
                "detail": "pyresult = PyCallFunction(moduleName, functionName[, arg1, arg2, ...])",
                "snippet": "PyCallFunction(${1:moduleName}, ${2:funcName}, ${3:args})"
            },
            {
                "key": "PyCallMethod",
                "icon": 3,
                "documentation": "The PyCallMethod function calls a method on a Python object.",
                "detail": "pyresult = PyCallMethod(pyobject, methodName [,arg1, arg2, ...]",
                "snippet": "PyCallMethod(${1:pyObj}, ${2:methName}, ${3:args})"
            },
            {
                "key": "PyGetAttr",
                "icon": 3,
                "documentation": "The PyGetAttr function gets the value of an attribute of a Python object.",
                "detail": "pyresult = PyGetAttr(pyobject, attrName)",
                "snippet": "PyGetAttr(${1:pyobj}, ${2:attrName})"
            },
            {
                "key": "PyImport",
                "icon": 3,
                "documentation": "The PyImport function imports a Python module",
                "detail": "pyresult = PyImport(moduleName)",
                "snippet": "PyImport(${1:moduleName})"
            },
            {
                "key": "PySetAttr",
                "icon": 3,
                "documentation": "The PySetAttr function sets the value of an attribute of a Python object.",
                "detail": "pyresult = PySetAttr(pyobject, attrName, value)",
                "snippet": "PySetAttr(${1:pyobj}, ${2:attrName}, ${3:val})"
            },
            {
                "key": "Quote",
                "icon": 3,
                "documentation": "Encloses an expression in double quotation marks.",
                "detail": "QUOTE (expression)",
                "snippet": "QUOTE(${1:expression})"
            },
            {
                "key": "Raise",
                "icon": 3,
                "documentation": "The RAISE function raises system delimiters in a string to the next highest delimiter.",
                "detail": "RAISE (expression)",
                "snippet": "RAISE(${1:str})"
            },
            {
                "key": "Randomize",
                "icon": 3,
                "documentation": "Initializes the RND function to ensure that the same sequence of random numbers is generated after initialization.",
                "detail": "RANDOMIZE [(expression)]",
                "snippet": "RANDOMIZE ${1:expr}"
            },
            {
                "key": "Read",
                "icon": 14,
                "documentation": "The READ statement allows a program to read a record from a previously opened file into a variable.",
                "detail": "READ dynamic.array FROM [file.variable,] record.ID [ON ERROR statements] READ dynamic.array FROM [file.variable,] record.ID [ON ERROR statements]",
                "snippet": "READ ${1:var} FROM ${2:filevar},${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Readblk",
                "icon": 14,
                "documentation": "Reads a block of data from a UniVerse file open for sequential processing and assigns it to a variable.",
                "detail": "READBLK variable FROM file.variable, blocksize THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "READBLK ${1:var} ${2:ENCODING} FROM ${3:filevariable}, ${4:blocksize} THEN ${5:then_statements} ELSE ${6:else_statements}"
            },
            {
                "key": "Readl",
                "icon": 14,
                "documentation": "Sets a shared read lock on a record, then assigns the contents of the record to a dynamic array variable.",
                "detail": "READL dynamic.array FROM [file.variable ,] record.ID [ON ERROR statements] [LOCKED statements] { THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "READL ${1:var} FROM ${2:filevar},${3:recordkey} THEN ${4:then_statements} ELSE ${5:else_statements}"
            },
            {
                "key": "Readlist",
                "icon": 14,
                "documentation": "READLIST allows the program to retrieve a previously stored list (perhaps created with the SAVE-LIST command), into a variable",
                "detail": "READLIST dynamic.array [FROM list.number] { THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "READLIST ${1:dynarr} FROM ${2:listnum} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Readnext",
                "icon": 14,
                "documentation": "READNEXT retrieves the next element in a list variable.",
                "detail": "READNEXT dynamic.array [,value [,subvalue]] [FROM list] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "READNEXT ${1:var} FROM ${2:list}"
            },
            {
                "key": "Readseq",
                "icon": 14,
                "documentation": "Reads a line of data from a UniVerse file opened for sequential processing and assigns it to a variable.",
                "detail": "READSEQ variable FROM file.variable [ON ERROR statements] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "READSEQ ${1:var} FROM ${2:filevar} ON ERROR ${3:err_statements} THEN ${4:then_statements} ELSE ${5:else_statements}"
            },
            {
                "key": "readSocket",
                "icon": 3,
                "documentation": "Reads data in the socket buffer up to max_read_size characters.",
                "detail": "readSocket(socket_handle, socket_data, max_read_size, time_out, mode, actual_read_size)",
                "snippet": "readSocket(${1:socket_handle}, ${2:socket_data}, ${3:max_read_size}, ${4:time_out}, ${5:mode}, ${6:actual_read_size})"
            },
            {
                "key": "Readt",
                "icon": 3,
                "documentation": "Assigns the contents of the next record from a magnetic tape unit to the named variable.",
                "detail": "READT [UNIT (mtu)] variable {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "READT ${1:variable} FROM ${2:expression} THEN ${3:then_statements} ELSE ${4:else_statements}"
            },
            {
                "key": "Readu",
                "icon": 14,
                "documentation": "The READU statement allows a program to read a record from a previously opened file into a variable. It respects record locking and locks the specified record for update.",
                "detail": "READU dynamic.array FROM [file.variable ,] record.ID [ON ERROR statements] [LOCKED statements] { THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "READU ${1:var} FROM ${2:filevar},${3:recordkey} LOCKED ${4:lock_statements} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Readv",
                "icon": 14,
                "documentation": "The READV statement allows a program to read a specific field from a record in a previously opened file into a variable.",
                "detail": "READV dynamic.array FROM [file.variable ,] record.ID , field# [ON ERROR statements] { THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "READV ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Readvl",
                "icon": 14,
                "documentation": "Sets a shared read lock on a record, then assigns the contents of a field of a record to a dynamic array variable.",
                "detail": "READVL dynamic.array FROM [file.variable ,] record.ID , field# [ON ERROR statements] [LOCKED statements] { THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "READVL ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} THEN ${5:then_statements} ELSE ${6:else_statements}"
            },
            {
                "key": "Readvu",
                "icon": 14,
                "documentation": "Sets an exclusive update lock on a record, then assigns the contents of a field of the record to a dynamic array variable.",
                "detail": "READVU dynamic.array FROM [file.variable ,] record.ID , field# [ON ERROR statements] [LOCKED statements] { THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "READVU ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} LOCKED ${5:lock_statements} THEN ${6:then_statements} ELSE ${7:else_statements}"
            },
            {
                "key": "ReadXMLData",
                "icon": 3,
                "documentation": "Reads an XML document after it is opened. UniVerse BASIC returns the XML data as a dynamic array.",
                "detail": "ReadXMLData($xml_data_handle, $rec)",
                "snippet": "ReadXMLData(${1:xml_data_handle}, ${2:rec})"
            },
            {
                "key": "Real",
                "icon": 3,
                "documentation": "Converts a numeric expression into a real number without loss of accuracy.",
                "detail": "REAL (number)",
                "snippet": "REAL(${1:num})"
            },
            {
                "key": "Recordlocked",
                "icon": 3,
                "documentation": "Establishes whether or not a record is locked by a user.",
                "detail": "RECORDLOCKED (file.variable , record.ID )",
                "snippet": "RECORDLOCKED(${1:filevar}, ${2:recordkey})"
            },
            {
                "key": "Recordlockl",
                "icon": 14,
                "documentation": "Sets a shared read-only lock on a record in a file.",
                "detail": "RECORDLOCKL file.variable , record.ID [ON ERROR statements] [LOCKED statements]",
                "snippet": "RECORDLOCKL ${1:filevar}, ${2:recordid}"
            },
            {
                "key": "Recordlocku",
                "icon": 14,
                "documentation": "Locks the specified record to prevent other users from accessing it.",
                "detail": "RECORDLOCKU file.variable , record.ID [ON ERROR statements] [LOCKED statements]",
                "snippet": "RECORDLOCKU ${1:filevar}, ${2:recordid}"
            },
            {
                "key": "Release",
                "icon": 14,
                "documentation": "The RELEASE statement explicitly releases record locks without updating the records using a WRITE or DELETE and it also clears all execution locks without issuing an UNLOCK.",
                "detail": "RELEASE [file.variable [,record.ID]] [ON ERROR statements]",
                "snippet": "RELEASE ${1:filevar}, ${2:recordid} ON ERROR ${3:err_statements}"
            },
            {
                "key": "ReleaseXML",
                "icon": 3,
                "documentation": "Releases the XML dynamic array after closing. ReleaseXML destroys the internal DOM tree and releases the associated memory.",
                "detail": "ReleaseXML(XMLhandle)",
                "snippet": "ReleaseXML(${1:XMLhandle})"
            },
            {
                "key": "Rem",
                "icon": 3,
                "documentation": "Calculates the value of the remainder after integer division is performed.",
                "detail": "REM (dividend, divisor)",
                "snippet": "REM (${1:dividend}, ${2:divisor})"
            },
            {
                "key": "Remove",
                "icon": 3,
                "documentation": "Removes substrings from a dynamic array.",
                "detail": "REMOVE (dynamic.array, variable)",
                "snippet": "REMOVE (${1:dynarr}, ${2:variable})"
            },
            {
                "key": "Repeat",
                "icon": 14,
                "documentation": "REPEAT causes the loop to start again with the first statement following the LOOP statement.",
                "detail": "REPEAT",
                "snippet": "REPEAT"
            },
            {
                "key": "Replace",
                "icon": 3,
                "documentation": "Replaces all or part of the contents of a dynamic array.",
                "detail": "REPLACE (expression, field#, value#, subvalue# { , | ; } replacement)\nREPLACE (expression [,field# [,value#]] ; replacement) variable < field# [ ,value# [,subvalue#]] >",
                "snippet": "REPLACE(${1:var}, ${2:attr}, ${3:value}, ${4:subvalue}; ${5:replace})"
            },
            {
                "key": "Return",
                "icon": 14,
                "documentation": "The RETURN statement transfers program execution to the caller of a subroutine\/function or to a specific label in the program.",
                "detail": "RETURN [TO statement.label]",
                "snippet": "RETURN $1"
            },
            {
                "key": "Return",
                "icon": 3,
                "documentation": "Returns a value from a user-written function.",
                "detail": "RETURN (expression)",
                "snippet": "RETURN (${1:expression})"
            },
            {
                "key": "Reuse",
                "icon": 3,
                "documentation": "Reuses the last value in the shorter of two multivalue lists in a dynamic array operation.",
                "detail": "REUSE (expression)",
                "snippet": "REUSE(${1:dynarr})"
            },
            {
                "key": "Revremove",
                "icon": 14,
                "documentation": "Successively removes elements from a dynamic array, starting from the last element and moving right to left. Extracts successive fields, values, etc., for dynamic array processing.",
                "detail": "REVREMOVE element FROM dynamic.array SETTING variable",
                "snippet": "REVREMOVE ${1:element} FROM ${2:dynarr} SETTING ${3:var}"
            },
            {
                "key": "Rewind",
                "icon": 3,
                "documentation": "Rewinds the magnetic tape to the beginning of the tape.",
                "detail": "REWIND [UNIT (mtu)] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "REWIND ${1:UNIT} THEN ${2:then_statements} ELSE ${3:else_statements}"
            },
            {
                "key": "Right",
                "icon": 3,
                "documentation": "Specifies a substring consisting of the last n characters of a string.",
                "detail": "RIGHT (string, n)",
                "snippet": "RIGHT(${1:str}, ${2:length})"
            },
            {
                "key": "Rnd",
                "icon": 3,
                "documentation": "Generates a random number between zero and a specified number minus one.",
                "detail": "RND (expression)",
                "snippet": "RND(${1:expr})"
            },
            {
                "key": "Rollback",
                "icon": 14,
                "documentation": "Rolls back all changes made during a transaction. No changes are written to disk",
                "detail": "ROLLBACK [WORK] [THEN statements] [ELSE statements ]\nstatement",
                "snippet": "ROLLBACK ${1:WORK} THEN ${2:then_statements} ELSE ${3:else_statements}"
            },
            {
                "key": "ROUND",
                "icon": 3,
                "documentation": "Use the ROUND function to round a numeric value to the specified number of decimal places.",
                "detail": "ROUND($num, $places)",
                "snippet": "ROUND(${1:num}, ${2:places})"
            },
            {
                "key": "Rpc.Call",
                "icon": 3,
                "documentation": "Sends requests to a remote server.",
                "detail": "RPC.CALL (connection.ID, procedure, #args, MAT arg.list, #values, MAT return.list)",
                "snippet": "RPC.CALL(${1:connID}, ${2:procedure}, ${3:numargs}, MAT ${4:arglist}, ${5:numvalues}, MAT ${6:return}.list)"
            },
            {
                "key": "Rpc.Connect",
                "icon": 3,
                "documentation": "Establishes a connection with a remote server process.",
                "detail": "RPC.CONNECT($host, $server)",
                "snippet": "RPC.CONNECT(${1:host}, ${2:server})"
            },
            {
                "key": "Rpc.Disconnect",
                "icon": 3,
                "documentation": "Disconnects from a remote server process.",
                "detail": "RPC.DISCONNECT (connection.ID)",
                "snippet": "RPC.DISCONNECT(${1:connID})"
            },
            {
                "key": "Rqm",
                "icon": 3,
                "documentation": "RQM is a synonym for the SLEEP statement.",
                "detail": "RQM $seconds",
                "snippet": "RQM ${1:seconds}"
            },
            {
                "key": "Sadd",
                "icon": 3,
                "documentation": "Adds two string numbers and returns the result as a string number.",
                "detail": "SADD (string.number.1, string.number.2)",
                "snippet": "SADD($1, $2)"
            },
            {
                "key": "saveSecurityContext",
                "icon": 3,
                "documentation": "Encrypts and saves a security context to a system security file.",
                "detail": "saveSecurityContext(context, name, passPhrase)",
                "snippet": "saveSecurityContext(context, name, passPhrase)"
            },
            {
                "key": "Scmp",
                "icon": 3,
                "documentation": "Compares two string numbers.",
                "detail": "SCMP (string.number.1, string.number.2)",
                "snippet": "SCMP($1, $2)"
            },
            {
                "key": "Sdiv",
                "icon": 3,
                "documentation": "Outputs the quotient of the whole division of two integers.",
                "detail": "SDIV (string.number.1, string.number.2 [,precision])",
                "snippet": "SDIV($1, $2, ${3:precision})"
            },
            {
                "key": "Seek",
                "icon": 14,
                "documentation": "Moves the file pointer by an offset, specified in bytes, relative to the current position, the beginning of the file, or the end of the file.",
                "detail": "SEEK file.variable [, offset [, relto]] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "SEEK ${1:filevar}, ${2:offset}, ${3:relto} THEN ${4:then_statements} ELSE ${5:else_statements}"
            },
            {
                "key": "Seek( Arg. )",
                "icon": 3,
                "documentation": "Moves the command line argument pointer.",
                "detail": "SEEK(ARG. [,arg#] ) [THEN statements] [ELSE statements]",
                "snippet": "SEEK(ARG. [,arg#] )"
            },
            {
                "key": "Select",
                "icon": 14,
                "documentation": "The SELECT statement creates a select list of elements in a specified variable for use with the READNEXT statement or to be saved in a list.",
                "detail": "SELECT [variable] [TO list.number] [ON ERROR statements]",
                "snippet": "SELECT ${1:variable1} TO ${2:list} ON ERROR ${3:err_statements}"
            },
            {
                "key": "Selecte",
                "icon": 14,
                "documentation": "Assigns the contents of select list 0 to a variable.",
                "detail": "SELECTE TO list.variable",
                "snippet": "SELECTE TO ${1:listname}"
            },
            {
                "key": "Selectindex",
                "icon": 14,
                "documentation": "Creates select lists from secondary key indexes.",
                "detail": "SELECTINDEX index [, alt.key] FROM file.variable [TO list.number]",
                "snippet": "SELECTINDEX index [, alt.key] FROM file.variable [TO list.number]"
            },
            {
                "key": "Selectinfo",
                "icon": 3,
                "documentation": "Returns the activity status of a select list.",
                "detail": "SELECTINFO (list, key)",
                "snippet": "SELECTINFO (${1:list}, ${2:key})"
            },
            {
                "key": "Selectn",
                "icon": 14,
                "documentation": "Store a select list in a numbered select list.",
                "detail": "SELECTN [variable] [TO list.number] [ON ERROR statements]",
                "snippet": "SELECTN ${1:variable}"
            },
            {
                "key": "Selectv",
                "icon": 14,
                "documentation": "Store a select list in a named list variable.",
                "detail": "SELECTV [variable] TO list.variable [ON ERROR statements]",
                "snippet": "SELECTV ${1:variable} TO ${2:list_variable}"
            },
            {
                "key": "Send",
                "icon": 14,
                "documentation": "Writes a block of data to a device that has been opened for I\/O using OPENDEV or OPENSEQ.",
                "detail": "SEND output [:] TO device { THEN statements [ELSE statements] | ELSE statements }",
                "snippet": "SEND ${1:output} TO ${2:filevar} THEN ${3:then_statements} ELSE ${4:else_statements}"
            },
            {
                "key": "Sentence",
                "icon": 3,
                "documentation": "Returns the stored sentence that invoked the current process.",
                "detail": "SENTENCE ()",
                "snippet": "SENTENCE()"
            },
            {
                "key": "Seq",
                "icon": 3,
                "documentation": "Converts an ASCII character code value to its corresponding numeric value.",
                "detail": "SEQ (expression)",
                "snippet": "SEQ(${1:char})"
            },
            {
                "key": "Seqs",
                "icon": 3,
                "documentation": "Converts each element of a dynamic array from an ASCII character code to a corresponding numeric value.",
                "detail": "SEQS (dynamic.array)",
                "snippet": "SEQS(${1:DynArr})"
            },
            {
                "key": "Set Transaction Isolation Level",
                "icon": 14,
                "documentation": "Sets the default transaction isolation level for your program.",
                "detail": "SET TRANSACTION ISOLATION LEVEL level",
                "snippet": "SET TRANSACTION ISOLATION LEVEL ${1:lvl}"
            },
            {
                "key": "setAuthenticationDepth",
                "icon": 3,
                "documentation": "Sets how deeply UniVerse should verify before deciding that a certificate is not valid.",
                "detail": "setAuthenticationDepth(context, depth, ServerOrClient)",
                "snippet": "setAuthenticationDepth(${1:context}, ${2:depth}, ${3:ServerOrClient})"
            },
            {
                "key": "setCipherSuite",
                "icon": 3,
                "documentation": "Allows you to identify which cipher suites should be supported for the context you specify. It affects the cipher suites and public key algorithms supported during the SSL\/TLS handshake and subsequent data exchanges.",
                "detail": "setCipherSuite(context,cipherSpecs)",
                "snippet": "setCipherSuite(${1:context}, ${2:cipherSpecs})"
            },
            {
                "key": "setClientAuthentication",
                "icon": 3,
                "documentation": "Turns client authentication for a server socket on or off.",
                "detail": "setClientAuthentication(context,option)",
                "snippet": "setClientAuthentication(${1:context}, ${2:option})"
            },
            {
                "key": "setHTTPDefault",
                "icon": 3,
                "documentation": "Configures the default HTTP settings, including proxy server and port, buffer size, authentication credential, HTTP version, and request header values.",
                "detail": "setHTTPDefault(option, value)",
                "snippet": "setHTTPDefault(${1:option}, ${2:value})"
            },
            {
                "key": "setIpv",
                "icon": 3,
                "documentation": "Set the default IPv connection for the whole system or for only Socket networks or UVNet",
                "detail": "setIpv (ipvexpr[,networkexpr])",
                "snippet": "setIpv(${1:option}, ${2:sockettype})"
            },
            {
                "key": "Setlocale",
                "icon": 3,
                "documentation": "Changes the setting of one or all categories for the current locale.",
                "detail": "SETLOCALE (category, value)",
                "snippet": "SETLOCALE(${1:category}, ${2:val})"
            },
            {
                "key": "setPrivateKey",
                "icon": 3,
                "documentation": "Loads the private key into a security context so that it can be used by SSL functions. If the context already had a set private key, it will be replaced.",
                "detail": "setPrivateKey(key, format, keyLoc, passPhrase, validate, context, p12pass)",
                "snippet": "setPrivateKey(${1:key}, ${2:format}, ${3:keyLoc}, ${4:passPhrase}, ${5:validate}, ${6:context}, ${7:p12pass})"
            },
            {
                "key": "setRandomSeed",
                "icon": 3,
                "documentation": "Generates a random seed file from a series of source files and sets that file as the default seed file for the security context you supply.",
                "detail": "setRandomSeed(inFiles, outFile, length, context)",
                "snippet": "setRandomSeed(${1:inFiles}, ${2:outFile}, ${3:length}, ${4:context})"
            },
            {
                "key": "Setrem",
                "icon": 14,
                "documentation": "Sets the position of the REMOVE pointer associated with a dynamic array.",
                "detail": "SETREM position ON dynamic.array",
                "snippet": "SETREM position ON ${1:dynarr}"
            },
            {
                "key": "setRequestHeader",
                "icon": 3,
                "documentation": "Enables you to set additional headers for a request.",
                "detail": "setRequestHeader(request_handle, header_name, header_value)",
                "snippet": "setRequestHeader(${1:request_handle}, ${2:header_name}, ${3:header_value})"
            },
            {
                "key": "setSocketMap",
                "icon": 3,
                "documentation": "Sets the default NLS map for either server or client sockets.",
                "detail": "setSocketMap(mapname)",
                "snippet": "setSocketMap(${1:mapname})"
            },
            {
                "key": "setSocketOptions",
                "icon": 3,
                "documentation": "Sets the current value for a socket option associated with a socket of any type.",
                "detail": "setSocketOptions(socket_handle, options)",
                "snippet": "setSocketOptions(${1:socket_handle}, ${2:options})"
            },
            {
                "key": "showSecurityContext",
                "icon": 3,
                "documentation": "Dumps the SSL configuration parameters of a security context into a readable format.",
                "detail": "showSecurityContext(context, config)",
                "snippet": "showSecurityContext(${1:context}, ${2:config})"
            },
            {
                "key": "Signature",
                "icon": 3,
                "documentation": "Generates a digital signature or verifies a signature using the supplied key.",
                "detail": "SIGNATURE(algorithm, action, data, dataLoc, key, keyLoc, keyFmt, pass, sigIn, result, p12pass)",
                "snippet": "SIGNATURE(${1:algorithm}, ${2:action}, ${3:data}, ${4:dataLoc}, ${5:key}, ${6:keyLoc}, ${7:keyFmt}, ${8:pass}, ${9:sigIn}, ${10:result}, ${11:p12pass})"
            },
            {
                "key": "Sin",
                "icon": 3,
                "documentation": "Calculates the trigonometric sine of an angle.",
                "detail": "SIN (expression)",
                "snippet": "SIN(${1:expr})"
            },
            {
                "key": "Sinh",
                "icon": 3,
                "documentation": "Calculates the hyperbolic sine of an expression.",
                "detail": "SINH (expression)SINH (expression)",
                "snippet": "SINH(${1:expr})"
            },
            {
                "key": "Sleep",
                "icon": 14,
                "documentation": "Suspends execution of a BASIC program, pausing for a specified number of seconds.",
                "detail": "SLEEP [seconds]",
                "snippet": "SLEEP ${1:seconds}"
            },
            {
                "key": "Smul",
                "icon": 3,
                "documentation": "Multiplies two string numbers.",
                "detail": "SMUL (string.number.1, string.number.2)",
                "snippet": "SMUL($1, $2)"
            },
            {
                "key": "SOAPCreateRequest",
                "icon": 3,
                "documentation": "Creates a SOAP request and returns a handle to the request.",
                "detail": "SOAPCreateRequest(URL, soapAction, Request)",
                "snippet": "SOAPCreateRequest(${1:URL}, ${2:soapAction}, ${3:Request})"
            },
            {
                "key": "SOAPCreateSecureRequest",
                "icon": 3,
                "documentation": "creates a secure SOAP request and returns a handle to the request.",
                "detail": "SOAPCreateSecureRequest(URL, soapAction, Request, security_context)",
                "snippet": "SOAPCreateSecureRequest(${1:URL}, ${2:soapAction}, ${3:Request}, ${4:security_context})"
            },
            {
                "key": "SOAPGetDefault",
                "icon": 3,
                "documentation": "Retrieves the default SOAP settings, such as the SOAP version.",
                "detail": "SOAPGetDefault(option, value)",
                "snippet": "SOAPGetDefault(${1:opt}, ${2:val})"
            },
            {
                "key": "SOAPGetFault",
                "icon": 3,
                "documentation": "Parses the response data from SOAPSubmitRequest into a dynamic array of SOAP Fault components.",
                "detail": "SOAPGetFault(respData, soapFault)",
                "snippet": "SOAPGetFault(${1:respData}, ${2:soapFault})"
            },
            {
                "key": "SOAPGetResponseHeader",
                "icon": 3,
                "documentation": "Gets a specific response header after issuing a SOAP request.",
                "detail": "SOAPGetResponseHeader(Request, headerName, headerValue)",
                "snippet": "SOAPGetResponseHeader(${1:request}, ${2:headerName}, ${3:headerValue})"
            },
            {
                "key": "SOAPRequestWrite",
                "icon": 3,
                "documentation": "Outputs the SOAP request, in XML format, to a string or to a file.",
                "detail": "SOAPRequestWrite(Request, reqDoc, docTypeFlag)",
                "snippet": "SOAPRequestWrite(${1:request}, ${2:reqDoc}, ${3:docTypeFlag})"
            },
            {
                "key": "SOAPSetDefault",
                "icon": 3,
                "documentation": "Define default SOAP settings, such as the SOAP version. By default, the SOAP version is 1.1, although you can specify version 1.2.",
                "detail": "SOAPSetDefault(option, value)",
                "snippet": "SOAPSetDefault(${1:opt}, ${2:val})"
            },
            {
                "key": "SOAPSetParameters",
                "icon": 3,
                "documentation": "Sets up the SOAP request body, specifying a remote method to call along with the method's parameter list.",
                "detail": "SOAPSetParameters(Request, URI, serviceName, paramArray)",
                "snippet": "SOAPSetParameters(${1:Request}, ${2:URI}, ${3:serviceName}, ${4:paramArray})"
            },
            {
                "key": "SOAPSetRequestBody",
                "icon": 3,
                "documentation": "Sets up a SOAP request body directly.",
                "detail": "SOAPSetRequestBody(Request, value)",
                "snippet": "SOAPSetRequestBody(${1:Request}, ${2:value})"
            },
            {
                "key": "SOAPSetRequestContent",
                "icon": 3,
                "documentation": "Sets the entire SOAP request's content from an input string or from a file.",
                "detail": "SOAPSetRequestContent(Request, reqDoc, docTypeFlag)",
                "snippet": "SOAPSetRequestContent(${1:Request}, ${2:reqDoc}, ${3:docTypeFlag})"
            },
            {
                "key": "SOAPSetRequestHeader",
                "icon": 3,
                "documentation": "Sets up a SOAP request header. By default, there is no SOAP header.",
                "detail": "SOAPSetRequestHeader(Request, value)",
                "snippet": "SOAPSetRequestHeader(${1:Request}, ${2:value})"
            },
            {
                "key": "SOAPSubmitRequest",
                "icon": 3,
                "documentation": "Submits a request and gets the response.",
                "detail": "SOAPSubmitRequest(Request, timeout, respHeaders, respData, soapStatus)",
                "snippet": "SOAPSubmitRequest(${1:Request}, ${2:timeout}, ${3:respHeaders}, ${4:respData}, ${5:soapStatus})"
            },
            {
                "key": "Soundex",
                "icon": 3,
                "documentation": "Returns the soundex code for a string.",
                "detail": "SOUNDEX (expression)",
                "snippet": "SOUNDEX(${1:str})"
            },
            {
                "key": "Space",
                "icon": 3,
                "documentation": "Generates a string consisting of a specified number of blank spaces.",
                "detail": "SPACE (expression)",
                "snippet": "SPACE(${1:cnt})"
            },
            {
                "key": "Spaces",
                "icon": 3,
                "documentation": "Generates a dynamic array consisting of a specified number of blank spaces for each element.",
                "detail": "SPACES (dynamic.array)",
                "snippet": "SPACES(${1:DynArr})"
            },
            {
                "key": "Splice",
                "icon": 3,
                "documentation": "Inserts a string between the concatenated values of corresponding elements of two dynamic arrays.",
                "detail": "SPLICE (array1, expression, array2)",
                "snippet": "SPLICE(${1:array1}, ${2:str}, ${3:array2})"
            },
            {
                "key": "Sqrt",
                "icon": 3,
                "documentation": "Calculates the square root of a number.",
                "detail": "SQRT (expression)",
                "snippet": "SQRT(${1:expression})"
            },
            {
                "key": "Squote",
                "icon": 3,
                "documentation": "The function will put single quotation mark at the beginning and end of a string.",
                "detail": "SQUOTE(Expression)",
                "snippet": "SQUOTE(${1:expression})"
            },
            {
                "key": "Sselect",
                "icon": 14,
                "documentation": "Creates a sorted list of all record IDs from a UniVerse file.",
                "detail": "SSELECT [variable] [TO list.number] [ON ERROR statements]",
                "snippet": "SSELECT ${1:filevar} TO ${2:list} ON ERROR ${3:statements}"
            },
            {
                "key": "Sselectn",
                "icon": 14,
                "documentation": "Stores a selected list of record IDs in a list number.",
                "detail": "SSELECTN [variable] [TO list.number] [ON ERROR statements]",
                "snippet": "SSELECTN ${1:var}"
            },
            {
                "key": "Sselectv",
                "icon": 14,
                "documentation": "Stores a selected list of record IDs in a list variable.",
                "detail": "SSELECTV [variable] TO list.variable [ON ERROR statements]",
                "snippet": "SSELECTV ${1:var}"
            },
            {
                "key": "Ssub",
                "icon": 3,
                "documentation": "Subtracts one string number from another and returns the result as a string number.",
                "detail": "SSUB (string.number.1, string.number.2)",
                "snippet": "SSUB($1, $2)"
            },
            {
                "key": "Status",
                "icon": 14,
                "documentation": "Determines the status of a UniVerse file open for sequential processing.",
                "detail": "STATUS dynamic.array FROM file.variable {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "STATUS ${1:dynarr} FROM file.variable {THEN statements [ELSE statements] | ELSE statements}"
            },
            {
                "key": "Status",
                "icon": 3,
                "documentation": "Reports the results of a Function or statement previously executed.",
                "detail": "STATUS()",
                "snippet": "STATUS()"
            },
            {
                "key": "Stop",
                "icon": 3,
                "documentation": "The STOP statement terminates program execution and returns system control to the invoking process.",
                "detail": "STOP [expression]",
                "snippet": "STOP $1"
            },
            {
                "key": "Stope",
                "icon": 14,
                "documentation": "The STOPE statement terminates program execution and returns system control to the invoking process. The ERRMSG file is used to display any message.",
                "detail": "STOP [expression]",
                "snippet": "STOP ${1:expr}"
            },
            {
                "key": "Stopm",
                "icon": 14,
                "documentation": "The STOPM statement terminates program execution and returns system control to the invoking process. The expression parameter is used to display any message.",
                "detail": "STOP [expression]",
                "snippet": "STOP ${1:expr}"
            },
            {
                "key": "Storage",
                "icon": 14,
                "documentation": "The STORAGE statement performs no function. It is provided for compatibility with other Pick systems.",
                "detail": "STORAGE arg1arg2arg3",
                "snippet": "STORAGE ${1:args}"
            },
            {
                "key": "Str",
                "icon": 3,
                "documentation": "Generates a particular character string a specified number of times.",
                "detail": "STR (string, repeat)",
                "snippet": "STR(${1:str}, ${2:cnt})"
            },
            {
                "key": "Strs",
                "icon": 3,
                "documentation": "Generates a dynamic array whose elements consist of a character string repeated a specified number of times.",
                "detail": "STRS (dynamic.array, repeat)",
                "snippet": "STRS(${1:DynArr}, ${2:count})"
            },
            {
                "key": "submitRequest",
                "icon": 3,
                "documentation": "Submits a request and gets a response.",
                "detail": "submitRequest(request_handle, time_out, post_data,response_headers,response_data, http_status)",
                "snippet": "submitRequest(${1:request_handle}, ${2:time_out}, ${3:post_data}, ${4:response_headers}, ${5:response_data}, ${6:http_status})"
            },
            {
                "key": "Subr",
                "icon": 3,
                "documentation": "Returns the value of an external subroutine.",
                "detail": "SUBR (name, [argument [,argument ]] )",
                "snippet": "SUBR(${1:name}, ${2:args})"
            },
            {
                "key": "Subroutine",
                "icon": 3,
                "documentation": "The SUBROUTINE statement is used at the start of any program that will be called externally by the CALL statement. It also declares any parameters to the compiler.",
                "detail": "SUBROUTINE [name] [([MAT] variable [, [MAT] variable ] )]",
                "snippet": "SUBROUTINE ${1:name}(${2:args})"
            },
            {
                "key": "Subs",
                "icon": 3,
                "documentation": "Subtracts elements of two dynamic arrays.",
                "detail": "SUBS (array1, array2)",
                "snippet": "SUBS(${1:DynArr1}, ${2:DynArr2})"
            },
            {
                "key": "Substrings",
                "icon": 3,
                "documentation": "Creates a dynamic array consisting of substrings of the elements of another dynamic array.",
                "detail": "SUBSTRINGS (dynamic.array, start, length)",
                "snippet": "SUBSTRINGS(${1:DynArr}, ${2:start}, ${3:length})"
            },
            {
                "key": "Sum",
                "icon": 3,
                "documentation": "Calculates the sum of numeric data within a dynamic array.",
                "detail": "SUM(dynamic.array)",
                "snippet": "SUM(${1:dynarr})"
            },
            {
                "key": "Summaton",
                "icon": 3,
                "documentation": "Adds the elements of a dynamic array.",
                "detail": "SUMMATION(dynamic.array)",
                "snippet": "SUMMATION(${1:dynarr})"
            },
            {
                "key": "Swap",
                "icon": 14,
                "documentation": "Interchanges the values in the variables you specify.",
                "detail": "SWAP variable1, variable2\nSWAP MAT variable1, MAT variable2",
                "snippet": "SWAP ${1:var1} ${2:var2}"
            },
            {
                "key": "System",
                "icon": 3,
                "documentation": "Checks the status of a system function.",
                "detail": "SYSTEM (expression)",
                "snippet": "SYSTEM(${1:key})"
            },
            {
                "key": "Tabstop",
                "icon": 14,
                "documentation": "Sets the current tabstop width for PRINT statements.",
                "detail": "TABSTOP expression",
                "snippet": "TABSTOP ${1:expr}"
            },
            {
                "key": "Tan",
                "icon": 3,
                "documentation": "Calculates the trigonometric tangent of an angle.",
                "detail": "TAN (expression)",
                "snippet": "TAN(${1:expression})"
            },
            {
                "key": "Tanh",
                "icon": 3,
                "documentation": "Calculates the hyperbolic tangent of an expression.",
                "detail": "TANH (expression)",
                "snippet": "TANH(${1:expr})"
            },
            {
                "key": "Terminfo",
                "icon": 3,
                "documentation": "Accesses the information contained in the terminfo files.",
                "detail": "TERMINFO (argument)",
                "snippet": "TERMINFO(${1:arg})"
            },
            {
                "key": "Time",
                "icon": 3,
                "documentation": "Returns the time in internal format.",
                "detail": "TIME ()",
                "snippet": "TIME()"
            },
            {
                "key": "Timedate",
                "icon": 3,
                "documentation": "Returns the time and date.",
                "detail": "TIMEDATE ()",
                "snippet": "TIMEDATE()"
            },
            {
                "key": "Timeout",
                "icon": 14,
                "documentation": "Terminates READSEQ or READBLK if no data is read in the specified time.",
                "detail": "TIMEOUT {file.variable | link.number}, time",
                "snippet": "TIMEOUT ${1:filevar}, ${2:time}"
            },
            {
                "key": "Tparm",
                "icon": 3,
                "documentation": "Evaluates a parameterized terminfo string.",
                "detail": "TPARM (terminfo.string, [arg1], [arg2], [arg3], [arg4], [arg5], [arg6], [arg7], [arg8] )",
                "snippet": "TPARM(${1:terminfo}, ${2:args})"
            },
            {
                "key": "Tprint",
                "icon": 14,
                "documentation": "Sends data with delays to the screen, a line printer, or another specified print file (that is, a logical printer).",
                "detail": "TPRINT [ON print.channel] [print.list]",
                "snippet": "TPRINT ${1:printlist}"
            },
            {
                "key": "Trans",
                "icon": 3,
                "documentation": "Returns the contents of a field in a record of a UniVerse file.",
                "detail": "TRANS ([DICT] filename, record.ID, field#, control.code)",
                "snippet": "TRANS(${1:filename}, ${2:key}, ${3:field}, ${4:controlcode})"
            },
            {
                "key": "Transabort",
                "icon": 14,
                "documentation": "This statement is used to abort the current transaction and reverse any updates to the database.",
                "detail": "TRANSABORT [abort-text] [THEN statement | ELSE statement]",
                "snippet": "TRANSABORT ${1:abort_text}"
            },
            {
                "key": "Transaction Abort",
                "icon": 14,
                "documentation": "Discards changes made during a transaction. No changes are written to disk.",
                "detail": "TRANSACTION ABORT",
                "snippet": "TRANSACTION ABORT"
            },
            {
                "key": "Transaction Commit",
                "icon": 14,
                "documentation": "Commits all changes made during a transaction, writing them to disk.",
                "detail": "TRANSACTION COMMIT\n{THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "TRANSACTION COMMIT\n{THEN statements [ELSE statements] | ELSE statements}"
            },
            {
                "key": "Transaction Start",
                "icon": 14,
                "documentation": "Indicates the beginning of a set of statements that make up a single transaction. (PI\/Open flavor)",
                "detail": "TRANSACTION START\n{THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "TRANSACTION START THEN ${1:then_statements} ELSE ${2:else_statements}"
            },
            {
                "key": "Transquery",
                "icon": 14,
                "documentation": "This function is used to detect whether or not a transaction is active on the current process.",
                "detail": "ROLLBACK",
                "snippet": "ROLLBACK"
            },
            {
                "key": "Transtart",
                "icon": 14,
                "documentation": "In transaction processing, this statement is used to mark the beginning of a transaction.",
                "detail": "TRANSTART [SYNC][start-text] [THEN statement | ELSE statement]",
                "snippet": "TRANSTART ${1:start_text}"
            },
            {
                "key": "Trim",
                "icon": 3,
                "documentation": "Use the TRIM function to remove unwanted characters in expression",
                "detail": "TRIM (expression [,character [,option]] )",
                "snippet": "TRIM(${1:str}, ${2:char}, ${3:mode})"
            },
            {
                "key": "Trimb",
                "icon": 3,
                "documentation": "Deletes all blank spaces and tabs after the last nonblank character in an expression.",
                "detail": "TRIMB (expression)",
                "snippet": "TRIMB(${1:str})"
            },
            {
                "key": "Trimbs",
                "icon": 3,
                "documentation": "Deletes all trailing blank spaces and tabs from each element of a dynamic array.",
                "detail": "TRIMBS (dynamic.array)",
                "snippet": "TRIMBS(${1:DynArr})"
            },
            {
                "key": "Trimf",
                "icon": 3,
                "documentation": "Deletes all blank spaces and tabs up to the first nonblank character in an expression.",
                "detail": "TRIMF(expression)",
                "snippet": "TRIMF(${1:str})"
            },
            {
                "key": "Trimfs",
                "icon": 3,
                "documentation": "Deletes all leading blank spaces and tabs from each element of a dynamic array.",
                "detail": "TRIMFS (dynamic.array)",
                "snippet": "TRIMFS(${1:DynArr})"
            },
            {
                "key": "Trims",
                "icon": 3,
                "documentation": "Deletes extra blank spaces and tabs from the elements of a dynamic array.",
                "detail": "TRIMS (dynamic.array)",
                "snippet": "TRIMS(${1:dynarr})"
            },
            {
                "key": "Trunc",
                "icon": 3,
                "documentation": "Use the TRUNC function to truncate a numeric variable or string to a specified number of decimal places.",
                "detail": "TRUNC($number, $places)",
                "snippet": "TRUNC(${1:number}, ${2:places})"
            },
            {
                "key": "Ttyctl",
                "icon": 14,
                "documentation": "Controls sequential file interaction with a terminal device.",
                "detail": "",
                "snippet": "TTYCTL ${1:filevar}, ${2:code} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Ttyget",
                "icon": 14,
                "documentation": "Gets a dynamic array of the terminal characteristics of a terminal, line printer channel, or magnetic tape channel.",
                "detail": "TTYGET variable [FROM {file.variable | LPTR [n] | MTU [n] }] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "TTYGET ${1:var} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Ttyset",
                "icon": 14,
                "documentation": "Sets the terminal characteristics of a terminal, line printer channel, or magnetic tape channel.",
                "detail": "TTYSET dynamic.array [ON {file.variable | LPTR [n] | MTU [n] }] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "TTYSET ${1:dynarr} ON ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\\nEND"
            },
            {
                "key": "UDOArrayAppendItem",
                "icon": 3,
                "documentation": "Appends the item you specify to the UDO array.",
                "detail": "UDOArrayAppendItem(udoHandle, value)",
                "snippet": "UDOArrayAppendItem(${1:udoHandle}, ${2:value})"
            },
            {
                "key": "UDOArrayDeleteItem",
                "icon": 3,
                "documentation": "Deletes the array item you specify from the index.",
                "detail": "UDOArrayDeleteItem(udoHandle,index)",
                "snippet": "UDOArrayDeleteItem(${1:udoHandle}, ${2:index})"
            },
            {
                "key": "UDOArrayDeleteProperty",
                "icon": 3,
                "documentation": "The UDODeleteProperty function deletes a property from the UDO object.",
                "detail": "UDODeleteProperty($udoHandle, $name)",
                "snippet": "UDODeleteProperty(${1:udoHandle}, ${2:name})"
            },
            {
                "key": "UDOArrayGetItem",
                "icon": 3,
                "documentation": "Returns the UDO array item by its index.",
                "detail": "UDOArrayGetItem(udoHandle, index, value[out], value_type[out])",
                "snippet": "UDOArrayGetItem(${1:udoHandle}, ${2:index}, ${3:value}, ${4:value_type})"
            },
            {
                "key": "UDOArrayGetNextItem",
                "icon": 3,
                "documentation": "returns the next UDO array item relative to the current position, which is the position of the array the last time it was accessed by this function. The initial position is 1.",
                "detail": "UDOArrayGetNextItem(udoHandle, value[out], type[out])",
                "snippet": "UDOArrayGetNextItem(${1:udoHandle}, ${2:value}, ${3:type})"
            },
            {
                "key": "UDOArrayGetSize",
                "icon": 3,
                "documentation": "Gets the size of the UDO array.",
                "detail": "UDOArrayGetNextItem(udoHandle, value[out], type[out])",
                "snippet": "UDOArrayGetSize(${1:udoHandle}, ${2:size})"
            },
            {
                "key": "UDOArrayInsertItem",
                "icon": 3,
                "documentation": "Inserts a UDO array element at the position you specify by index.",
                "detail": "UDOArrayInsertItem(udoHandle, index, value)",
                "snippet": "UDOArrayInsertItem(${1:udoHandle}, ${2:index}, ${3:value})"
            },
            {
                "key": "UDOArraySetItem",
                "icon": 3,
                "documentation": "Sets or inserts a UDO array element at the position you specify.",
                "detail": "UDOArraySetItem(udoHandle, index, value)",
                "snippet": "UDOArraySetItem(${1:udoHandle}, ${2:index}, ${3:value})"
            },
            {
                "key": "UDOClone",
                "icon": 3,
                "documentation": "Clones a UDO object or array so that changes to the new object or array will not affect the original object.",
                "detail": "UDOClone(udoHandle, newUdoHandle[out])",
                "snippet": "UDOClone(${1:udoHandle}, ${2:newUdoHandle})"
            },
            {
                "key": "UDOCreate",
                "icon": 3,
                "documentation": "Creates a UDO item of the type you specify.",
                "detail": "UDOCreate(udoType, udoHandle[out])",
                "snippet": "UDOCreate(${1:udoType}, ${2:udoHandle})"
            },
            {
                "key": "UDODeleteProperty",
                "icon": 3,
                "documentation": "Deletes a property from the UDO object.",
                "detail": "UDODeleteProperty(udoHandle, name)",
                "snippet": "UDODeleteProperty(udoHandle, name)"
            },
            {
                "key": "UDOFree",
                "icon": 3,
                "documentation": "Forcefully removes a UDO object or array from memory.",
                "detail": "UDOFree(udoHandle)",
                "snippet": "UDOFree(${1:udoHandle})"
            },
            {
                "key": "UDOGetLastError",
                "icon": 3,
                "documentation": "Return the last error code and error message.",
                "detail": "UDOGetLastError(errorCode[out], errorMessage[out])",
                "snippet": "UDOGetLastError(${1:errorCode}, ${2:errorMessage})"
            },
            {
                "key": "UDOGetNextProperty",
                "icon": 3,
                "documentation": "Provides a convenient way to walk through all the properties in a UDO object, without needing to know the property names in advance.",
                "detail": "UDOGetNextProperty(udoHandle, name[out], value[out], value_type[out])",
                "snippet": "UDOGetNextProperty(${1:udoHandle}, ${2:name}, ${3:value}, ${4:value_type})"
            },
            {
                "key": "UDOGetOption",
                "icon": 3,
                "documentation": "Gets the value of a UDO option.",
                "detail": "UDOGetOption(option, value[out])",
                "snippet": "UDOGetOption(${1:option}, ${2:value})"
            },
            {
                "key": "UDOGetProperty",
                "icon": 3,
                "documentation": "Returns the value and type of the UDO object.",
                "detail": "UDOGetProperty(udoHandle, name, value[out], value_type[out])",
                "snippet": "UDOGetProperty(${1:udoHandle}, ${2:name}, ${3:value}, ${4:value_type})"
            },
            {
                "key": "UDOGetPropertyNames",
                "icon": 3,
                "documentation": "Returns a UDO array that holds the names of all the properties in the UDO object.",
                "detail": "UDOGetPropertyNames(udoHandle, udoArray[out])",
                "snippet": "UDOGetPropertyNames(${1:udoHandle}, ${2:udoArray})"
            },
            {
                "key": "UDOGetType",
                "icon": 3,
                "documentation": "Gets the UDO value type of a UniVerse BASIC variable.",
                "detail": "UDOGetType(udoHandle, type[out)",
                "snippet": "UDOGetType(${1:udoHandle}, ${2:type})"
            },
            {
                "key": "UDOIsTypeOf",
                "icon": 3,
                "documentation": "Test the UDO value type of a UniVerse BASIC variable.",
                "detail": "UDOIsTypeOf(udoHandle, type)",
                "snippet": "UDOIsTypeOf(${1:udoHandle}, ${2:type})"
            },
            {
                "key": "UDORead",
                "icon": 3,
                "documentation": "Creates a UDO object from a JSON string or XML string.",
                "detail": "UDORead(inputString, inputType, udoHandle[out])",
                "snippet": "UDORead(${1:inputString}, ${2:inputType}, ${3:udoHandle})"
            },
            {
                "key": "UDOSetOption",
                "icon": 3,
                "documentation": "Sets the options for the UDO API.",
                "detail": "UDOSetOption(option, value)",
                "snippet": "UDOSetOption(${1:option}, ${2:value})"
            },
            {
                "key": "UDOSetProperty",
                "icon": 3,
                "documentation": "Creates or updates a property on a UDO object.",
                "detail": "UDOSetOption(option, value)",
                "snippet": "UDOSetProperty(${1:udoHandle}, ${2:name}, ${3:value})"
            },
            {
                "key": "UDOWrite",
                "icon": 3,
                "documentation": "Writes a UDO object in JSON or XML format.",
                "detail": "UDOWrite(udoHandle, outputType, outputString[out])",
                "snippet": "UDOWrite(${1:udoHandle}, ${2:outputType}, ${3:outputString})"
            },
            {
                "key": "Unassigned",
                "icon": 3,
                "documentation": "The UNASSIGNED function allows a program to determine whether a variable has been assigned a value.",
                "detail": "UNASSIGNED(variable)",
                "snippet": "UNASSIGNED(${1:variable})"
            },
            {
                "key": "Unichar",
                "icon": 3,
                "documentation": "Generates a character from a Unicode integer value.",
                "detail": "UNICHAR (unicode)",
                "snippet": "UNICHAR(${1:unicode})"
            },
            {
                "key": "Unichars",
                "icon": 3,
                "documentation": "Generates a dynamic array from an array of Unicode values.",
                "detail": "UNICHARS (dynamic.array)",
                "snippet": "UNICHARS(${1:dynarr})"
            },
            {
                "key": "Uniseq",
                "icon": 3,
                "documentation": "Generates a Unicode integer value from a character.",
                "detail": "UNISEQ (expression)",
                "snippet": "UNISEQ(${1:expr})"
            },
            {
                "key": "Uniseqs",
                "icon": 3,
                "documentation": "Generates an array of Unicode values from a dynamic array.",
                "detail": "UNISEQS (dynamic.array)",
                "snippet": "UNISEQS(${1:dynarr})"
            },
            {
                "key": "Unlock",
                "icon": 14,
                "documentation": "Releases an execution lock that was set with the LOCK statement.",
                "detail": "UNLOCK [expression]",
                "snippet": "UNLOCK ${1:expr}"
            },
            {
                "key": "Upcase",
                "icon": 3,
                "documentation": "UPCASE converts all lowercase characters in an expression to uppercase characters.",
                "detail": "UPCASE(expression)",
                "snippet": "UPCASE(${1:str})"
            },
            {
                "key": "Uprint",
                "icon": 14,
                "documentation": "Prints data without performing any mapping. Typically used with data that has already been mapped using OCONV (mapname).",
                "detail": "UPRINT [ON print.channel] [print.list ]",
                "snippet": "UPRINT ${1:expr}"
            },
            {
                "key": "Userinfo",
                "icon": 3,
                "documentation": "Gets the PID, user number and more for the PID or user number specified.",
                "detail": "USERINFO (code, value, userinfo)",
                "snippet": "USERINFO(${1:code}, ${2:value}, ${3:userinfo})"
            },
            {
                "key": "Uvsysmon",
                "icon": 3,
                "documentation": "The system-level uvsysmon utility monitors the performance of the Recoverable File System (RFS).",
                "detail": "uvsysmon"
            },
            {
                "key": "Weof",
                "icon": 3,
                "documentation": "Writes an end-of-file mark to a magnetic tape.",
                "detail": "WEOF [UNIT (mtu)] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "WEOF ${1:UNIT} THEN ${2:then_statements} ELSE ${3:else_statements}"
            },
            {
                "key": "Weofseq",
                "icon": 14,
                "documentation": "Writes an end-of-file mark to a UniVerse file open for sequential processing at the current position.",
                "detail": "WEOFSEQfile.variable [ON ERROR statements]",
                "snippet": "WEOFSEQ ${1:filevar} ON ERROR ${2:err_statements}"
            },
            {
                "key": "Write",
                "icon": 14,
                "documentation": "The WRITE statement allows a program to write a record into a previously opened file.",
                "detail": "WRITE expression {ON | TO} [file.variable,] record.ID [ON ERROR statements] [LOCKED statements] [THEN statements] [ELSE statements]",
                "snippet": "WRITE ${1:var} TO ${2:filevar},${3:recordkey}"
            },
            {
                "key": "Writeblk",
                "icon": 14,
                "documentation": "Writes a block of data to a record in a sequential file.",
                "detail": "WRITEBLK expression ON file.variable {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "WRITEBLK ${1:var} ON ${2:filevar} THEN ${3:then_statements} ELSE ${4:else_statements}"
            },
            {
                "key": "Writelist",
                "icon": 14,
                "documentation": "Saves a list as a record in the &SAVEDLISTS& file.",
                "detail": "WRITELIST dynamic.array ON listname",
                "snippet": "WRITELIST ${1:dynarr} TO ${2:listname}"
            },
            {
                "key": "Writeseq",
                "icon": 14,
                "documentation": "Writes new values to the specified record of a UniVerse file sequentially.",
                "detail": "WRITESEQ expression {ON | TO} file.variable [ON ERROR statements] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "WRITESEQ ${1:expr} TO ${2:filevar} ON ERROR ${3:err_statements} THEN ${4:then_statements} ELSE ${5:else_statements}"
            },
            {
                "key": "Writeseqf",
                "icon": 14,
                "documentation": "Writes new values to the specified record of a UniVerse file sequentially and ensures that the data is written to disk.",
                "detail": "WRITESEQF expression {ON | TO} file.variable [ON ERROR statements] {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "WRITESEQF ${1:var} TO ${2:filevar} ON ERROR ${3:err_statements} THEN ${4:then_statements} ELSE ${5:else_statements}"
            },
            {
                "key": "writeSocket",
                "icon": 3,
                "documentation": "Writes data to a socket connection.",
                "detail": "writeSocket(socket_handle, socket_data, time_out, mode, actual_write_size)",
                "snippet": "writeSocket(${1:socket_handle}, ${2:socket_data}, ${3:time_out}, ${4:mode}, ${5:actual_write_size})"
            },
            {
                "key": "Writet",
                "icon": 3,
                "documentation": "Writes the contents of a record onto magnetic tape.",
                "detail": "WRITET [UNIT (mtu)] variable {THEN statements [ELSE statements] | ELSE statements}",
                "snippet": "WRITET ${1:var} TO ${2:expression} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Writeu",
                "icon": 14,
                "documentation": "The WRITEU statement allows a program to write a record into a previously opened file. An existing record lock will be preserved.",
                "detail": "WRITEU variable1 ON|TO [ variable2,] expression [SETTING setvar] [ON ERROR statements]",
                "snippet": "WRITEU ${1:var} TO ${2:filevar},${3:recordkey}"
            },
            {
                "key": "Writev",
                "icon": 14,
                "documentation": "TThe WRITEV statement allows a program to write a specific field of a record in a previously opened file.",
                "detail": "WRITEV expression {ON | TO} [file.variable,] record.ID, field# [ON ERROR statements] [LOCKED statements] [THEN statements] [ELSE statements]",
                "snippet": "WRITEV ${1:var} TO ${2:filevar},${3:recordkey},${4:attr}"
            },
            {
                "key": "Writevu",
                "icon": 14,
                "documentation": "Replaces the contents of a field in the record without releasing the record lock.",
                "detail": "WRITEVU expression {ON | TO} [file.variable,] record.ID, field# [ON ERROR statements] [LOCKED statements] [THEN statements] [ELSE statements]",
                "snippet": "WRITEVU ${1:var} TO ${2:filevar},${3:recordkey},${4:attr}"
            },
            {
                "key": "XDOMAddChild",
                "icon": 3,
                "documentation": "Inserts a node as the last child of the found node. I",
                "detail": "XDOMAddChild(xmlHandle, xpathString, nsMap, nodeHandle, dupFlag,nodeType)",
                "snippet": "XDOMAddChild(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:nodeHandle}, ${5:dupFlag}, ${6:nodeType})"
            },
            {
                "key": "XDOMAppend",
                "icon": 3,
                "documentation": "Finds the xpathString in the context xmlHandle in the DOM structure, and inserts nodeHandle into the DOM structure as the next sibling of the found node. If the inserted node type is XDOM.ATTR.NODE, this node is inserted as an attribute.",
                "detail": "XDOMAppend(xmlHandle, xpathString, nsMap, nodeHandle, dupFlag)",
                "snippet": "XDOMAppend(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:nodeHandle}, ${5:dupFlag})"
            },
            {
                "key": "XDOMClone",
                "icon": 3,
                "documentation": "Duplicates the DOM subtree specified by xmlHandle to a new subtree newXmlHandle. ",
                "detail": "XDOMClone(xmlHandle, newXmlHandle, depth)",
                "snippet": "XDOMClone(${1:xmlHandle}, ${2:newXmlHandle}, ${3:depth})"
            },
            {
                "key": "XDOMClose",
                "icon": 3,
                "documentation": "Frees the DOM structure.",
                "detail": "XDOMClose(domHandle)",
                "snippet": "XDOMClose(${1:domHandle})"
            },
            {
                "key": "XDOMCreateNode",
                "icon": 3,
                "documentation": "Creates a new node in the DOM structure.",
                "detail": "XDOMCreateNode(xmlHandle, nodeName, nodeValue, nodeType, nodeHandle)",
                "snippet": "XDOMCreateNode(${1:xmlHandle}, ${2:nodeName}, ${3:nodeValue}, ${4:nodeType}, ${5:nodeHandle})"
            },
            {
                "key": "XDOMCreateRoot",
                "icon": 3,
                "documentation": "Creates a new DOM structure with root only.",
                "detail": "XDOMCreateRoot(domHandle)",
                "snippet": "XDOMCreateRoot(${1:domHandle})"
            },
            {
                "key": "XDOMEvaluate",
                "icon": 3,
                "documentation": "Returns the value of xpathString in the context xmlHandle in the DOM structure.",
                "detail": "XDOMEvaluate(xmlHandle, xpathString, nsMap, aValue)",
                "snippet": "XDOMEvaluate(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:aValue})"
            },
            {
                "key": "XDOMGetAttribute",
                "icon": 3,
                "documentation": "Gets the node's attribute node, whose attribute name is attrName.",
                "detail": "XDOMGetAttribute(nodeHandle, attrName, nodeHandle)",
                "snippet": "XDOMGetAttribute(${1:nodeHandle}, ${2:attrName}, ${3:nodeHandle})"
            },
            {
                "key": "XDOMGetChildNodes",
                "icon": 3,
                "documentation": "Returns all child nodes of xmlHandle.",
                "detail": "XDOMGetChildNodes(xmlHandle, nodeListHandle)",
                "snippet": "XDOMGetChildNodes(${1:xmlHandle}, ${2:nodeListHandle})"
            },
            {
                "key": "XDOMGetElementById",
                "icon": 3,
                "documentation": "Finds the first element with the ID you specify.",
                "detail": "XDOMGetElementById(xmlHandle,idstr,nodeHandle)",
                "snippet": "XDOMGetElementById(${1:xmlHandle}, ${2:idstr}, ${3:nodeHandle})"
            },
            {
                "key": "XDOMGetElementsByName",
                "icon": 3,
                "documentation": "Tries to find all elements with the name you specify.",
                "detail": "XDOMGetElementsByName(xmlHandle, namestr, nodeListHandle)",
                "snippet": "XDOMGetElementsByName(${1:xmlHandle}, ${2:namestr}, ${3:nodeListHandle})"
            },
            {
                "key": "XDOMGetElementsByTag",
                "icon": 3,
                "documentation": "Tries to find all elements with the tag name you specify.",
                "detail": "XDOMGetElementsByTag(xmlHandle, tagname, nodeListHandle)",
                "snippet": "XDOMGetElementsByTag(${1:xmlHandle}, ${2:tagname}, ${3:nodeListHandle})"
            },
            {
                "key": "XDOMGetNodeName",
                "icon": 3,
                "documentation": "Returns the node name.",
                "detail": "XDOMGetNodeName(nodeHandle, nodeName)",
                "snippet": "XDOMGetElementsByTag(${1:nodeHandle}, ${2:nodeName})"
            },
            {
                "key": "XDOMGetNodeType",
                "icon": 3,
                "documentation": "Returns the node type.",
                "detail": "XDOMGetNodeType(nodeHandle, nodeType)",
                "snippet": "XDOMGetNodeType(${1:nodeHandle}, ${2:nodeType})"
            },
            {
                "key": "XDOMGetNodeValue",
                "icon": 3,
                "documentation": "Gets the node value.",
                "detail": "XDOMGetNodeValue(nodeHandle, nodeValue)",
                "snippet": "XDOMGetNodeValue(${1:nodeHandle}, ${2:nodeValue})"
            },
            {
                "key": "XDOMGetOwnerDocument",
                "icon": 3,
                "documentation": "Returns the DOM handle to which nodeHandle belongs.",
                "detail": "XDOMGetOwnerDocument(nodeHandle, domHandle)",
                "snippet": "XDOMGetOwnerDocument(${1:nodeHandle}, ${2:domHandle})"
            },
            {
                "key": "XDOMGetUserData",
                "icon": 3,
                "documentation": "Returns the user data associated with the node.",
                "detail": "XDOMGetUserData(nodeHandle, userData)",
                "snippet": "XDOMGetUserData(${1:nodeHandle}, ${2:userData})"
            },
            {
                "key": "XDOMItem",
                "icon": 3,
                "documentation": "Returns the index-th item in the list.",
                "detail": "XDOMItem(nodeListHandle, index, dataHandle, dataType)",
                "snippet": "XDOMItem(${1:nodeListHandle}, ${2:index}, ${3:dataHandle}, ${4:dataType})"
            },
            {
                "key": "XDOMLength",
                "icon": 3,
                "documentation": "Determines the number of nodes in the list. The range of the valid child node index is to 1 to length, inclusive.",
                "detail": "XDOMLength(nodeListHandle, length)",
                "snippet": "XDOMLength(${1:nodeListHandle}, ${2:length})"
            },
            {
                "key": "XDOMLocate",
                "icon": 3,
                "documentation": "Finds a starting point for relative XPath searching in context xmlHandle in the DOM structure. ",
                "detail": "XDOMLocate(xmlHandle, xpathString, nsMap, nodeHandle )",
                "snippet": "XDOMLocate(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:nodeHandle}, ${5:XMLSINGLE_XMLMULTI})"
            },
            {
                "key": "XDOMLocateNode",
                "icon": 3,
                "documentation": "Traverses from nodeHandle and gets the next node according to direction and childIndex.",
                "detail": "XDOMLocateNode(nodeHandle, direction, childIndex, nodeType, newNodeHandle)",
                "snippet": "XDOMLocateNode(${1:nodeHandle}, ${2:direction}, ${3:childIndex}, ${4:nodeType}, ${5:newNodeHandle})"
            },
            {
                "key": "XDOMOpen",
                "icon": 3,
                "documentation": "Reads an xmlDocument and creates DOM structure. If the DTD is included in the document, UniVerse validates the document. The xmlDocument can be from a string, or from a file, depending on the docLocation flag.",
                "detail": "XDOMOpen(xmlDocument, docLocation, domHandle)",
                "snippet": "XDOMOpen(${1:xmlDocument}, ${2:docLocation}, ${3:domHandle})"
            },
            {
                "key": "XDOMQuery",
                "icon": 3,
                "documentation": "Runs xquery on the current document or document node you specify with xmlHandle.",
                "detail": "XDOMQuery(xmlHandle, xquery, xqueryLocation, itemListHandle)",
                "snippet": "XDOMQuery(${1:xmlHandle}, ${2:xquery}, ${3:xqueryLocation}, ${4:itemListHandle})"
            },
            {
                "key": "XDOMRemove",
                "icon": 3,
                "documentation": "Finds the xpathString in the context xmlHandle in the DOM structure, and then removes the found node or its attribute with name attrName.",
                "detail": "XDOMRemove(xmlHandle, xpathString, nsMap, attrName, nodeHandle)",
                "snippet": "XDOMRemove(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:attrName}, ${5:nodeHandle})"
            },
            {
                "key": "XDOMReplace",
                "icon": 3,
                "documentation": "Finds the xpathString in the context xmlHandle in the DOM structure, and replaces the found node with nodeHandle.",
                "detail": "XDOMReplace(xmlHandle, xpathString, nsMap, nodeHandle, dupFlag)",
                "snippet": "XDOMReplace(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:nodeHandle}, ${5:dupFlag})"
            },
            {
                "key": "XDOMSetNodeValue",
                "icon": 3,
                "documentation": "Sets the node value.",
                "detail": "XDOMSetNodeValue(nodeHandle, nodeValue)",
                "snippet": "XDOMSetNodeValue(${1:nodeHandle}, ${2:nodeValue})"
            },
            {
                "key": "XDOMSetUserData",
                "icon": 3,
                "documentation": "Sets the user data associated with the node.",
                "detail": "XDOMSetUserData(nodeHandle, userData)",
                "snippet": "XDOMSetUserData(${1:nodeHandle}, ${2:userData})"
            },
            {
                "key": "XDOMTransform",
                "icon": 3,
                "documentation": "Transforms input DOM structure using the style sheet specified by styleSheet to output DOM structure.",
                "detail": "XDOMTransform(domHandle, styleSheet, ssLocation, outDomHandle)",
                "snippet": "XDOMTransform(${1:domHandle}, ${2:styleSheet}, ${3:ssLocation}, ${4:outDomHandle})"
            },
            {
                "key": "XDOMValidate",
                "icon": 3,
                "documentation": "Validates the DOM document using the schema specified by schFile.",
                "detail": "XDOMValidate(xmlDocument, docLocation, schFile, schLocation)",
                "snippet": "XDOMValidate(${1:xmlDocument}, ${2:docLocation}, ${3:schFile}, ${4:schLocation})"
            },
            {
                "key": "XDOMWrite",
                "icon": 3,
                "documentation": "Writes the DOM structure to xmlDocument. xmlDocument can be a string or a file, depending on the value of the docLocation flag.",
                "detail": "XDOMWrite(domHandle, xmlDocument, docLocation)",
                "snippet": "XDOMWrite(${1:domHandle}, ${2:xmlDocument}, ${3:docLocation})"
            },
            {
                "key": "Xlate",
                "icon": 3,
                "documentation": "Returns the contents of a field in a record of a UniVerse file.",
                "detail": "XLATE ([DICT] filename, record.ID, field#, control.code)",
                "snippet": "XLATE(${1:filename}, ${2:recordkey}, ${3:field}, ${4:actioncode})"
            },
            {
                "key": "XMAPAppendRec",
                "icon": 3,
                "documentation": "Formats the specified record from the UniVerse file as a U2XMAP dataset record and appends it to the U2XMAP dataset.",
                "detail": "XMAPAppendRec(XMAPhandle, file_name, record)",
                "snippet": "XMAPAppendRec(${1:XMAPhandle}, ${2:file_name}, ${3:record})"
            },
            {
                "key": "XMAPClose",
                "icon": 3,
                "documentation": "Closes the U2XMAP dataset handle and frees all related structures and memory.",
                "detail": "XMAPClose(XMAP_handle)",
                "snippet": "XMAPClose(${1:XMAP_handle})"
            },
            {
                "key": "XMAPCreate",
                "icon": 3,
                "documentation": "Creates an empty XML document for transferring data from the UniVerse database to XML according the mapping rules you define.",
                "detail": "XMAPCreate(u2xmapping_rules, mapping_flag, XMAPhandle)",
                "snippet": "XMAPCreate(${1:u2xmapping_rules}, ${2:mapping_flag}, ${3:XMAPhandle})"
            },
            {
                "key": "XMAPOpen",
                "icon": 3,
                "documentation": "Opens an XML document as a U2XMAP data set.",
                "detail": "XMAPOpen(xml_document, doc_flag, u2xmapping_rules, u2xmap_flag, XMAPhandle)",
                "snippet": "XMAPOpen(${1:xml_document}, ${2:doc_flag}, ${3:u2xmapping_rules}, ${4:u2xmap_flag}, ${5:XMAPhandle})"
            },
            {
                "key": "XMAPReadNext",
                "icon": 3,
                "documentation": "etrieves the next record from the U2XMAP dataset and formats it as a record of the UniVerse file that is being mapped.",
                "detail": "XMAPReadNext(XMAPhandle, file_name, record)",
                "snippet": "XMAPReadNext(${1:XMAPhandle}, ${2:file_name}, ${3:record})"
            },
            {
                "key": "XMAPToXMLDoc",
                "icon": 3,
                "documentation": "Generates an XML document from the data in the U2XMAP dataset using the mapping rules you define.",
                "detail": "XMAPToXMLDoc(XMAPhandle, xmlfile, doc_flag)",
                "snippet": "XMAPToXMLDoc(${1:XMAPhandle}, ${2:xmlfile}, ${3:doc_flag})"
            },
            {
                "key": "XMLError",
                "icon": 3,
                "documentation": "Get the last error message.",
                "detail": "XMLError(errmsg)",
                "snippet": "XMLError(${1:errmsg})"
            },
            {
                "key": "XMLError",
                "icon": 14,
                "documentation": "Gets the last error message when using XML documents.",
                "detail": "XMLError",
                "snippet": "XMLError"
            },
            {
                "key": "XMLExecute",
                "icon": 3,
                "documentation": "Enables you to create an XML document using the RetrieVe LIST statement or the UniVerse SQL SELECT statement from a UniVerse BASIC program.",
                "detail": "XMLExecute(cmd, options, xmlvar, xsdvar)",
                "snippet": "XMLExecute(${1:cmd}, ${2:options}, ${3:xmlvar}, ${4:xsdvar})"
            },
            {
                "key": "XMLGetError",
                "icon": 3,
                "documentation": "Returns the error code and error message after the previous XML API failed.",
                "detail": "XMLGetError(errorCode, errorMessage)",
                "snippet": "XMLGetError(${1:errorCode}, ${2:errorMessage})"
            },
            {
                "key": "XMLTODB",
                "icon": 3,
                "documentation": "Populate the UniVerse database.",
                "detail": "XMLTODB(xml_document, doc_flag, u2xmapping_rules, u2xmap_ flag, status)",
                "snippet": "XMLTODB(${1:xml_document}, ${2:doc_flag}, ${3:u2xmapping_rules}, ${4:u2xmap_flag}, ${5:status})"
            },
            {
                "key": "XTD",
                "icon": 3,
                "documentation": "Convert a string of hexadecimal characters to an integer. ",
                "detail": "XTD (string)",
                "snippet": "XTD(${1:str})"
            }
        ]
    }
}
