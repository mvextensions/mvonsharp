{
    "Language": {
        "Type": "UniData Basic",
        "Keywords": [
            {
                "key": "$BASICTYPE",
                "icon": 14,
                "documentation": "The UniBasic $BASICTYPE command compiles data in a specified BASICTYPE. The $BASICTYPE statement must be the first noncomment statement in the program or subroutine.",
                "detail": "\\$BASICTYPE $param",
                "snippet": "$BASICTYPE ${1:param}"
            },
            {
                "key": "$DEFINE",
                "icon": 14,
                "documentation": "The UniBasic $DEFINE command defines a control variable you can use later to direct compilation.",
                "detail": "\\$DEFINE $var",
                "snippet": "$DEFINE ${1:var}"
            },
            {
                "key": "$IFDEF",
                "icon": 14,
                "documentation": "The UniBasic $IFDEF command conditionally compiles UniBasic statements depending on the existence of a variable definition. Variables are defined by $DEFINE.",
                "detail": "\\$IFDEF $var\n\t$statements\n\\$ELSE\n\t$else_statments\n\\$ENDIF",
                "snippet": "$IFDEF ${1:var}\n\t${2:statements}\n\\${3:ELSE}\n\t${4:else_statments}\n\\${5:ENDIF}"
            },
            {
                "key": "$IFNDEF",
                "icon": 14,
                "documentation": "The UniBasic $IFNDEF command conditionally compiles UniBasic statements depending on the absence of a variable definition. Variables are defined by $DEFINE.",
                "detail": "\\$IFNDEF $var\n\t$statements\n\\$ELSE\n\t$else_statments\n\\$ENDIF",
                "snippet": "$IFNDEF ${1:var}\n\t${2:statements}\n\\${3:ELSE}\n\t${4:else_statments}\n\\${5:ENDIF}"
            },
            {
                "key": "$INCLUDE",
                "icon": 14,
                "documentation": "The UniBasic $INCLUDE and $INSERT commands insert UniBasic source code from the file you specify into the program being compiled. The third form of the syntax inserts code from a UNIX, or Windows platform sequential file.",
                "detail": "\\$INCLUDE $expr",
                "snippet": "$INCLUDE ${1:expr}"
            },
            {
                "key": "$INSERT",
                "icon": 14,
                "documentation": "$INSERT is a synonym for the $INCLUDE command.",
                "detail": "\\$INSERT $expr",
                "snippet": "$INSERT ${1:expr}"
            },
            {
                "key": "$UNDEFINE",
                "icon": 14,
                "documentation": "The UniBasic $UNDEFINE command deletes the definition of var previously defined by $DEFINE.",
                "detail": "\\$UNDEFINE $var",
                "snippet": "$UNDEFINE ${1:var}"
            },
            {
                "key": "ABORT",
                "icon": 14,
                "documentation": "The UniBasic ABORT command terminates the program or subroutine in progress, returning the user to the UniData system level. ABORT returns the user to the UniData prompt, whether the aborted program was called by another program or executed through a UniData menu or paragraph. ABORT can include an optional string exprto display when the program aborts. The expression can contain variables, functions, and\/or arithmetic or string operators.",
                "detail": "ABORT $expr",
                "snippet": "ABORT ${1:expr}"
            },
            {
                "key": "ABS",
                "icon": 3,
                "documentation": "The UniBasic ABS function returns the positive numeric value (absolute value) of the argument. expr can be any numeric expression.",
                "detail": "ABS($expr)",
                "snippet": "ABS(${1:expr})"
            },
            {
                "key": "acceptConnection",
                "icon": 3,
                "documentation": "Use the acceptConnection() function to accept an incoming connection attempt on the server side socket.",
                "detail": "acceptConnection",
                "snippet": "acceptConnection()"
            },
            {
                "key": "ACOS",
                "icon": 3,
                "documentation": "The UniBasic ACOS function returns the trigonometric arc cosine (inverse cosine) of a numeric expression in degrees. expr must be a value between -1 and +1. ACOS returns a value expressed as the degree of the arc cosine of the input, which ranges from 0 to 180. If expr evaluates to a value outside the range of -1 to +1, UniData displays an error message and returns 0 as the result.",
                "detail": "ACOS($expr)",
                "snippet": "ACOS(${1:expr})"
            },
            {
                "key": "ACTIVATEKEY",
                "icon": 14,
                "documentation": "Use the ACTIVATEKEY command to activate a key or wallet. It is necessary to activate a key if you want to supply a password for key protection.",
                "detail": "ACTIVATEKEY $keyid, $password ON $NFA_SERVER ON ERROR $err",
                "snippet": "ACTIVATEKEY ${1:keyid}, ${2:password} ON ${3:NFA_SERVER} ON ERROR ${4:err}"
            },
            {
                "key": "addAuthenticationRule",
                "icon": 3,
                "documentation": "The addAuthenticationRule function adds an authentication rule to a security context. The rules are used during SSL negotiation to determine whether or not the peer is to be trusted.",
                "detail": "addAuthenticationRule($context, $serverOrClient, $rule, $ruleString)",
                "snippet": "addAuthenticationRule(${1:context}, ${2:serverOrClient}, ${3:rule}, ${4:ruleString})"
            },
            {
                "key": "addCertificate",
                "icon": 3,
                "documentation": "The addCertificate function loads a certificate, or multiple certificates, into a security context for UniData to use as a server or client certificate. Alternatively, this function can specify a directory which contains the certificates that are either used as CA (Certificate Authority) certificates to authenticate incoming certificates, or act as a Revocation list to check against expired or revoked certificates.",
                "detail": "addCertificate($certPath, $usedAs, $format, $algorithm, $context)",
                "snippet": "addCertificate(${1:certPath}, ${2:usedAs}, ${3:format}, ${4:algorithm}, ${5:context})"
            },
            {
                "key": "addRequestParameter",
                "icon": 3,
                "documentation": "The addRequestParameter function adds a parameter to the request.",
                "detail": "addRequestParameter($request_handle, $parameter_name, $parameter_value, $content_handling)",
                "snippet": "addRequestParameter(${1:request_handle}, ${2:parameter_name}, ${3:parameter_value}, ${4:content_handling})"
            },
            {
                "key": "ALPHA",
                "icon": 3,
                "documentation": "The UniBasic ALPHA function tests a string to see if it is composed entirely of alphabetic characters. If str.expr is made entirely of alphabetic characters (not special characters, escape sequences, or the null value), the function returns 1. If numeric or other characters are present in str.expr, or if str.expr evaluates to an empty string or the null value, the function returns 0.",
                "detail": "ALPHA($value)",
                "snippet": "ALPHA(${1:value})"
            },
            {
                "key": "amInitialize",
                "icon": 3,
                "documentation": "The amInitialize function creates and opens an AMI session. The output parameter, hsession, is a session handle that is valid until the session is terminated. This function returns a status code indicating success, warning, or failure.",
                "detail": "amInitialize($hSession, $appName, $policyName, $reasonCode)",
                "snippet": "amInitialize(${1:hSession}, ${2:appName}, ${3:policyName}, ${4:reasonCode})"
            },
            {
                "key": "amReceiveMsg",
                "icon": 3,
                "documentation": "The amReceiveMsg function receives a message sent by the amSendMsg function. For detailed information about amReceiveMsg, see UniBasic Extensions.",
                "detail": "amReceiveMsg($hSession, $receiverName, $policyName, $selMsgName, $maxMsgLen, $dataLen, $data, $rcvMsgName, $reasonCode)",
                "snippet": "amReceiveMsg(${1:hSession}, ${2:receiverName}, ${3:policyName}, ${4:selMsgName}, ${5:maxMsgLen}, ${6:dataLen}, ${7:data}, ${8:rcvMsgName}, ${9:reasonCode})"
            },
            {
                "key": "amReceiveRequest",
                "icon": 3,
                "documentation": "The amReceiveRequest function receives a request message. For detailed information about this function, see UniBasic Extensions.",
                "detail": "amReceiveRequest($hSession, $receiverName, $policyName, $maxMsgLen, $dataLen, $data, $rcvMsgName, $senderName, $reasonCode)",
                "snippet": "amReceiveRequest(${1:hSession}, ${2:receiverName}, ${3:policyName}, ${4:maxMsgLen}, ${5:dataLen}, ${6:data}, ${7:rcvMsgName}, ${8:senderName}, ${9:reasonCode})"
            },
            {
                "key": "amSendMsg",
                "icon": 3,
                "documentation": "The amSendMsg function sends a datagram (send and forget) message. For detailed information about this function, see UniBasic Extensions.",
                "detail": "amSendMsg($hSession, $senderName, $policyName, $data, $sndMsgName, $reasonCode)",
                "snippet": "amSendMsg(${1:hSession}, ${2:senderName}, ${3:policyName}, ${4:data}, ${5:sndMsgName}, ${6:reasonCode})"
            },
            {
                "key": "amSendRequest",
                "icon": 3,
                "documentation": "The amSendRequest function sends a request message.",
                "detail": "amSendRequest($hSession, $senderName, $policyName, $data, $sndMsgName, $reasonCode)",
                "snippet": "amSendRequest(${1:hSession}, ${2:senderName}, ${3:policyName}, ${4:data}, ${5:sndMsgName}, ${6:reasonCode})"
            },
            {
                "key": "amSendResponse",
                "icon": 3,
                "documentation": "The amSendResponse function sends a request message.",
                "detail": "amSendResponse($hSession, $senderName, $policyName, $rcvMsgName, $data, $sndMsgName, $reasonCode)",
                "snippet": "amSendResponse(${1:hSession}, ${2:senderName}, ${3:policyName}, ${4:rcvMsgName}, ${5:data}, ${6:sndMsgName}, ${7:reasonCode})"
            },
            {
                "key": "amTerminate",
                "icon": 3,
                "documentation": "The amTerminate function closes a session.",
                "detail": "amTerminate($hSession, $policyName, $reasonCode)",
                "snippet": "amTerminate(${1:hSession}, ${2:policyName}, ${3:reasonCode})"
            },
            {
                "key": "analyzeCertificate",
                "icon": 3,
                "documentation": "The analyzeCertficate function decodes a certificate and inputs plain text in the result parameter. The result parameter then contains such information as the subject name, location, institute, issuer, public key, other extensions, and the signature of the issuer.",
                "detail": "analyzeCertificate($cert, $format, $result)",
                "snippet": "analyzeCertificate(${1:cert}, ${2:format}, ${3:result})"
            },
            {
                "key": "ASCII",
                "icon": 3,
                "documentation": "The UniBasic ASCII function converts a string in EBCDIC format to the corresponding ASCII values. Even though the ASCII function works with data in any format, its results are meaningful only when it is applied to EBCDIC data.",
                "detail": "ASCII($expr)",
                "snippet": "ASCII(${1:expr})"
            },
            {
                "key": "ASIN",
                "icon": 3,
                "documentation": "The UniBasic ASIN function returns the trigonometric arc sine (inverse sine) of a numeric expression. expr must be a value between -1 and +1. ASIN returns a value expressed as the degree of the arc sine of the input, which ranges from -90 to +90. If expr evaluates to a value outside the range of -1 and +1, then UniData displays an error message and returns 0 as the result.",
                "detail": "ASIN($expr)",
                "snippet": "ASIN(${1:expr})"
            },
            {
                "key": "ASSIGN",
                "icon": 14,
                "documentation": "The UniBasic ASSIGN command redefines some system-level parameters. The value in option changes to the value you specify with expr.",
                "detail": "ASSIGN $expr TO SYSTEM($opt)",
                "snippet": "ASSIGN ${1:expr} TO SYSTEM(${2:opt})"
            },
            {
                "key": "ATAN",
                "icon": 3,
                "documentation": "The UniBasic ATAN function returns the trigonometric arc tangent (inverse tangent) of a numeric expression expr in degrees",
                "detail": "ATAN($expr)",
                "snippet": "ATAN(${1:expr})"
            },
            {
                "key": "BITAND",
                "icon": 3,
                "documentation": "The UniBasic BITAND function performs the bit-wise AND logical function on the arguments num.expr1 and num.expr2.",
                "detail": "BITAND($expr1, $expr2)",
                "snippet": "BITAND(${1:expr1}, ${2:expr2})"
            },
            {
                "key": "BITNOT",
                "icon": 3,
                "documentation": "The UniBasic BITNOT function performs the bit-wise NOT logical function on the argument num.expr.",
                "detail": "BITNOT($expr)",
                "snippet": "BITNOT(${1:expr})"
            },
            {
                "key": "BITOR",
                "icon": 3,
                "documentation": "The UniBasic BITOR function performs the bit-wise OR logical function on the arguments num.expr1 and num.expr2.",
                "detail": "BITOR($expr1, $expr2)",
                "snippet": "BITOR(${1:expr1}, ${2:expr2})"
            },
            {
                "key": "BITXOR",
                "icon": 3,
                "documentation": "The UniBasic BITXOR function performs the bit-wise XOR logical function on the arguments num.expr1 and num.expr2.",
                "detail": "BITXOR($expr1, $expr2)",
                "snippet": "BITXOR(${1:expr1}, ${2:expr2})"
            },
            {
                "key": "BPIOCP",
                "icon": 14,
                "documentation": "The UniBasic BPIOCP command turns automatic pagination on.",
                "detail": "BPIOCP",
                "snippet": "BPIOCP"
            },
            {
                "key": "BPIOCPN",
                "icon": 14,
                "documentation": "The UniBasic BPIOCPN command turns off automatic pagination. With pagination off, printing to a terminal does not pause at the bottom of each screen display.",
                "detail": "BPIOCPN",
                "snippet": "BPIOCPN"
            },
            {
                "key": "BREAK",
                "icon": 14,
                "documentation": "The UniBasic BREAK command enables or disables the interrupt key to exit a program to the \u2018!\u2019 debugger prompt and displays the current program line number. The program must have been compiled and run with debugger options.",
                "detail": "BREAK $1",
                "snippet": "BREAK $1"
            },
            {
                "key": "BYTELEN",
                "icon": 3,
                "documentation": "The UniBasic BYTELEN function returns the number of bytes required to store a character. From one to four bytes could be required.",
                "detail": "BYTELEN($expr)",
                "snippet": "BYTELEN(${1:expr})"
            },
            {
                "key": "CALCULATE",
                "icon": 3,
                "documentation": "The UniBasic CALCULATE or {} (braces) function executes a virtual attribute. The dictionary.item must be a valid virtual attribute within the dictionary previously opened to the @DICT variable with an OPEN statement.",
                "detail": "CALCULATE($dictitem)",
                "snippet": "CALCULATE(${1:dictitem})"
            },
            {
                "key": "CALL",
                "icon": 14,
                "documentation": "The UniBasic CALL command transfers program control to an external subroutine.",
                "detail": "CALL $subroutine_name($arguments)",
                "snippet": "CALL ${1:subroutine_name}(${2:arguments})"
            },
            {
                "key": "CALLC",
                "icon": 14,
                "documentation": "The UniBasic CALLC command transfers program control to an external function (c.sub.name). The second form of the syntax calls a function whose name is stored in a UniBasic variable (@var). The program could pass back return values in variables. CALLC arguments can be simple variables or complex expressions, but not arrays.",
                "detail": "CALLC $subname($args)",
                "snippet": "CALLC ${1:subname}(${2:args})"
            },
            {
                "key": "CAT",
                "icon": 0,
                "documentation": "The UniBasic CAT arithmetic operator concatenates expr1 to expr2.",
                "detail": "$expr1 CAT $expr2",
                "snippet": "${1:expr1} CAT ${2:expr2}"
            },
            {
                "key": "CATS",
                "icon": 3,
                "documentation": "The UniBasic CATS function concatenates array1 to array2. Each element of array2 is concatenated to its corresponding element in array1.",
                "detail": "CATS($arr1, $arr2)",
                "snippet": "CATS(${1:arr1}, ${2:arr2})"
            },
            {
                "key": "CHAIN",
                "icon": 14,
                "documentation": "The UniBasic CHAIN command terminates the current UniBasic program and executes the ECL command str.expr. CHAIN performs a function similar to the EXECUTE statement, except that control is not returned to the original program. UniData treats str.expr as a command you type at the ECL colon (:) prompt. If str.exp executes a UniBasic program, variables could be passed through common areas, but all other variables are reinitialized when the new program begins.",
                "detail": "CHAIN $expr",
                "snippet": "CHAIN ${1:expr}"
            },
            {
                "key": "CHANGE",
                "icon": 3,
                "documentation": "The UniBasic CHANGE function replaces all occurrences of old.substring in string with new.substring. If old.substring is an empty string, the system does not change string. CHANGE supports multibyte languages.",
                "detail": "CHANGE($string, $old, $new)",
                "snippet": "CHANGE(${1:string}, ${2:old}, ${3:new})"
            },
            {
                "key": "CHAR",
                "icon": 3,
                "documentation": "The UniBasic CHAR function changes a numeric expression to its ASCII character string equivalent. expr can be a constant, variable, numeric function, or any combination of these. expr must evaluate to a positive number from 0 to 255 (the range of ASCII character codes). CHAR supports multibyte languages.",
                "detail": "CHAR($expr)",
                "snippet": "CHAR(${1:expr})"
            },
            {
                "key": "CHARLEN",
                "icon": 3,
                "documentation": "The UniBasic CHARLEN function returns the number of characters in a character string. A multibyte character could require from one to four bytes to encode.",
                "detail": "CHARLEN($str)",
                "snippet": "CHARLEN(${1:str})"
            },
            {
                "key": "CHARS",
                "icon": 3,
                "documentation": "The UniBasic CHARS function changes a numeric value in array to its ASCII character string equivalent. array elements can contain a constant, variable, numeric function, or any combination of these. array elements must evaluate to a positive number 0\u2013255 (the range of ASCII character codes). CHARS supports multibyte languages.",
                "detail": "CHARS($DynArr)",
                "snippet": "CHARS(${1:DynArr})"
            },
            {
                "key": "CHECKSUM",
                "icon": 3,
                "documentation": "The UniBasic CHECKSUM function computes the positional checksum of the string str.expr you specify. The positional checksum is the sum of the ASCII value of each character in the string, multiplied by the position of the character in the string.",
                "detail": "CHECKSUM($expr)",
                "snippet": "CHECKSUM(${1:expr})"
            },
            {
                "key": "CLEAR",
                "icon": 14,
                "documentation": "The UniBasic CLEAR command sets the values of all variables stored in local memory to 0, including all array elements. Variables assigned to named or unnamed common areas are not affected.",
                "detail": "CLEAR",
                "snippet": "CLEAR"
            },
            {
                "key": "CLEARCOMMON",
                "icon": 14,
                "documentation": "The UniBasic CLEARCOMMON command sets all variables in a named common area to zero. If you do not specify common.label, CLEARCOMMON sets all variables specified in the unnamed common area to zero.",
                "detail": "CLEARCOMMON $1",
                "snippet": "CLEARCOMMON $1"
            },
            {
                "key": "CLEARDATA",
                "icon": 14,
                "documentation": "The UniBasic CLEARDATA command clears data stored by any executed DATA statements. Subsequent INPUT statements request data from the keyboard because the input queue is empty.",
                "detail": "CLEARDATA",
                "snippet": "CLEARDATA"
            },
            {
                "key": "CLEARFILE",
                "icon": 14,
                "documentation": "The UniBasic CLEARFILE command clears all records from a file, but does not delete the file itself.",
                "detail": "CLEARFILE $variable",
                "snippet": "CLEARFILE ${1:variable}"
            },
            {
                "key": "CLEARINPUT",
                "icon": 14,
                "documentation": "The UniBasic CLEARINPUT command clears the terminal type-ahead buffer so the next INPUT statement forces a response from the user.",
                "detail": "CLEARINPUT",
                "snippet": "CLEARINPUT"
            },
            {
                "key": "CLEARSELECT",
                "icon": 14,
                "documentation": "The UniBasic CLEARSELECT command clears active select lists. You can specify a particular ID list by specifying num.expr as 0 through 9. ALL clears all active select lists. If you do not specify a parameter, UniData clears the default ID list (zero). If you specify an ID list outside the valid range, a runtime error occurs.",
                "detail": "CLEARSELECT $ListName",
                "snippet": "CLEARSELECT ${1:ListName}"
            },
            {
                "key": "CLEARSQL",
                "icon": 14,
                "documentation": "The UniBasic CLEARSQL command clears all active temporary tables that were created during the current session (for example, created with the EXECUTESQL command with a corresponding TO clause). If you do not specify file.name.expr, CLEARSQL clears all the UniData SQL file variables created during this UniBasic session.",
                "detail": "CLEARSQL $fileNameExpr",
                "snippet": "CLEARSQL ${1:fileNameExpr}"
            },
            {
                "key": "CLOSE",
                "icon": 14,
                "documentation": "The UniBasic CLOSE command closes a dictionary or data file.",
                "detail": "CLOSE $filevar",
                "snippet": "CLOSE ${1:filevar}"
            },
            {
                "key": "CLOSESEQ",
                "icon": 14,
                "documentation": "The UniBasic CLOSESEQ command closes a sequential file that you opened with the OPENSEQ or OSOPEN command. The CLOSESEQ command releases the exclusive file lock set by the OPENSEQ command. If any new lines (sequential records) were added to the file, UniData writes a new end-offile mark after the new lines.",
                "detail": "CLOSESEQ $filevar",
                "snippet": "CLOSESEQ ${1:filevar}"
            },
            {
                "key": "closeSocket",
                "icon": 3,
                "documentation": "Use the closeSocket() function to close a socket connection.",
                "detail": "closeSocket($socket_handle)",
                "snippet": "closeSocket(${1:socket_handle})"
            },
            {
                "key": "CLOSEXMLDATA",
                "icon": 3,
                "documentation": "The CLOSEXMLDATA function closes the dynamic array variable for an XML document.",
                "detail": "CLOSEXMLDATA(xml_data_handle)",
                "snippet": "CLOSEXMLDATA(${1:xml_data_handle})"
            },
            {
                "key": "COL1",
                "icon": 3,
                "documentation": "The UniBasic COL1 function returns the column position preceding a substring found by the FIELD function. The COL1 function has no arguments. If you do not execute the FIELD function before executing COL1, the function returns 0. COL1 supports multibyte languages.",
                "detail": "COL1()",
                "snippet": "COL1()"
            },
            {
                "key": "COL2",
                "icon": 3,
                "documentation": "The UniBasic COL2 function returns the column position following a substring found by the FIELD function. The COL2 function has no arguments. If you do not execute the FIELD before executing COL2, the function returns a zero. COL2 supports multibyte languages.",
                "detail": "COL2()",
                "snippet": "COL2()"
            },
            {
                "key": "COMMON",
                "icon": 14,
                "documentation": "The UniBasic COMMON command stores variables that can be accessed from any subroutine or program. You can declare one unnamed common area and multiple named common areas. The number of variables that a common area can contain depends on the virtual memory of your system.",
                "detail": "COMMON $1",
                "snippet": "COMMON $1"
            },
            {
                "key": "CONVERT Function",
                "icon": 3,
                "documentation": "The UniBasic CONVERT function changes all occurrences of the substring expr1 in expr3 to the string expr2. The system compares each character of the replacement string expr2 and, if necessary, replaces each character of the target string expr1 on an individual basis. UniBasic does not compare and insert strings as a whole. CONVERT supports multibyte languages.",
                "detail": "CONVERT($fromchars, $tostring, $var)",
                "snippet": "CONVERT(${1:fromchars}, ${2:tostring}, ${3:var})"
            },
            {
                "key": "CONVERT Statement",
                "icon": 14,
                "documentation": "The UniBasic CONVERT command changes all occurrences of the substring expr1 in var to the string expr2. UniBasic compares each character of the replacement string expr2 and, if necessary, replaces each character of the target string expr1 on an individual basis. UniBasic does not compare and insert strings as a whole. CONVERT supports multibyte languages.",
                "detail": "CONVERT $fromchars TO $tostring IN $var",
                "snippet": "CONVERT ${1:fromchars} TO ${2:tostring} IN ${3:var}"
            },
            {
                "key": "COS",
                "icon": 3,
                "documentation": "The UniBasic COS function returns the trigonometric cosine of a numeric expression.",
                "detail": "COS($expr)",
                "snippet": "COS(${1:expr})"
            },
            {
                "key": "COUNT",
                "icon": 3,
                "documentation": "The UniBasic COUNT function returns the number of times a substring appears within a string. The string you want to search, str.expr1, must be longer than the substring str.expr2. After str.expr2 is found, the system searches the string again with the new starting point after the entire first occurrence of str.expr2. If str.expr2 is not found, the COUNT function returns 0. COUNT supports multibyte languages.",
                "detail": "COUNT($expr, $delimiter)",
                "snippet": "COUNT(${1:expr}, ${2:delimiter})"
            },
            {
                "key": "COUNTS",
                "icon": 3,
                "documentation": "The UniBasic COUNTS function returns the number of times a substring appears within each element of an array. The elements in the array you want to search, expr, must be longer than the substring str.expr. After str.expr is found, the system searches the array again with the new starting point after the entire first occurrence of str.expr. If str.expr is not found, COUNTS returns 0. COUNTS supports multibyte languages.",
                "detail": "COUNTS($dynamic_array, $substring)",
                "snippet": "COUNTS(${1:dynamic_array}, ${2:substring})"
            },
            {
                "key": "createCertificate",
                "icon": 3,
                "documentation": "The createCertificate function generates a certificate. The certificate can either be a selfsigned certificate as a root CA that you can use later to sign other certificates, or it can be a CA signed certificate. The generated certificate conforms to X509V3 standard.",
                "detail": "createCertificate($action, $req, $signKey, $keyPass, $CAcert, $days, $extensions, $certOut)",
                "snippet": "createCertificate(${1:action}, ${2:req}, ${3:signKey}, ${4:keyPass}, ${5:CAcert}, ${6:days}, ${7:extensions}, ${8:certOut})"
            },
            {
                "key": "createCertRequest",
                "icon": 3,
                "documentation": "The createCertRequest() function generates a PKCS #10 certificate request from a private key in PKCS #8 form and a set of user specified data. The request can be sent to a CA or used as a parameter to createCertificate() to obtain an X.509 public key certificate.",
                "detail": "createCertRequest($key, $inFormat, $keyLoc, $algorithm, $digest, $passPhrase, $subjectData, $outFile, $outFormat)",
                "snippet": "createCertRequest(${1:key}, ${2:inFormat}, ${3:keyLoc}, ${4:algorithm}, ${5:digest}, ${6:passPhrase}, ${7:subjectData}, ${8:outFile}, ${9:outFormat})"
            },
            {
                "key": "createRequest",
                "icon": 3,
                "documentation": "The createRequest function creates an HTTP request and returns a handle to the request.",
                "detail": "createRequest($URL, $http_method, $request_handle)",
                "snippet": "createRequest(${1:URL}, ${2:http_method}, ${3:request_handle})"
            },
            {
                "key": "createSecureRequest",
                "icon": 3,
                "documentation": "The createSecureRequest function behaves exactly the same as the createRequest() function, except for the fourth parameter, a handle to a security context, which is used to associate the security context with the request. If the URL does not start with \u201chttps\u201d the parameter is ignored. If the URL starts with \u201chttps\u201d but an invalid context handle or no handle is provided, the function aborts and returns with an error status.",
                "detail": "createSecureRequest($URL, $http_method, $request_handle, $security_context)",
                "snippet": "createSecureRequest(${1:URL}, ${2:http_method}, ${3:request_handle}, ${4:security_context})"
            },
            {
                "key": "createSecurityContext",
                "icon": 3,
                "documentation": "The createSecurityContext function creates a security context and returns a handle to the context.",
                "detail": "createSecurityContext($context, $version)",
                "snippet": "createSecurityContext(${1:context}, ${2:version})"
            },
            {
                "key": "CRT",
                "icon": 14,
                "documentation": "The UniBasic CRT command sends output to the display terminal regardless of the use of the PRINTER ON\/OFF command.",
                "detail": "CRT $expr",
                "snippet": "CRT ${1:expr}"
            },
            {
                "key": "CRT @",
                "icon": 14,
                "documentation": "The UniBasic CRT command sends output to the display terminal regardless of the use of the PRINTER ON\/OFF command.",
                "detail": "CRT @($col,$row): $expr",
                "snippet": "CRT @(${1:col},${2:row}): ${3:expr}"
            },
            {
                "key": "DATA",
                "icon": 14,
                "documentation": "The UniBasic DATA command places data in an input queue stored in @DATA. ASCII character 013 (CR) delimits elements in the queue. Each subsequent INPUT statement reads one element. @DATA is read-only.",
                "detail": "DATA $expr",
                "snippet": "DATA ${1:expr}"
            },
            {
                "key": "DATE",
                "icon": 3,
                "documentation": "The UniBasic DATE function returns the current system date in internal format. Internal format is the number of days after December 31, 1967.",
                "detail": "DATE()",
                "snippet": "DATE()"
            },
            {
                "key": "DBTOXML",
                "icon": 0,
                "documentation": "Creates an XML document from the UniData database.",
                "detail": "DBTOXML($xml_document, $doc_location, $u2xmap_file, $u2xmap_location, $condition, $status)",
                "snippet": "DBTOXML(${1:xml_document}, ${2:doc_location}, ${3:u2xmap_file}, ${4:u2xmap_location}, ${5:condition}, ${6:status})"
            },
            {
                "key": "DCOUNT",
                "icon": 3,
                "documentation": "The UniBasic DCOUNT function returns the number of substrings delimited by delim in a string. If str is an empty string, UniData returns 0. If str contains data but no delimiter, UniData returns 1. DCOUNT supports multibyte languages.",
                "detail": "DCOUNT($expr, $delimiter)",
                "snippet": "DCOUNT(${1:expr}, ${2:delimiter})"
            },
            {
                "key": "DEACTIVATEKEY",
                "icon": 14,
                "documentation": "Use the DEACTIVATEKEY command to deactivate a key or a wallet. This command is useful to deactivate keys to make your system more secure.",
                "detail": "DEACTIVATEKEY $keyid, $password ON $NFA_SERVER ON ERROR $err",
                "snippet": "DEACTIVATEKEY ${1:keyid}, ${2:password} ON ${3:NFA_SERVER} ON ERROR ${4:err}"
            },
            {
                "key": "DEBUG",
                "icon": 14,
                "documentation": "The UniBasic DEBUG command stops program execution, turns control over to the interactive UniBasic debugger, and then displays the debugger prompt (!). Pressing the interrupt key also gives control to the debugger.",
                "detail": "DEBUG",
                "snippet": "DEBUG"
            },
            {
                "key": "DEFFUN",
                "icon": 14,
                "documentation": "The UniBasic DEFFUN command declares a user-written function, making the function available in a UniBasic program. You must declare the function before you can use it in a program.",
                "detail": "DEFFUN $FuncName($args)",
                "snippet": "DEFFUN ${1:FuncName}(${2:args})"
            },
            {
                "key": "DEL",
                "icon": 14,
                "documentation": "The UniBasic DEL command deletes an attribute, value, or subvalue from a dynamic array. The corresponding delimiter is also removed.",
                "detail": "DEL $variable",
                "snippet": "DEL ${1:variable}"
            },
            {
                "key": "DELETE Function",
                "icon": 14,
                "documentation": "The UniBasic DELETE command deletes a record from a UniData file. In addition, the DELETE command releases any locks on the record that have been set by previous commands.",
                "detail": "DELETE($arr, $attr, $val, $subval)",
                "snippet": "DELETE(${1:arr}, ${2:attr}, ${3:val}, ${4:subval})"
            },
            {
                "key": "DELETE Statement",
                "icon": 14,
                "documentation": "The UniBasic DELETE command deletes a record from a UniData file. In addition, the DELETE command releases any locks on the record that have been set by previous commands.",
                "detail": "DELETE $filevar,$recordkey",
                "snippet": "DELETE ${1:filevar},${2:recordkey}"
            },
            {
                "key": "DELETELIST",
                "icon": 14,
                "documentation": "The UniBasic DELETELIST command deletes a saved select list.",
                "detail": "DELETELIST $expr",
                "snippet": "DELETELIST ${1:expr}"
            },
            {
                "key": "DELETEU",
                "icon": 14,
                "documentation": "The UniBasic DELETEU command deletes the specified record from a UniData file.",
                "detail": "DELETEU $filevar,$recordkey",
                "snippet": "DELETEU ${1:filevar},${2:recordkey}"
            },
            {
                "key": "DIM",
                "icon": 14,
                "documentation": "The UniBasic DIM command creates and determines the dimensions of a dimensioned array. You can specify arrays with one dimension (rows) or two dimensions (rows or rows, cols).",
                "detail": "DIM $variable($numbers)",
                "snippet": "DIM ${1:variable}(${2:numbers})"
            },
            {
                "key": "DIGEST",
                "icon": 3,
                "documentation": "The DIGEST function generates a message digest of supplied data. A message digest is the result of a one-way hash function (digest algorithm) performed on the message. Message digest has the unique properties that alight change in the input results in a significant difference in the resulting digest. Therefore, the probability of two different messages resulting in the same digest (collision) is very unlikely. It is also virtually impossible to reverse to the original message from a digest. Message digest is widely used for digital signatures and other purposes.",
                "detail": "DIGEST($algorithm, $data, $dataLoc, $result)",
                "snippet": "DIGEST(${1:algorithm}, ${2:data}, ${3:dataLoc}, ${4:result})"
            },
            {
                "key": "DIR",
                "icon": 3,
                "documentation": "The UniBasic DIR function returns the file size (in bytes), the last date and time the file was modified (in internal format), and the privileges for the file. UniData stores these values in the first four attributes of the return value.file.expr must evaluate to a file name at the operating system level. If you do not specify a path, UniData searches the current directory.",
                "detail": "DIR($filename)",
                "snippet": "DIR(${1:filename})"
            },
            {
                "key": "DISABLEDEC",
                "icon": 14,
                "documentation": "Use the DISABLEDEC command to turn off decryption on a file or fields you specify.",
                "detail": "DISABLEDEC $filename ON ERROR $err",
                "snippet": "DISABLEDEC ${1:filename} ON ERROR ${2:err}"
            },
            {
                "key": "DISPLAY",
                "icon": 14,
                "documentation": "DISPLAY is a synonym for the CRT command.",
                "detail": "DISPLAY $expr",
                "snippet": "DISPLAY ${1:expr}"
            },
            {
                "key": "DISPLAYWIDTH",
                "icon": 3,
                "documentation": "The UniBasic DISPLAYWIDTH function returns the number of bytes needed to display a string expression. For instance, the display width of English characters is one. In languages that use multibyte characters, the display width of a character can be 1, 2, 3, or 4 bytes, depending on the language and the character.",
                "detail": "DISPLAYWIDTH($str)",
                "snippet": "DISPLAYWIDTH(${1:str})"
            },
            {
                "key": "DOWNCASE",
                "icon": 3,
                "documentation": "The UniBasic DOWNCASE function converts all characters in a string (str.expr) to lowercase. Special characters, including the null value, are not converted by this function. DOWNCASE does not convert multibyte characters.",
                "detail": "DOWNCASE($expr)",
                "snippet": "DOWNCASE(${1:expr})"
            },
            {
                "key": "DQUOTE",
                "icon": 3,
                "documentation": "DQUOTE is a synonym for the QUOTE function.",
                "detail": "DQUOTE($expr)",
                "snippet": "DQUOTE(${1:expr})"
            },
            {
                "key": "DROUND",
                "icon": 3,
                "documentation": "The UniBasic DROUND function performs double-precision rounding on a value. Double-precision rounding uses two words to store a number, accommodating a larger number than in single-precision rounding, which stores each number in a single word.",
                "detail": "DROUND($value)",
                "snippet": "DROUND(${1:value})"
            },
            {
                "key": "EBCDIC",
                "icon": 3,
                "documentation": "The UniBasic EBCDIC function converts the ASCII data in expr to its corresponding EBCDIC values.",
                "detail": "EBCDIC($expr)",
                "snippet": "EBCDIC(${1:expr})"
            },
            {
                "key": "ECHO",
                "icon": 14,
                "documentation": "The UniBasic ECHO command controls whether characters display on the terminal screen as you type them on the keyboard.",
                "detail": "ECHO $expr",
                "snippet": "ECHO ${1:expr}"
            },
            {
                "key": "ENABLEDEC",
                "icon": 14,
                "documentation": "Use the ENABLEDEC command to activate decryption on a file or fields you specify.",
                "detail": "ENABLEDEC $filename ON ERROR $err",
                "snippet": "ENABLEDEC ${1:filename} ON ERROR ${2:err}"
            },
            {
                "key": "ENCODE",
                "icon": 3,
                "documentation": "The ENCODE() function performs data encoding on input data.",
                "detail": "ENCODE($algorithm, $action, $data, $dataLoc, $result, $resultLoc)",
                "snippet": "ENCODE(${1:algorithm}, ${2:action}, ${3:data}, ${4:dataLoc}, ${5:result}, ${6:resultLoc})"
            },
            {
                "key": "ENCRYPT",
                "icon": 3,
                "documentation": "The ENCRYPT() function performs symmetric encryption operations. You can call various block and stream symmetric ciphers through this function. The supported ciphers are listed in Security Features.",
                "detail": "ENCRYPT($algorithm, $action, $data, $dataLoc, $key, $keyLoc, $keyAction, $salt, $IV, $result, $resultLoc)",
                "snippet": "ENCRYPT(${1:algorithm}, ${2:action}, ${3:data}, ${4:dataLoc}, ${5:key}, ${6:keyLoc}, ${7:keyAction}, ${8:salt}, ${9:IV}, ${10:result}, ${11:resultLoc})"
            },
            {
                "key": "ENTER",
                "icon": 14,
                "documentation": "The UniBasic ENTER command passes control to the program you specify. It terminates the program that is passing control and executes the cataloged program. The ENTER command allows variables to pass through common areas, but all other variables are reinitialized when the new program begins.",
                "detail": "ENTER $name",
                "snippet": "ENTER ${1:name}"
            },
            {
                "key": "EQ",
                "icon": 0,
                "documentation": "The UniBasic EQ operator serves as an assignment operator and a relational operator.",
                "detail": "$expr1 EQ $expr2",
                "snippet": "${1:expr1} EQ ${2:expr2}"
            },
            {
                "key": "EQS",
                "icon": 3,
                "documentation": "The UniBasic EQS function compares each value in array1 to its corresponding value in array2. UniData returns an array with 1 in each position where values are equal, and 0 in each position for values that are not equal.",
                "detail": "EQS($array1, $array2)",
                "snippet": "EQS(${1:array1}, ${2:array2})"
            },
            {
                "key": "EQU",
                "icon": 14,
                "documentation": "The UniBasic EQU command replaces a constant with an array, function, number, string, or variable name when the program is compiled.",
                "detail": "EQU $constant1 TO $value1",
                "snippet": "EQU ${1:constant1} TO ${2:value1}"
            },
            {
                "key": "EREPLACE",
                "icon": 3,
                "documentation": "The EREPLACE function replaces substring in expression with another substring. If you do not specify occurrence, each occurrence of substring is replaced.",
                "detail": "EREPLACE($expr, $substring, $replacement, $occurrence, $begin)",
                "snippet": "EREPLACE(${1:expr}, ${2:substring}, ${3:replacement}, ${4:occurrence}, ${5:begin})"
            },
            {
                "key": "EXECUTE",
                "icon": 14,
                "documentation": "The UniBasic EXECUTE command executes an ECL or UniData SQL command from within a UniBasic program.",
                "detail": "EXECUTE $expr",
                "snippet": "EXECUTE ${1:expr}"
            },
            {
                "key": "EXECUTESQL",
                "icon": 14,
                "documentation": "The UniBasic EXECUTESQL command executes a UniData SQL statement within a UniBasic program.",
                "detail": "EXECUTESQL $str",
                "snippet": "EXECUTESQL ${1:str}"
            },
            {
                "key": "EXIT",
                "icon": 14,
                "documentation": "The UniBasic EXIT command terminates a FOR\/NEXT or LOOP\/REPEAT structure and transfers control to the following statement. As with the CONTINUE statement, EXIT forms well structured programs.",
                "detail": "EXIT",
                "snippet": "EXIT"
            },
            {
                "key": "EXP",
                "icon": 3,
                "documentation": "The UniBasic EXP function raises e to the power of expr.",
                "detail": "EXP($expr)",
                "snippet": "EXP(${1:expr})"
            },
            {
                "key": "EXTRACT",
                "icon": 3,
                "documentation": "The UniBasic EXTRACT function retrieves data from an attribute, value, or subvalue in a dynamic array. The dynamic array itself remains unchanged. You can use either of the preceding syntax forms.",
                "detail": "EXTRACT($DynArr, $attr)",
                "snippet": "EXTRACT(${1:DynArr}, ${2:attr})"
            },
            {
                "key": "FIELD",
                "icon": 3,
                "documentation": "The UniBasic FIELD function treats a string as an array, with fields delimited by any specified ASCII character (for example, spaces, commas, or periods), and returns a substring or group of substrings. FIELD supports multibyte languages.",
                "detail": "FIELD($string, $delimiter, $field, $repexpr)",
                "snippet": "FIELD(${1:string}, ${2:delimiter}, ${3:field}, ${4:repexpr})"
            },
            {
                "key": "FIELDSTORE",
                "icon": 3,
                "documentation": "The UniBasic FIELDSTORE function inserts an expression and an appropriate delimiter into a string.",
                "detail": "FIELDSTORE($string, $delimiter, $i, $opt, $newstring)",
                "snippet": "FIELDSTORE(${1:string}, ${2:delimiter}, ${3:i}, ${4:opt}, ${5:newstring})"
            },
            {
                "key": "FIELDWRITE",
                "icon": 14,
                "documentation": "The UniBasic FIELDWRITE command allows you to update the specified fields in an existing record and releases locks set by the same process. For those using replication, FIELDWRITE generates fieldlevel replication logs. This command is similar to WRITEV, but it is not a replacement for WRITEV.",
                "detail": "FIELDWRITE $recordexpr ON $filevar, $recordid, $attrlist ON ERROR $err",
                "snippet": "FIELDWRITE ${1:recordexpr} ON ${2:filevar}, ${3:recordid}, ${4:attrlist} ON ERROR ${5:err}"
            },
            {
                "key": "FIELDWRITEU",
                "icon": 14,
                "documentation": "The UniBasic FIELDWRITEU command allows you to update the specified fields in an existing record without releasing locks. FIELDWRITEU writes regardless of lock status. For those using replication, FIELDWRITEU generates field-level replication logs. This command is similar to WRITEVU, but it is not a replacement for WRITEVU.",
                "detail": "FIELDWRITEU $recordexpr ON $filevar, $recordid, $attrlist ON ERROR $err",
                "snippet": "FIELDWRITEU ${1:recordexpr} ON ${2:filevar}, ${3:recordid}, ${4:attrlist} ON ERROR ${5:err}"
            },
            {
                "key": "FILEINFO",
                "icon": 3,
                "documentation": "The FILEINFO function returns information about the configuration of a file.",
                "detail": "FILEINFO($file_variable, $code)",
                "snippet": "FILEINFO(${1:file_variable}, ${2:code})"
            },
            {
                "key": "FILELOCK",
                "icon": 14,
                "documentation": "The UniBasic FILELOCK command locks the dictionary or data portion of a file against access by READL, READU, READVU, MATREADL, MATREADU, MATWRITEU, WRITEU, and WRITEVU statements. Other file input\/output commands ignore FILELOCK.",
                "detail": "FILELOCK filevar LOCKED $lock_statements ON ERROR $error_statements",
                "snippet": "FILELOCK filevar LOCKED ${1:lock_statements} ON ERROR ${2:error_statements}"
            },
            {
                "key": "FILEUNLOCK",
                "icon": 14,
                "documentation": "The UniBasic FILEUNLOCK command unlocks a file previously locked with a FILELOCK command.",
                "detail": "FILEUNLOCK $file_variable ON ERROR $statements",
                "snippet": "FILEUNLOCK ${1:file_variable} ON ERROR ${2:statements}"
            },
            {
                "key": "FIND",
                "icon": 14,
                "documentation": "The UniBasic FIND command determines the position of the given expression in a dynamic array. FIND returns the attribute, value, and subvalue position of the found string. The expression must match the entire array element to make a match.",
                "detail": "FIND $expr1 IN $Var1 SETTING $Var2 THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "FIND ${1:expr1} IN ${2:Var1} SETTING ${3:Var2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "FINDSTR",
                "icon": 14,
                "documentation": "The UniBasic FINDSTR command determines the position of a given substring in a dynamic array. FINDSTR supports multibyte languages.",
                "detail": "FINDSTR $expr1 IN $Var1 SETTING $Var2 THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "FINDSTR ${1:expr1} IN ${2:Var1} SETTING ${3:Var2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "FLUSH",
                "icon": 14,
                "documentation": "The FLUSH command flushes output to the terminal when UDT.OPTIONS 46 is on.",
                "detail": "FLUSH",
                "snippet": "FLUSH"
            },
            {
                "key": "FMT",
                "icon": 3,
                "documentation": "The UniBasic FMT function formats data in expr for display purposes. FMT can format a dynamic array that contains multivalues. The statement can be no longer than 2,046 characters.",
                "detail": "FMT($var, $code)",
                "snippet": "FMT(${1:var}, ${2:code})"
            },
            {
                "key": "FOOTING",
                "icon": 14,
                "documentation": "The UniBasic FOOTING command causes the specified string to print or display at the bottom of each page of a report. You can specify a footer of any length. The ECL LIMIT command has no effect on this command.",
                "detail": "FOOTING $expr",
                "snippet": "FOOTING ${1:expr}"
            },
            {
                "key": "FORMLIST",
                "icon": 14,
                "documentation": "The UniBasic FORMLIST command creates an active select list from a dynamic array. FORMLIST uses the attribute marks in dynamic.array.var to create a select list that you can use with READNEXT statements or other list processing commands such as external LIST statements.",
                "detail": "FORMLIST $dynarr TO $listno",
                "snippet": "FORMLIST ${1:dynarr} TO ${2:listno}"
            },
            {
                "key": "FOR\/NEXT",
                "icon": 14,
                "documentation": "The UniBasic FOR\/NEXT command executes statements repeatedly while incrementing a variable over a range until it reaches the end of the range, or until the condition in the WHILE or UNTIL clause is achieved. You can nest FOR\/NEXT constructions. Each FOR statement must end with a NEXT statement.",
                "detail": "FOR $1 = $2 To $3\n$4\nNEXT $1",
                "snippet": "FOR $1 = $2 To $3\n$4\nNEXT $5"
            },
            {
                "key": "FOR\/NEXT STEP",
                "icon": 14,
                "documentation": "The UniBasic FOR\/NEXT command executes statements repeatedly while incrementing a variable over a range until it reaches the end of the range, or until the condition in the WHILE or UNTIL clause is achieved. You can nest FOR\/NEXT constructions. Each FOR statement must end with a NEXT statement.",
                "detail": "FOR $1 = $2 To $3 STEP $4\n$5\nNEXT $1",
                "snippet": "FOR $1 = $2 To $3 STEP $4\n$5\nNEXT $6"
            },
            {
                "key": "FUNCTION",
                "icon": 14,
                "documentation": "The UniBasic FUNCTION command begins the definition of a user-written function. The FUNCTION command must be the first noncomment line in the file, which must be cataloged locally or globally.",
                "detail": "FUNCTION $name($arguments)\n\t$statements\nRETURN $var",
                "snippet": "FUNCTION ${1:name}(${2:arguments})\n\t${3:statements}\nRETURN ${4:var}"
            },
            {
                "key": "GARBAGECOLLECT",
                "icon": 14,
                "documentation": "The UniBasic GARBAGECOLLECT command releases all reserved but nonactive memory allocated for UniBasic variables.",
                "detail": "GARBAGECOLLECT",
                "snippet": "GARBAGECOLLECT"
            },
            {
                "key": "generateKey",
                "icon": 3,
                "documentation": "The generateKey() function generates a public key cryptography key pair and encrypts the private key. You should then put it into an external key file protected by the provided pass phrase. UniData SSL sessions can use the protected private key later to secure communication. The public key will not be encrypted.",
                "detail": "generateKey($priveKey, $pubKey, $format, $keyLoc, $algorithm, $keyLength, $passPhrase, $paramFile)",
                "snippet": "generateKey(${1:priveKey}, ${2:pubKey}, ${3:format}, ${4:keyLoc}, ${5:algorithm}, ${6:keyLength}, ${7:passPhrase}, ${8:paramFile})"
            },
            {
                "key": "GES",
                "icon": 3,
                "documentation": "The UniBasic GES function compares each value in array1 to its corresponding value in array2. UniData returns an array with 1 in each position where the value in array1 is greater than or equal to the value in the corresponding position in array2. UniData returns 0 in each position for values that are less than array2.",
                "detail": "GES($array1, $array2)",
                "snippet": "GES(${1:array1}, ${2:array2})"
            },
            {
                "key": "GET",
                "icon": 14,
                "documentation": "The UniBasic GET command receives unprompted input from an attached line. UniData accepts all control characters, including the carriage return and line feed as input characters. All data read from the attached line is placed in var. GET supports multibyte languages.",
                "detail": "GET $Var FROM $lineexpr THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "GET ${1:Var} FROM ${2:lineexpr} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "getCipherSuite",
                "icon": 3,
                "documentation": "The getCipherSuite() function obtains information about supported cipher suites, their version, usage, strength and type for the security context you specify.",
                "detail": "getCipherSuite($context, $ciphers)",
                "snippet": "getCipherSuite(${1:context}, ${2:ciphers})"
            },
            {
                "key": "GETENV",
                "icon": 3,
                "documentation": "The UniBasic GETENV function returns the contents of the UNIX, or Windows platform environment variable. If you include the environment variable explicitly (as opposed to including it in a variable), you must enclose it in quotation marks.",
                "detail": "GETENV($variable)",
                "snippet": "GETENV(${1:variable})"
            },
            {
                "key": "getHTTPDefault",
                "icon": 3,
                "documentation": "The getHTTPDefault function returns the default values of the HTTP settings.",
                "detail": "getHTTPDefault($option, $value)",
                "snippet": "getHTTPDefault(${1:option}, ${2:value})"
            },
            {
                "key": "getIpv",
                "icon": 3,
                "documentation": "The getIpv function, without an option, returns the current IPv setting. If a network choice is entered as an option, it returns only that network\u2019s IPv setting.",
                "detail": "getIpv($opt, $sockettype)",
                "snippet": "getIpv(${1:opt}, ${2:sockettype})"
            },
            {
                "key": "GETLIST",
                "icon": 14,
                "documentation": "The UniBasic GETLIST command restores a select list from a saved list.",
                "detail": "GETLIST $listname TO $listnum SETTING $cntvar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "GETLIST ${1:listname} TO ${2:listnum} SETTING ${3:cntvar} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "GETPTR",
                "icon": 3,
                "documentation": "The UniBasic GETPTR function returns a string variable containing the values of the current printer settings for the unit.no specified.",
                "detail": "GETPTR($unitnum)",
                "snippet": "GETPTR(${1:unitnum})"
            },
            {
                "key": "GETPU",
                "icon": 3,
                "documentation": "The UniBasic GETPU function returns the full path of the current print or hold file ID created by the current user process. unit.number is the number of the logical printer unit.",
                "detail": "GETPU($unit)",
                "snippet": "GETPU(${1:unit})"
            },
            {
                "key": "GETQUEUE",
                "icon": 3,
                "documentation": "The UniBasic GETQUEUE function returns a dynamic array containing information about all records currently locked and waiting to be released.",
                "detail": "GETQUEUE()",
                "snippet": "GETQUEUE()"
            },
            {
                "key": "GETREADU",
                "icon": 14,
                "documentation": "The UniBasic GETREADU function returns a dynamic array containing information about all records that have been locked by any UniBasic or ECL command that updates any record.",
                "detail": "GETREADU()",
                "snippet": "GETREADU()"
            },
            {
                "key": "getResponseHeader",
                "icon": 3,
                "documentation": "This function gets a specific response header value from response headers returned by submitRequest(). It can be used to query if a specific header, for example, Content-encoding, is present in the response.",
                "detail": "getResponseHeader($request_handle, $header_name, $header_value)",
                "snippet": "getResponseHeader(${1:request_handle}, ${2:header_name}, ${3:header_value})"
            },
            {
                "key": "getSocketErrorMessage",
                "icon": 3,
                "documentation": "Use the getSocketErrorMessage() function to translate an error code into a text error message.",
                "detail": "getSocketErrorMessage($errCode, $errMsg)",
                "snippet": "getSocketErrorMessage(${1:errCode}, ${2:errMsg})"
            },
            {
                "key": "getSocketInformation",
                "icon": 3,
                "documentation": "Use the getSocketInformation() function to obtain information about a socket connection.",
                "detail": "getSocketInformation($socket_handle, $self_ or_ peer, $socket_info)",
                "snippet": "getSocketInformation(${1:socket_handle}, ${2:self_} or_ peer, ${3:socket_info})"
            },
            {
                "key": "getSocketOptions",
                "icon": 3,
                "documentation": "The getSocketOptions() function gets the current value for a socket option associated with a socket of any type.",
                "detail": "getSocketOptions($socket_handle, $options)",
                "snippet": "getSocketOptions(${1:socket_handle}, ${2:options})"
            },
            {
                "key": "GETUSERGROUP",
                "icon": 3,
                "documentation": "For UNIX, the UniBasic GETUSERGROUP function returns the group number for the user ID you specify by uid. For Windows platforms, it returns 0.",
                "detail": "GETUSERGROUP($uid)",
                "snippet": "GETUSERGROUP(${1:uid})"
            },
            {
                "key": "GETUSERID",
                "icon": 3,
                "documentation": "The UniBasic GETUSERID function returns the user ID for a user name. For UNIX, this is the systemrecognized user ID. For Windows platforms, the returned user ID is meaningful in UniData only.",
                "detail": "GETUSERID($username)",
                "snippet": "GETUSERID(${1:username})"
            },
            {
                "key": "GETUSERNAME",
                "icon": 3,
                "documentation": "The UniBasic GETUSERNAME function returns the user name for a user ID. To obtain the ID of the current user, use the UniBasic @UID variable (or, for UNIX, enter \u201cid\u201d at the UNIX prompt). After you obtain the user ID, you can specify it explicitly in the GETUSERNAME function.",
                "detail": "GETUSERNAME($uid)",
                "snippet": "GETUSERNAME(${1:uid})"
            },
            {
                "key": "GOSUB",
                "icon": 14,
                "documentation": "The UniBasic GOSUB command transfers program control to an internal subroutine. UniData requires a valid statement label. Control returns to the main program when the RETURN statement is encountered in the subroutine.",
                "detail": "GOSUB $label",
                "snippet": "GOSUB ${1:label}"
            },
            {
                "key": "GROUP",
                "icon": 3,
                "documentation": "The UniBasic GROUP function extracts the number of continuous groups you specify from the given string.",
                "detail": "GROUP($subject, $delimiter, $first_field, $num_to_extract)",
                "snippet": "GROUP(${1:subject}, ${2:delimiter}, ${3:first_field}, ${4:num_to_extract})"
            },
            {
                "key": "GROUPSTORE",
                "icon": 14,
                "documentation": "The UniBasic GROUPSTORE command inserts a given substring or portion of a substring into a string, and replaces all, part, or none of the string. The string can be delimited by the single character delimiter. The unit of replacement is called an element in this section.",
                "detail": "GROUPSTORE $repstr IN $str USING $i, $n",
                "snippet": "GROUPSTORE ${1:repstr} IN ${2:str} USING ${3:i}, ${4:n}"
            },
            {
                "key": "GTS",
                "icon": 3,
                "documentation": "The UniBasic GTS function compares each value in array1 to its corresponding value in array2. UniData returns an array with 1 in each position where the value in array1 is greater than the value in the corresponding position in array2, and 0 in each position for values that are less than array2.",
                "detail": "GTS($arr1, $arr2)",
                "snippet": "GTS(${1:arr1}, ${2:arr2})"
            },
            {
                "key": "HASH",
                "icon": 3,
                "documentation": "The UniBasic HASH function determines to which group a particular record key is hashed, depending on the modulo and the file type. HASH returns the group number in which a record with a key of rec.key is stored. HASH includes a file type parameter.",
                "detail": "HASH($reckey, $modulo, $type)",
                "snippet": "HASH(${1:reckey}, ${2:modulo}, ${3:type})"
            },
            {
                "key": "HEADING",
                "icon": 14,
                "documentation": "The UniBasic HEADING command prints a string you specify at the top of each report page on the current print device.",
                "detail": "HEADING $expr",
                "snippet": "HEADING ${1:expr}"
            },
            {
                "key": "HMAC function",
                "icon": 3,
                "documentation": "HMAC (keyed-Hash Message Authentication Code) is a specific construction for calculating a message authentication code (MAC) involving a cryptographic hash function in combination with a secret key.",
                "detail": "HMAC($hmacAlg, $hmacKey, $hmacData, $outFormat)",
                "snippet": "HMAC(${1:hmacAlg}, ${2:hmacKey}, ${3:hmacData}, ${4:outFormat})"
            },
            {
                "key": "HUSH",
                "icon": 14,
                "documentation": "The UniBasic HUSH command enables or disables terminal output.",
                "detail": "HUSH $expr",
                "snippet": "HUSH ${1:expr}"
            },
            {
                "key": "ICONV",
                "icon": 3,
                "documentation": "The UniBasic ICONV function converts string or numeric data to internal representation format based on conversion codes. ICONV supports multibyte languages. If the input value or conversion code is invalid, UniData returns the input value.",
                "detail": "ICONV($subject, $convcode)",
                "snippet": "ICONV(${1:subject}, ${2:convcode})"
            },
            {
                "key": "ICONVS",
                "icon": 3,
                "documentation": "The UniBasic ICONVS function converts string or numeric data from display format to internal format, based on a conversion code, for each element of a dynamic array. If the input value or conversion code is invalid, UniData returns the input value.",
                "detail": "ICONVS($DynArr, $conversion)",
                "snippet": "ICONVS(${1:DynArr}, ${2:conversion})"
            },
            {
                "key": "IF Then",
                "icon": 14,
                "documentation": "The UniBasic IF\/THEN\/ELSE command executes one of two blocks of statements based on a conditional expression. If expr is true, UniData executes the first group of statements. If expr is false, UniData executes the second group of statements.",
                "detail": "IF $1 THEN\n\t$2\nEND",
                "snippet": "IF $1 THEN\t${2:2END}"
            },
            {
                "key": "IF Then\/Else",
                "icon": 14,
                "documentation": "The UniBasic IF\/THEN\/ELSE command executes one of two blocks of statements based on a conditional expression. If expr is true, UniData executes the first group of statements. If expr is false, UniData executes the second group of statements.",
                "detail": "IF $1 THEN\n\t$2\nEND ELSE\n\t$3\nEND",
                "snippet": "IF $1 THEN\t${2:2END} ELSE\t${3:3END}"
            },
            {
                "key": "IN",
                "icon": 3,
                "documentation": "The UniBasic IN function captures raw data from an input queue or from a terminal.",
                "detail": "IN()",
                "snippet": "IN()"
            },
            {
                "key": "INDEX",
                "icon": 3,
                "documentation": "The UniBasic INDEX function returns the starting position of the num.expr occurrence of str.expr2 within str.expr1. INDEX supports multibyte languages.",
                "detail": "INDEX($subject, $search, $occurrence)",
                "snippet": "INDEX(${1:subject}, ${2:search}, ${3:occurrence})"
            },
            {
                "key": "INDICES",
                "icon": 3,
                "documentation": "The UniBasic INDICES function returns one of the following: 1) Names of alternate key indexes. 2) Information about a particular alternate key index.",
                "detail": "INDICES($filevar, $indexname)",
                "snippet": "INDICES(${1:filevar}, ${2:indexname})"
            },
            {
                "key": "initSecureServerSocket",
                "icon": 3,
                "documentation": "Use the initSecureServerSocket() function to create a secured connection-oriented stream server socket. It does exactly the same as the initServerSocket() function except that the connection will be secure.",
                "detail": "initSecureServerSocket($name_or_IP, $port, $backlog, $svr_socket, $context)",
                "snippet": "initSecureServerSocket(${1:name_or_IP}, ${2:port}, ${3:backlog}, ${4:svr_socket}, ${5:context})"
            },
            {
                "key": "initServerSocket",
                "icon": 3,
                "documentation": "Use the initServerSocket() function to create a connection-oriented (stream) socket. Associate this socket with an address (name_or_IP) and port number (port), and specify the maximum length the queue of pending connections may grow to.",
                "detail": "initServerSocket($name_or_IP, $port, $backlog, $svr_socket)",
                "snippet": "initServerSocket(${1:name_or_IP}, ${2:port}, ${3:backlog}, ${4:svr_socket})"
            },
            {
                "key": "INMAT",
                "icon": 3,
                "documentation": "The UniBasic INMAT function, in the first form, returns the number of elements (rows) in a dimensioned array. The second form returns the current dimension of the dimensioned array array.name. If the dimensioned array has two dimensions, the bounds are separated by value marks.",
                "detail": "INMAT($array)",
                "snippet": "INMAT(${1:array})"
            },
            {
                "key": "INPUT",
                "icon": 14,
                "documentation": "The UniBasic INPUT command requests data from an input queue or from the terminal screen. INPUT supports multibyte languages.",
                "detail": "INPUT $var",
                "snippet": "INPUT ${1:var}"
            },
            {
                "key": "INPUT @",
                "icon": 14,
                "documentation": "The UniBasic INPUT @ command places the cursor at a specific location on the terminal screen and prompts the user for input. INPUT @ supports multibyte languages.",
                "detail": "INPUT @($col, $row): $var",
                "snippet": "INPUT @(${1:col}, ${2:row}): ${3:var}"
            },
            {
                "key": "INPUTCLEAR",
                "icon": 14,
                "documentation": "INPUTCLEAR is a synonym for the CLEARINPUT command.",
                "detail": "INPUTCLEAR",
                "snippet": "INPUTCLEAR"
            },
            {
                "key": "INPUTERR",
                "icon": 14,
                "documentation": "The UniBasic INPUTERR command displays an error message at the bottom line of the terminal screen. error.expr can be any valid UniBasic statement, including a literal string enclosed in quotation marks.",
                "detail": "INPUTERR $errExpr",
                "snippet": "INPUTERR ${1:errExpr}"
            },
            {
                "key": "INPUTIF",
                "icon": 14,
                "documentation": "The UniBasic INPUTIF command retrieves input from the type-ahead buffer and assigns the input to a variable.",
                "detail": "INPUTIF $var THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "INPUTIF ${1:var} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "INPUTNULL",
                "icon": 14,
                "documentation": "The UniBasic INPUTNULL command enables you to change the default INPUTNULL character from the default, underscore, to any other single character. When you enter the INPUTNULL character in response to an INPUT or INPUT @ prompt, UniData stores an empty string in place of the character entered. expr specifies the character to serve as the INPUTNULL character for this session.",
                "detail": "INPUTNULL $expr",
                "snippet": "INPUTNULL ${1:expr}"
            },
            {
                "key": "INPUTTRAP",
                "icon": 14,
                "documentation": "The UniBasic INPUTTRAP command sets a trap for a particular character or characters in a program. INPUTTRAP enables you to specify characters which, if entered at an INPUT or INPUT @ statement, will branch to another statement label.",
                "detail": "INPUTTRAP $expr GOSUB $label1",
                "snippet": "INPUTTRAP ${1:expr} GOSUB ${2:label1}"
            },
            {
                "key": "INS",
                "icon": 14,
                "documentation": "The UniBasic INS command inserts an expression with the appropriate delimiter before the specified attribute, value, or subvalue mark in a dynamic array.",
                "detail": "INS $expr BEFORE $Var<$attr, $value, $subvalue>",
                "snippet": "INS ${1:expr} BEFORE ${2:Var}<${3:attr}, ${4:value}, ${5:subvalue}>"
            },
            {
                "key": "INSERT",
                "icon": 3,
                "documentation": "The UniBasic INSERT function inserts an expression (with its delimiter) before or after the specified attribute, value, or subvalue mark in a dynamic array.",
                "detail": "INSERT($DynArr, $attr, $value, $subvalue; $expr)",
                "snippet": "INSERT(${1:DynArr}, ${2:attr}, ${3:value}, ${4:subvalue}; ${5:expr})"
            },
            {
                "key": "INT",
                "icon": 3,
                "documentation": "The UniBasic INT function returns the integer value of numeric expression num.expr.",
                "detail": "INT($expr)",
                "snippet": "INT(${1:expr})"
            },
            {
                "key": "ISMB",
                "icon": 3,
                "documentation": "The UniBasic ISMB function returns a code indicating whether the currently installed language is made up of a single-byte or multibyte character set.",
                "detail": "ISMB()",
                "snippet": "ISMB()"
            },
            {
                "key": "ISNV",
                "icon": 3,
                "documentation": "The UniBasic ISNV function tests an expression for the null value. If expr is the null value, this function returns a code of 1. If the expression is not null, or if it contains a null value as well as other characters, this function returns a code of 0.",
                "detail": "ISNV($expr)",
                "snippet": "ISNV(${1:expr})"
            },
            {
                "key": "ISNVS",
                "icon": 3,
                "documentation": "The UniBasic ISNVS function tests dynamic array elements to see if any of them is the null value. This function is meaningful only when null value handling is on. It returns an array with 0 or 1 in each element. If the array element is the null value, this function returns a code of 1. If the element is not null, or if it contains the null value as well as other characters, this function returns a code of 0.",
                "detail": "ISNVS($dynarr)",
                "snippet": "ISNVS(${1:dynarr})"
            },
            {
                "key": "ITYPE",
                "icon": 3,
                "documentation": "The UniBasic ITYPE function enables a UniBasic program to execute a UniData virtual attribute from the dictionary of a UniData file. The value of the function is the same as if it were run using UniQuery or UniData SQL.",
                "detail": "ITYPE($itype)",
                "snippet": "ITYPE(${1:itype})"
            },
            {
                "key": "LEN",
                "icon": 3,
                "documentation": "The UniBasic LEN function returns the length of character expression str.expr. LEN supports multibyte languages.",
                "detail": "LEN($expr)",
                "snippet": "LEN(${1:expr})"
            },
            {
                "key": "LENS",
                "icon": 3,
                "documentation": "The UniBasic LENS function returns the length of the values within each element of a dynamic array. LENS supports multibyte languages.",
                "detail": "LENS($dynamic_array)",
                "snippet": "LENS(${1:dynamic_array})"
            },
            {
                "key": "LES",
                "icon": 3,
                "documentation": "The UniBasic LES function compares each value in array1 to its corresponding value in array2. UniData returns an array with 1 in each position where the value in array1 is less than or equal to the value in the corresponding value in array2, and 0 in each position when the value in array1 is greater than that in array2.",
                "detail": "LES($array1, $array2)",
                "snippet": "LES(${1:array1}, ${2:array2})"
            },
            {
                "key": "LISTUSER",
                "icon": 3,
                "documentation": "The LISTUSER function returns information about UniData processes currently running in a dynamic array.",
                "detail": "LISTUSER()",
                "snippet": "LISTUSER()"
            },
            {
                "key": "LN",
                "icon": 3,
                "documentation": "The UniBasic LN function returns the natural base logarithm of numeric expression num.expr. This function is the inverse of the EXP function.",
                "detail": "LN($expr)",
                "snippet": "LN(${1:expr})"
            },
            {
                "key": "loadSecurityContext",
                "icon": 3,
                "documentation": "The loadSecurityContext() function loads a saved security context record into the current session.",
                "detail": "loadSecurityContext($context, $name, $passPhrase)",
                "snippet": "loadSecurityContext(${1:context}, ${2:name}, ${3:passPhrase})"
            },
            {
                "key": "LOCATE Function",
                "icon": 14,
                "documentation": "The UniBasic LOCATE command locates an element within a dynamic array. For LOCATE to be successful, the search string, element, must match the entire array element (including any associated lower-level elements). LOCATE does not modify the data in the array.",
                "detail": "LOCATE($search, $subject; $returnVar) THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "LOCATE(${1:search}, ${2:subject}; ${3:returnVar}) THEN\t${4:then_statementsEND} ELSE\t${5:else_statementsEND}"
            },
            {
                "key": "LOCATE Statement",
                "icon": 14,
                "documentation": "The UniBasic LOCATE command locates an element within a dynamic array. For LOCATE to be successful, the search string, element, must match the entire array element (including any associated lower-level elements). LOCATE does not modify the data in the array.",
                "detail": "LOCATE $search IN $subject SETTING $returnVar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "LOCATE ${1:search} IN ${2:subject} SETTING ${3:returnVar} THEN\t${4:then_statementsEND} ELSE\t${5:else_statementsEND}"
            },
            {
                "key": "LOCK",
                "icon": 14,
                "documentation": "The UniBasic LOCK command reserves a computer resource (such as a device or file) for the current user process.",
                "detail": "LOCK $expr THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "LOCK ${1:expr} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "LOOP While",
                "icon": 14,
                "documentation": "The UniBasic LOOP\/REPEAT command repeats any contained statements while or until a specified condition is met, depending on whether you use the WHILE or UNTIL clause. statements can precede and\/or follow the test condition. If space permits, you can write the structure on one line. Otherwise, you can extend the structure on as many lines as necessary. REPEAT is required and finishes the LOOP operation.",
                "detail": "LOOP\n\t$statement1\nWHILE $expression DO\n\t$statement2\nREPEAT",
                "snippet": "LOOP\t${1:statement1} WHILE ${2:expression} DO\t${3:statement2REPEAT}"
            },
            {
                "key": "LOOP Until",
                "icon": 14,
                "documentation": "The UniBasic LOOP\/REPEAT command repeats any contained statements while or until a specified condition is met, depending on whether you use the WHILE or UNTIL clause. statements can precede and\/or follow the test condition. If space permits, you can write the structure on one line. Otherwise, you can extend the structure on as many lines as necessary. REPEAT is required and finishes the LOOP operation.",
                "detail": "LOOP\n\t$statement1\nUNTIL $expression DO\n\t$statement2\nREPEAT",
                "snippet": "LOOP\t${1:statement1} UNTIL ${2:expression} DO\t${3:statement2REPEAT}"
            },
            {
                "key": "WHILE LOOP (Modern)",
                "icon": 14,
                "documentation": "The UniBasic LOOP\/REPEAT command repeats any contained statements while or until a specified condition is met, depending on whether you use the WHILE or UNTIL clause. statements can precede and\/or follow the test condition. If space permits, you can write the structure on one line. Otherwise, you can extend the structure on as many lines as necessary. REPEAT is required and finishes the LOOP operation.",
                "detail": "LOOP WHILE $expression DO\n\t$statement2\nREPEAT",
                "snippet": "LOOP WHILE ${1:expression} DO\n\t${2:statement2}\nREPEAT"
            },
            {
                "key": "UNTIL LOOP (Modern)",
                "icon": 14,
                "documentation": "The UniBasic LOOP\/REPEAT command repeats any contained statements while or until a specified condition is met, depending on whether you use the WHILE or UNTIL clause. statements can precede and\/or follow the test condition. If space permits, you can write the structure on one line. Otherwise, you can extend the structure on as many lines as necessary. REPEAT is required and finishes the LOOP operation.",
                "detail": "LOOP UNTIL $expression DO\n\t$statement2\nREPEAT",
                "snippet": "LOOP UNTIL ${1:expression} DO\n\t${2:statement2}\nREPEAT"
            },
            {
                "key": "LOWER",
                "icon": 3,
                "documentation": "The UniBasic LOWER function converts all attribute marks to value marks, and, in a dynamic array, it converts all value marks to subvalue marks.",
                "detail": "LOWER($expr)",
                "snippet": "LOWER(${1:expr})"
            },
            {
                "key": "LTS",
                "icon": 3,
                "documentation": "The UniBasic LTS function compares each element in array1 to its corresponding value in array2. UniData returns an array with 1 in each position where the value in array1 is less than the value in the corresponding position in array2, and 0 in each position for values in array1 that are greater than those in array2.",
                "detail": "LTS($arr1, $arr2)",
                "snippet": "LTS(${1:arr1}, ${2:arr2})"
            },
            {
                "key": "MAT",
                "icon": 14,
                "documentation": "The first form of the UniBasic MAT command assigns new values to all elements of a dimensioned array based on an expression. The second form assigns the contents of a dimensioned array to another dimensioned array.",
                "detail": "MAT $array = $expr",
                "snippet": "MAT ${1:array} = ${2:expr}"
            },
            {
                "key": "MATBUILD",
                "icon": 14,
                "documentation": "The UniBasic MATBUILD command generates a dynamic array from a dimensioned array based on specified starting and ending positions and the delimiter given. The dimensioned array can be multidimensional. The statement retrieves elements from the multidimensional array according to the order in which its elements are stored.",
                "detail": "MATBUILD $variable FROM $array, $startexpr, $endexpr",
                "snippet": "MATBUILD ${1:variable} FROM ${2:array}, ${3:startexpr}, ${4:endexpr}"
            },
            {
                "key": "MATCH",
                "icon": 3,
                "documentation": "The UniBasic MATCH or MATCHES function determines if a variable matches a specific pattern of characters, numbers, or a literal string. If var matches the pattern, MATCH or MATCHES returns 1. If var does not match the pattern, MATCH or MATCHES returns 0.",
                "detail": "$str1 MATCH $pattern",
                "snippet": "${1:str1} MATCH ${2:pattern}"
            },
            {
                "key": "MATCHFIELD",
                "icon": 3,
                "documentation": "The UniBasic MATCHFIELD function returns a substring that matches a pattern or literal. If no match is made, UniData returns an empty string. MATCHFIELD supports multibyte languages.",
                "detail": "MATCHFIELD($string, $pattern, $element)",
                "snippet": "MATCHFIELD(${1:string}, ${2:pattern}, ${3:element})"
            },
            {
                "key": "MATPARSE",
                "icon": 14,
                "documentation": "The UniBasic MATPARSE command distributes elements of a delimited string or dynamic array to consecutive elements of a dimensioned array. Delimiters can be the standard UniData delimiters or any other ASCII character.",
                "detail": "MATPARSE $mat FROM $str SETTING $var",
                "snippet": "MATPARSE ${1:mat} FROM ${2:str} SETTING ${3:var}"
            },
            {
                "key": "MATREAD",
                "icon": 14,
                "documentation": "The UniBasic MATREAD command assigns the values found in successive attributes of a record to corresponding elements of a dimensioned array \u2014 regardless of lock status.",
                "detail": "MATREAD $mat FROM $filevar, $recordkey THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "MATREAD ${1:mat} FROM ${2:filevar}, ${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "MATREADL",
                "icon": 14,
                "documentation": "The UniBasic MATREADL command assigns the values found in successive attributes of a record to corresponding elements of a dimensioned array. MATREADL checks for locks and will not read a record locked with an exclusive (U) lock. If the record is available, MATREADL reads and sets a shared (L) lock on it.",
                "detail": "MATREADL $mat FROM $filevar, $recordkey THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "MATREADL ${1:mat} FROM ${2:filevar}, ${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "MATREADU",
                "icon": 14,
                "documentation": "The UniBasic MATREADU command assigns the values found in successive attributes of a record to corresponding elements of a dimensioned array. MATREADU checks for locks and will not read a locked record. If the record is available, MATREADU reads and sets an exclusive (U) lock on it.",
                "detail": "MATREADU $mat FROM $filevar, $recordkey THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "MATREADU ${1:mat} FROM ${2:filevar}, ${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "MATWRITE",
                "icon": 14,
                "documentation": "The UniBasic MATWRITE command writes successive elements of a dimensioned array to the corresponding attributes of a record.",
                "detail": "MATWRITE $mat TO $filevar, $recordkey",
                "snippet": "MATWRITE ${1:mat} TO ${2:filevar}, ${3:recordkey}"
            },
            {
                "key": "MATWRITEU",
                "icon": 14,
                "documentation": "The UniBasic MATWRITEU command writes successive elements of a dimensioned array to the corresponding attributes of a specified record. MATWRITEU does not release locks set by READU, READVU, or MATREADU statements.",
                "detail": "MATWRITEU $mat TO $filevar, $recordkey",
                "snippet": "MATWRITEU ${1:mat} TO ${2:filevar}, ${3:recordkey}"
            },
            {
                "key": "MAXIMUM",
                "icon": 3,
                "documentation": "The UniBasic MAXIMUMfunction returns the largest numeric value found in a dynamic array. This function ignores nonnumeric elements. If the array you specify contains only nonnumeric elements, MAXIMUM returns an empty string. If an element is empty, UniData treats it as 0.",
                "detail": "MAXIMUM($DynArr)",
                "snippet": "MAXIMUM(${1:DynArr})"
            },
            {
                "key": "MBLEN",
                "icon": 3,
                "documentation": "The UniBasic MBLEN function returns the number of bytes in the first character of a string.",
                "detail": "MBLEN($str)",
                "snippet": "MBLEN(${1:str})"
            },
            {
                "key": "MDPERFORM",
                "icon": 14,
                "documentation": "The UniBasic MDPERFORM command executes various UniData commands, sentences, or paragraphs within a UniBasic program while transferring lists to and from the executed commands.",
                "detail": "MDPERFORM $strexpr",
                "snippet": "MDPERFORM ${1:strexpr}"
            },
            {
                "key": "MINIMUM",
                "icon": 3,
                "documentation": "The UniBasic MINIMUM function returns the smallest numeric element found in a dynamic array.",
                "detail": "MINIMUM($DynArr)",
                "snippet": "MINIMUM(${1:DynArr})"
            },
            {
                "key": "MOD",
                "icon": 3,
                "documentation": "The UniBasic MOD and REM functions return the remainder of the division of num.expr2 into num.expr1. These functions divide integers and decimals. The sign of the result is the same as that of num.expr1.",
                "detail": "MOD($dividend, $divisor)",
                "snippet": "MOD(${1:dividend}, ${2:divisor})"
            },
            {
                "key": "NEG",
                "icon": 3,
                "documentation": "The UniBasic NEG function changes the value of expr to its opposite sign. If the value of expr is positive, NEG returns a negative value. If the value of expr is negative, NEG returns a positive value.",
                "detail": "NEG($expr)",
                "snippet": "NEG(${1:expr})"
            },
            {
                "key": "NES",
                "icon": 3,
                "documentation": "The UniBasic NES function compares each value in array1 to its corresponding value in array2. UniData returns an array with a one in each position where the value in array1 is not equal to the value in the corresponding position in array2, and a zero in each position for values that are equal to array2.",
                "detail": "NES($expr1, $expr2)",
                "snippet": "NES(${1:expr1}, ${2:expr2})"
            },
            {
                "key": "NFAUSER",
                "icon": 3,
                "documentation": "Beginning at UniData 5.0, a Network File Access (NFA) connection from an NFA client requires a valid user name and password. If the client connection is made through udtelnet, this information is available and passed to the NFA server for connecting. If the session is a console session, the system prompts for the user name and password when a connection is requested, such as when you OPEN the first NFA file on a database. UniBasic now provides the NFAUSER function which enables you to set the user name and password in a UniBasic program.",
                "detail": "NFAUSER($username, $password)",
                "snippet": "NFAUSER(${1:username}, ${2:password})"
            },
            {
                "key": "NOCONVERT",
                "icon": 14,
                "documentation": "The UniBasic NOCONVERT command controls the conversion of the special character CHAR(0). The following UniBasic commands read and write non-UniData files or tapes and convert CHAR(0) to CHAR(128) on input. They also convert CHAR(128) to CHAR(0) on output. This can cause problems under some circumstances, especially if you use the character CHAR(128) in an application or in stored data. NOCONVERT provides a way of switching the conversion OFF or ON. The default is OFF.",
                "detail": "NOCONVERT $OFF_ON",
                "snippet": "NOCONVERT ${1:OFF_ON}"
            },
            {
                "key": "NOT",
                "icon": 3,
                "documentation": "The UniBasic NOT Boolean operator inverts the logical result of the argument expr. If the expression is true, the function returns 0 (false). If the expression is not true, the function returns 1 (true).",
                "detail": "NOT($expr)",
                "snippet": "NOT(${1:expr})"
            },
            {
                "key": "NOTS",
                "icon": 0,
                "documentation": "The UniBasic NOTS Boolean operator inverts the logical result of each element of a dynamic array. If the element is true, the operator returns 0 (false) in the corresponding position of the new array. If the expression is not true, the operator returns 1 (true) in the corresponding position of the new array.",
                "detail": "NOTS($DynArr)",
                "snippet": "NOTS(${1:DynArr})"
            },
            {
                "key": "NULL",
                "icon": 14,
                "documentation": "The UniBasic NULL command acts as a dummy statement. You can use the NULL statement anywhere a statement is required.",
                "detail": "NULL",
                "snippet": "NULL"
            },
            {
                "key": "NUM",
                "icon": 3,
                "documentation": "The UniBasic NUM function determines if an expression is numeric. If expr is numeric, NUM returns 1. Otherwise, it returns 0. expr can be any valid UniBasic expression. The NUM function returns 0 for any multibyte character.",
                "detail": "NUM($str)",
                "snippet": "NUM(${1:str})"
            },
            {
                "key": "NUMS",
                "icon": 3,
                "documentation": "The UniBasic NUMS function determines, for each element of an array, if that element is numeric. If the element is numeric, NUM returns 1 in the corresponding position of the new array. For nonnumeric and multibyte characters, it returns 0.",
                "detail": "NUMS($DynArr)",
                "snippet": "NUMS(${1:DynArr})"
            },
            {
                "key": "OCONV",
                "icon": 3,
                "documentation": "The UniBasic OCONV function converts string or numeric data from internal format to display format based on conversion codes. If the input value or conversion code is invalid, UniData returns the input value. OCONV supports multibyte languages.",
                "detail": "OCONV($subject, $conversion)",
                "snippet": "OCONV(${1:subject}, ${2:conversion})"
            },
            {
                "key": "OCONVS",
                "icon": 3,
                "documentation": "The UniBasic OCONVS function converts string or numeric data from internal format to output format, based on a conversion code, for each element of a dynamic array. If the input value or conversion code is invalid, UniData returns the input value.",
                "detail": "OCONVS($DynArr, $conversion)",
                "snippet": "OCONVS(${1:DynArr}, ${2:conversion})"
            },
            {
                "key": "ON\/GOSUB",
                "icon": 14,
                "documentation": "The UniBasic ON\/GOSUB command transfers program control to a subroutine label based on the value of expr.",
                "detail": "ON $expr GOSUB $label",
                "snippet": "ON ${1:expr} GOSUB ${2:label}"
            },
            {
                "key": "OPEN",
                "icon": 14,
                "documentation": "The UniBasic OPEN command opens a UniData hashed data or dictionary file, so you can read, write, or delete records from it. The number of files you can open is determined by operating system and UniData configuration parameters. For information about file performance, see Administering UniData on UNIX or Administering UniData on Windows Platforms.",
                "detail": "OPEN $filename TO $filevar ELSE $else_statements",
                "snippet": "OPEN ${1:filename} TO ${2:filevar} ELSE ${3:else_statements}"
            },
            {
                "key": "openSecureSocket",
                "icon": 3,
                "documentation": "Use the openSecureSocket() function to open a secure socket connection in a specified mode and return the status.",
                "detail": "openSecureSocket($name_or_IP, $port, $mode, $timeout, $socket_handle, $context)",
                "snippet": "openSecureSocket(${1:name_or_IP}, ${2:port}, ${3:mode}, ${4:timeout}, ${5:socket_handle}, ${6:context})"
            },
            {
                "key": "OPENSEQ",
                "icon": 14,
                "documentation": "The UniBasic OPENSEQ command opens a sequential file for access, starting at the specified record. UniData limits to 150 the number of sequential files you can open in a UniBasic program.",
                "detail": "OPENSEQ $path $READONLY TO $filevar ON ERROR $err LOCKED $lock THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "OPENSEQ ${1:path} ${2:READONLY} TO ${3:filevar} ON ERROR ${4:err} LOCKED ${5:lock} THEN\n\t${6:then_statements}\nEND ELSE\n\t${7:else_statements}\nEND"
            },
            {
                "key": "openSocket",
                "icon": 3,
                "documentation": "Use the openSocket() function to open a socket connection in a specified mode and return the status.",
                "detail": "openSocket($name_or_IP, $port, $mode, $timeout, $socket_handle)",
                "snippet": "openSocket(${1:name_or_IP}, ${2:port}, ${3:mode}, ${4:timeout}, ${5:socket_handle})"
            },
            {
                "key": "OPENXMLDATA",
                "icon": 3,
                "documentation": "Use the OPENXMLDATA function to open an XML document after preparing it using the PREPAREXML function.",
                "detail": "OPENXMLDATA($xml_handle, $xml_data_extraction_rule, $xml_data_handle)",
                "snippet": "OPENXMLDATA(${1:xml_handle}, ${2:xml_data_extraction_rule}, ${3:xml_data_handle})"
            },
            {
                "key": "OSBREAD",
                "icon": 14,
                "documentation": "The UniBasic OSBREAD command reads data from a file starting at a specified byte location for a certain length of bytes, and assigns the data to a variable. OSBREAD performs an operating system block read on a UNIX, or Windows platform file.",
                "detail": "OSBREAD $var FROM $filevar LENGTH $length_expr",
                "snippet": "OSBREAD ${1:var} FROM ${2:filevar} LENGTH ${3:length_expr}"
            },
            {
                "key": "OSBWRITE",
                "icon": 14,
                "documentation": "The UniBasic OSBWRITE command writes an expression to a sequential file starting at a specified byte location. OSBWRITE immediately writes a file segment out to the UNIX, or Windows platform file.",
                "detail": "OSBWRITE $expr TO $filevar",
                "snippet": "OSBWRITE ${1:expr} TO ${2:filevar}"
            },
            {
                "key": "OSCLOSE",
                "icon": 14,
                "documentation": "The UniBasic OSCLOSE command closes a sequential file that you opened with the OSOPEN or OPENSEQ command.",
                "detail": "OSCLOSE $filevar",
                "snippet": "OSCLOSE ${1:filevar}"
            },
            {
                "key": "OSDELETE",
                "icon": 14,
                "documentation": "The UniBasic OSDELETE command deletes an NTFS or UNIX sequential file.",
                "detail": "OSDELETE $path",
                "snippet": "OSDELETE ${1:path}"
            },
            {
                "key": "OSOPEN",
                "icon": 14,
                "documentation": "The UniBasic OSOPEN command opens a sequential file that does not use CHAR(10) as the line delimiter.",
                "detail": "OSOPEN $filename TO $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "OSOPEN ${1:filename} TO ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "OSREAD",
                "icon": 14,
                "documentation": "The UniBasic OSREAD command reads an entire sequential file and assigns the contents of the file to a variable.",
                "detail": "OSREAD $var FROM $path ON ERROR $err THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "OSREAD ${1:var} FROM ${2:path} ON ERROR ${3:err} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "OSWRITE",
                "icon": 14,
                "documentation": "The UniBasic OSWRITE command writes the contents of an expression to a sequential file.",
                "detail": "OSWRITE $expr TO $path ON ERROR $err",
                "snippet": "OSWRITE ${1:expr} TO ${2:path} ON ERROR ${3:err}"
            },
            {
                "key": "PAGE",
                "icon": 14,
                "documentation": "The UniBasic PAGE command prints the current output page. UniData prints the page with any specified header or footer.",
                "detail": "PAGE $1",
                "snippet": "PAGE $1"
            },
            {
                "key": "PAUSE",
                "icon": 14,
                "documentation": "The UniBasic PAUSE command suspends the UniData process that issues the command for the amount of time you specify with wait_time, or until a UniBasic WAKE command is executed for this process.",
                "detail": "PAUSE $timeout",
                "snippet": "PAUSE ${1:timeout}"
            },
            {
                "key": "PCPERFORM",
                "icon": 14,
                "documentation": "The UniBasic PCPERFORM command executes an operating system command from within a UniBasic program.",
                "detail": "PCPERFORM $str CAPTURING $dynarr",
                "snippet": "PCPERFORM ${1:str} CAPTURING ${2:dynarr}"
            },
            {
                "key": "PERFORM",
                "icon": 14,
                "documentation": "PERFORM is a synonym for the EXECUTE command.",
                "detail": "PERFORM $expr",
                "snippet": "PERFORM ${1:expr}"
            },
            {
                "key": "PRECISION",
                "icon": 14,
                "documentation": "The UniBasic PRECISION command rounds numbers to the number of decimal places indicated in num.expr. num.expr can be a number from 0 to 14. If the number is not within this range, UniData does not change the setting. The default is four decimal places.",
                "detail": "PRECISION $integer",
                "snippet": "PRECISION ${1:integer}"
            },
            {
                "key": "PREPAREXML",
                "icon": 3,
                "documentation": "Use the PREPAREXML function to prepare the XML document in the UniBasic program. This step allocates memory for the XML document, opens the document, determines the file structure of the document, and returns the file structure.",
                "detail": "PREPAREXML($xml_file, $xml_handle)",
                "snippet": "PREPAREXML(${1:xml_file}, ${2:xml_handle})"
            },
            {
                "key": "PRINT",
                "icon": 14,
                "documentation": "The UniBasic PRINT command prints data on the display terminal or the system printer, or sends data to a print file.",
                "detail": "PRINT $expr",
                "snippet": "PRINT ${1:expr}"
            },
            {
                "key": "PRINTER",
                "icon": 14,
                "documentation": "The UniBasic PRINTER command directs output of PRINT, FOOTING, HEADING, and PAGE statements not sent to a file (those executed without the ON clause). If you specify ON, UniData directs all output to the system printer. If you specify OFF, UniData directs all output to the terminal screen.",
                "detail": "PRINTER $ON_OFF",
                "snippet": "PRINTER ${1:ON_OFF}"
            },
            {
                "key": "PRINTER CLOSE",
                "icon": 14,
                "documentation": "The UniBasic PRINTER CLOSE command sends data stored in either a print file or a print buffer to the print queue. The ON clause does not physically close the print file. Instead, it sends its contents to a print buffer, leaving the file empty. Then you can send additional data to the same print file to begin a new set of data to be printed. As many as 31 print files can be open at the same time. The PRINTER CLOSE statement does not generate a new line at the end of a page. UniBasic is in control of page feeds or generating new line equivalents.",
                "detail": "PRINTER CLOSE",
                "snippet": "PRINTER CLOSE"
            },
            {
                "key": "PRINTERR",
                "icon": 14,
                "documentation": "The UniBasic PRINTERR command prints error messages stored in the UniData system message file or in a user-defined file.",
                "detail": "PRINTERR $expr",
                "snippet": "PRINTERR ${1:expr}"
            },
            {
                "key": "PROCREAD",
                "icon": 14,
                "documentation": "The UniBasic PROCREAD command assigns the string value of the primary input buffer of the calling Proc to a variable. PROCREAD can be used to access the primary input buffer of a calling proc.",
                "detail": "PROCREAD $variable THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "PROCREAD ${1:variable} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "PROCWRITE",
                "icon": 14,
                "documentation": "The UniBasic PROCWRITE command writes data to the primary input buffer of the calling Proc. PROCWRITE overlays any data in the primary input buffer with the new data in PROCWRITE.",
                "detail": "PROCWRITE $expr",
                "snippet": "PROCWRITE ${1:expr}"
            },
            {
                "key": "PROGRAM",
                "icon": 14,
                "documentation": "The UniBasic PROGRAM command defines the name of the current main program. This statement is optional. It is used for documentation purposes only. The PROGRAM statement must be the first noncomment statement in the program.",
                "detail": "PROGRAM $progname",
                "snippet": "PROGRAM ${1:progname}"
            },
            {
                "key": "PROMPT",
                "icon": 14,
                "documentation": "The UniBasic PROMPT command sets the prompt displayed by the INPUT command to a specified single-byte character. If str.expr is longer than one character, UniData uses the first character as the prompt. You cannot set the prompt to a multibyte character.",
                "detail": "PROMPT $expr",
                "snippet": "PROMPT ${1:expr}"
            },
            {
                "key": "protocolLogging",
                "icon": 3,
                "documentation": "This function will start or stop logging.",
                "detail": "protocolLogging($log_file, $log_action, $log_level)",
                "snippet": "protocolLogging(${1:log_file}, ${2:log_action}, ${3:log_level})"
            },
            {
                "key": "PWR",
                "icon": 3,
                "documentation": "The UniBasic PWR function raises expr1 to the power of expr2.",
                "detail": "PWR($expr1, $pwrexpr)",
                "snippet": "PWR(${1:expr1}, ${2:pwrexpr})"
            },
            {
                "key": "QUOTE",
                "icon": 3,
                "documentation": "The UniBasic QUOTE function encloses a string expression in double quotation marks.",
                "detail": "QUOTE($expr)",
                "snippet": "QUOTE(${1:expr})"
            },
            {
                "key": "RAISE",
                "icon": 3,
                "documentation": "The UniBasic RAISE function raises all UniData delimiters to the next level. UniData raises attribute marks to record marks, value marks to attribute marks, and subvalue marks to value marks.",
                "detail": "RAISE($str)",
                "snippet": "RAISE(${1:str})"
            },
            {
                "key": "READ",
                "icon": 14,
                "documentation": "The UniBasic READ command reads a record from a file and assigns its contents to a dynamic array. UniData assigns the first attribute of the record to the first position of the array, the second attribute to the second position, and so on. If UniData cannot find the record you specify, it executes the ELSE clause and returns dyn.array.var empty.",
                "detail": "READ $var FROM $filevar,$recordkey THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READ ${1:var} FROM ${2:filevar},${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "READBCK",
                "icon": 14,
                "documentation": "The first READBCK command retrieves the alternate key set by SETINDEX, then each subsequent READBCK retrieves the previous alternate key value in the index. The corresponding record is read into a dynamic array, and the record ID is assigned to the @ID variable.",
                "detail": "READBCK $dynarr FROM $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READBCK ${1:dynarr} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READBCKL",
                "icon": 14,
                "documentation": "The first READBCKL command retrieves the alternate key set by SETINDEX, and then each subsequent READBCKL retrieves the previous alternate key in the index. The corresponding record is read into a dynamic array, and the record ID is assigned to the @ID variable. READBCKL checks for locks. If the record is available, it sets a shared (L) lock before reading the record.",
                "detail": "READBCKL $dynarr FROM $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READBCKL ${1:dynarr} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READBCKU",
                "icon": 14,
                "documentation": "The first READBCKU command retrieves the alternate key set by SETINDEX, and then each subsequent READBCKU retrieves the previous alternate key value in the index. The corresponding record is read into a dynamic array, and the record ID is assigned to the @ID variable. READBCKU checks for locks. If the record is available, it sets an exclusive (U) lock before reading the record.",
                "detail": "READBCKU $dynarr FROM $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READBCKU ${1:dynarr} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READFWD",
                "icon": 14,
                "documentation": "The first READFWD command retrieves the alternate key set by SETINDEX, and then each subsequent READFWD retrieves the next alternate key value in the index. UniData reads the corresponding record into a dynamic array, and then assigns the record ID to the @ID variable.",
                "detail": "READFWD $dynarr FROM $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READFWD ${1:dynarr} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READFWDL",
                "icon": 14,
                "documentation": "The first READFWDL command retrieves the alternate key set by SETINDEX, and then each subsequent READFWDL retrieves the next alternate key value in the index. UniData reads the corresponding record into a dynamic array, and then assigns the record ID to the @ID variable. READFWDL checks for locks. If the record is available, it sets a shared (L) lock.",
                "detail": "READFWDL $dynarr FROM $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READFWDL ${1:dynarr} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READFWDU",
                "icon": 14,
                "documentation": "The first READFWDU command retrieves the alternate key set by SETINDEX, and then each subsequent READFWDU retrieves the next alternate key value in the index. UniData reads the corresponding record into a dynamic array, and then assigns the record ID to the @ID variable. READFWDU checks for locks. If the record is available, READFWDU sets an exclusive (U) lock before reading the record.",
                "detail": "READFWDU $dynarr FROM $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READFWDU ${1:dynarr} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READL",
                "icon": 14,
                "documentation": "The UniBasic READL command reads the specified record from a file and assigns its contents to a dynamic array. UniData assigns the first attribute of the record to the first position of the array, the second attribute to the second position, and so on. READL checks for locks. If the record is available, it sets a read-only lock on the record, preventing other lock-checking commands from updating it.",
                "detail": "READL $var FROM $filevar,$recordkey THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READL ${1:var} FROM ${2:filevar},${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "READLIST",
                "icon": 14,
                "documentation": "The UniBasic READLIST command assigns the values in an active select list to a dynamic array. Each select list element becomes an attribute in the dynamic array.",
                "detail": "READLIST $var FROM $listnum THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READLIST ${1:var} FROM ${2:listnum} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READNEXT",
                "icon": 14,
                "documentation": "The UniBasic READNEXT command assigns the next record ID from an active select list to a variable.",
                "detail": "READNEXT $var FROM $list",
                "snippet": "READNEXT ${1:var} FROM ${2:list}"
            },
            {
                "key": "READNEXTTUPLE",
                "icon": 14,
                "documentation": "The UniBasic READNEXTTUPLE command assigns the next entire record to a variable. The record ID is obtained from an active select list that was created by a UniData SQL SELECT statement during the current work session.",
                "detail": "READNEXTTUPLE $dynarr FROM $filenameexpr THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READNEXTTUPLE ${1:dynarr} FROM ${2:filenameexpr} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READSELECT",
                "icon": 14,
                "documentation": "READSELECT is a synonym for the READLIST command.",
                "detail": "READSELECT $var FROM $listnum THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READSELECT ${1:var} FROM ${2:listnum} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READSEQ",
                "icon": 14,
                "documentation": "The UniBasic READSEQ command reads the next record from a sequential file and assigns the data read to a variable.",
                "detail": "READSEQ $var FROM $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READSEQ ${1:var} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "readSocket",
                "icon": 3,
                "documentation": "Use the readSocket() function to read data in the socket buffer up to max_read_size characters.",
                "detail": "readSocket($socket_handle, $socket_data, $max_read_size, $time_out, $mode, $actual_read_size)",
                "snippet": "readSocket(${1:socket_handle}, ${2:socket_data}, ${3:max_read_size}, ${4:time_out}, ${5:mode}, ${6:actual_read_size})"
            },
            {
                "key": "READT",
                "icon": 14,
                "documentation": "The UniBasic READT command reads the next record from a tape and assigns it to a variable.",
                "detail": "READT $variable THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READT ${1:variable} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "READU",
                "icon": 14,
                "documentation": "The UniBasic READU command reads a record from a file and assigns its contents to a dynamic array. READU checks for locks. If the record is available, it sets an exclusive lock and reads the record.",
                "detail": "READU $var FROM $filevar,$recordkey LOCKED $lock_statements THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READU ${1:var} FROM ${2:filevar},${3:recordkey} LOCKED ${4:lock_statements} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "READV",
                "icon": 14,
                "documentation": "The UniBasic READV command assigns the data from an attribute of a record to a variable.",
                "detail": "READV $var FROM $filevar,$recordkey,$attr THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READV ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "READVL",
                "icon": 14,
                "documentation": "The UniBasic READVL command assigns the data from an attribute of a record to a variable. READVL checks for locks. If the record is available, it sets a shared lock before it reads the record.",
                "detail": "READVL $var FROM $filevar,$recordkey,$attr THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READVL ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "READVU",
                "icon": 14,
                "documentation": "The UniBasic READVU command assigns the data from an attribute of a record to a variable. READVU checks for locks. If the record is available, it sets an exclusive lock before it reads the record.",
                "detail": "READVU $var FROM $filevar,$recordkey,$attr LOCKED $lock_statements THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READVU ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} LOCKED ${5:lock_statements} THEN\n\t${6:then_statements}\nEND ELSE\n\t${7:else_statements}\nEND"
            },
            {
                "key": "READXBCK",
                "icon": 14,
                "documentation": "The UniBasic READXBCK command reads the previous key in an alternate key index in much the same manner as the READBCK command, but does not read the associated record. READXBCK enables a program to read alternate keys without incurring the overhead of retrieving a record every time.",
                "detail": "READXBCK $dynarr FROM $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READXBCK ${1:dynarr} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READXFWD",
                "icon": 14,
                "documentation": "The UniBasic READXFWD command reads the next value in an alternate key index in much the same manner as the READFWD command, but does not read the associated record. READXFWD enables a program to read alternate keys without incurring the overhead of retrieving a record every time.",
                "detail": "READXFWD $dynarr FROM $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "READXFWD ${1:dynarr} FROM ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "READXMLDATA",
                "icon": 3,
                "documentation": "After opening the XML document with the OPENXMLDATA function, read the document using the READXMLDATA function. UniBasic returns the XML data as a dynamic array.",
                "detail": "READXMLDATA($xml_data_handler, $rec)",
                "snippet": "READXMLDATA(${1:xml_data_handler}, ${2:rec})"
            },
            {
                "key": "RECORDLOCKED",
                "icon": 14,
                "documentation": "The UniBasic RECORDLOCKED function returns the lock status of the specified record or file. For an explanation of UniData locks, and for a sample program you can use to test this command, see Developing UniBasic Applications.",
                "detail": "RECORDLOCKED($filevar, $recordkey)",
                "snippet": "RECORDLOCKED(${1:filevar}, ${2:recordkey})"
            },
            {
                "key": "RECORDLOCKL",
                "icon": 14,
                "documentation": "The UniBasic RECORDLOCKL command checks for record locks. If the record is available, it sets a shared lock on the record. For an explanation of UniData locks, and for a sample program that you can use to test this command, see Developing UniBasic Applications.",
                "detail": "RECORDLOCKL $filevar, $recordkey ON ERROR $err_statements LOCKED $lock_statements",
                "snippet": "RECORDLOCKL ${1:filevar}, ${2:recordkey} ON ERROR ${3:err_statements} LOCKED ${4:lock_statements}"
            },
            {
                "key": "RECORDLOCKU",
                "icon": 14,
                "documentation": "The UniBasic RECORDLOCKU command checks for record locks. If the record is available, it sets an exclusive lock on the record. For an explanation of UniData locks, and for a sample program that you can use to test this command, see Developing UniBasic Applications.",
                "detail": "RECORDLOCKU $filevar, $recordkey ON ERROR $err_statements LOCKED $lock_statements",
                "snippet": "RECORDLOCKU ${1:filevar}, ${2:recordkey} ON ERROR ${3:err_statements} LOCKED ${4:lock_statements}"
            },
            {
                "key": "RELEASE",
                "icon": 14,
                "documentation": "The UniBasic RELEASE command unlocks records and files locked by the same user process. If no files or records are locked, RELEASE has no effect.",
                "detail": "RELEASE $filevar, $expr ON ERROR $err_statements",
                "snippet": "RELEASE ${1:filevar}, ${2:expr} ON ERROR ${3:err_statements}"
            },
            {
                "key": "RELEASEXML",
                "icon": 3,
                "documentation": "Release the dynamic array variable using the RELEASEXML function. RELEASEXML destroys the internal DOM tree and releases the associated memory.",
                "detail": "RELEASEXML($XMLhandle)",
                "snippet": "RELEASEXML(${1:XMLhandle})"
            },
            {
                "key": "REM",
                "icon": 14,
                "documentation": "The UniBasic REM command enables you to enter remarks in a program. You can enter the comment on a line by itself by entering the comment command followed by text. You also can enter a comment on a line that contains another UniBasic command by preceding the comment command with a semicolon.",
                "detail": "REM $commentText",
                "snippet": "REM ${1:commentText}"
            },
            {
                "key": "REMOVE",
                "icon": 14,
                "documentation": "The UniBasic REMOVE command extracts an element from a dynamic array and assigns the removed element to a variable. REMOVE does not change the value of the dynamic array. REMOVE supports multibyte languages.",
                "detail": "REMOVE $variable FROM $array SETTING $setvar",
                "snippet": "REMOVE ${1:variable} FROM ${2:array} SETTING ${3:setvar}"
            },
            {
                "key": "REMOVE Function",
                "icon": 3,
                "documentation": "The UniBasic REMOVE function extracts an element from a dynamic array and assigns the removed element to a variable. REMOVE does not change the value of the dynamic array.",
                "detail": "REMOVE($dynarr, $delim)",
                "snippet": "REMOVE(${1:dynarr}, ${2:delim})"
            },
            {
                "key": "REPLACE",
                "icon": 3,
                "documentation": "The UniBasic REPLACE function replaces data in a dynamic array with an expression. If an attribute, value, or subvalue is less than 0, the replacement string is placed after the last attribute, value, or subvalue as appropriate. If the position given does not exist (for example, attribute 6 specified in an array with two attributes), the necessary number of attribute, value, and subvalue marks are added to create the specified position.",
                "detail": "REPLACE($var, $attr, $value, $subvalue; $replace)",
                "snippet": "REPLACE(${1:var}, ${2:attr}, ${3:value}, ${4:subvalue}; ${5:replace})"
            },
            {
                "key": "RESIZET",
                "icon": 14,
                "documentation": "The UniBasic RESIZET command changes the block size the WRITET command uses. When UniData processes a variable length record, the record length is less than the block length and UniData fills the remaining portion of the block with blanks.",
                "detail": "RESIZET $expr THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "RESIZET ${1:expr} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "RETURN",
                "icon": 14,
                "documentation": "The UniBasic RETURN command transfers program control from a subroutine back to the calling program or subroutine.",
                "detail": "RETURN $1",
                "snippet": "RETURN $1"
            },
            {
                "key": "REUSE",
                "icon": 3,
                "documentation": "The UniBasic REUSE function affects the application of arithmetic operations on dynamic arrays.",
                "detail": "REUSE($dynarr)",
                "snippet": "REUSE(${1:dynarr})"
            },
            {
                "key": "REWIND",
                "icon": 14,
                "documentation": "The UniBasic REWIND command rewinds a tape.",
                "detail": "REWIND THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "REWIND THEN\n\t${1:then_statements}\nEND ELSE\n\t${2:else_statements}\nEND"
            },
            {
                "key": "RND",
                "icon": 3,
                "documentation": "The UniBasic RND function returns a random integer from 0 through num.expr minus 1.",
                "detail": "RND($expr)",
                "snippet": "RND(${1:expr})"
            },
            {
                "key": "RNDSEED",
                "icon": 14,
                "documentation": "The UniBasic RNDSEED command enables you to \u201cseed\u201d the pseudo random number generator. The RND function gives you a different sequence of numbers each time. RNDSEED generates the same sequence of random numbers each time you run a program with the same seed. expr is a numeric seed point. Each time you use the same expr, RND generates the same sequence of random numbers.",
                "detail": "RNDSEED $expr",
                "snippet": "RNDSEED ${1:expr}"
            },
            {
                "key": "RQM",
                "icon": 3,
                "documentation": "RQM is a synonym for the SLEEP function",
                "detail": "RQM $seconds",
                "snippet": "RQM ${1:seconds}"
            },
            {
                "key": "SADD",
                "icon": 3,
                "documentation": "The UniBasic SADD function adds two string numbers and returns the result as a string number. SADD is the string addition function. Arguments can be any valid numbers or string numbers of any magnitude or precision.",
                "detail": "SADD($1, $2)",
                "snippet": "SADD($1, $2)"
            },
            {
                "key": "saveSecurityContext",
                "icon": 3,
                "documentation": "The saveSecurityContext() function encrypts and saves a security context to a system security file. UniData maintains this file on a per account basis for. and uses the name as the record ID to access the saved security information. Since the information is encrypted, you should not attempt to directly manipulate the information.",
                "detail": "saveSecurityContext($context, $name, $passPhrase)",
                "snippet": "saveSecurityContext(${1:context}, ${2:name}, ${3:passPhrase})"
            },
            {
                "key": "SCMP",
                "icon": 3,
                "documentation": "The UniBasic SCMP function compares two string numbers and returns a value depending on the result of the comparison. Arguments can be any valid numbers or string numbers of any magnitude or precision. If x or y contains nonnumeric data, UniData displays an error message, and the comparison returns 0.",
                "detail": "SCMP($1, $2)",
                "snippet": "SCMP($1, $2)"
            },
            {
                "key": "SDIV",
                "icon": 3,
                "documentation": "The UniBasic SDIV function divides two string numbers and returns the result as a string number. SDIV divides x by y. Arguments can be any valid numbers or string numbers of any magnitude or precision. However, result precision is limited to 14 significant digits.",
                "detail": "SDIV($1, $2)",
                "snippet": "SDIV($1, $2)"
            },
            {
                "key": "SELECT",
                "icon": 14,
                "documentation": "The UniBasic SELECT command creates an active select list of all record IDs in a file. Records appear in the list in the order in which they are stored in the file.",
                "detail": "SELECT $variable1 TO $list ON ERROR $err_statements",
                "snippet": "SELECT ${1:variable1} TO ${2:list} ON ERROR ${3:err_statements}"
            },
            {
                "key": "SELECTINDEX",
                "icon": 14,
                "documentation": "The UniBasic SELECTINDEX command creates a select list based on an alternate key index.",
                "detail": "SELECTINDEX $indexname, $val FROM $filevar TO $listno",
                "snippet": "SELECTINDEX ${1:indexname}, ${2:val} FROM ${3:filevar} TO ${4:listno}"
            },
            {
                "key": "SELECTINFO",
                "icon": 3,
                "documentation": "The UniBasic SELECTINFO function returns the state of a select list. list.num.expr is an expression evaluating to the number of the select list (0-9).",
                "detail": "SELECTINFO($listnum, 1)",
                "snippet": "SELECTINFO(${1:listnum}, 1)"
            },
            {
                "key": "SEND",
                "icon": 14,
                "documentation": "The UniBasic SEND command sends output data to a specified line. You usually use SEND after a line is attached.",
                "detail": "SEND $output TO $filevar THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "SEND ${1:output} TO ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "SEQ",
                "icon": 3,
                "documentation": "The UniBasic SEQ function converts a single character to its ASCII code value. The SEQ function is the complement of the CHAR function. SEQ supports multibyte languages.",
                "detail": "SEQ($char)",
                "snippet": "SEQ(${1:char})"
            },
            {
                "key": "SEQS",
                "icon": 3,
                "documentation": "The UniBasic SEQS function converts the first character in each element of a dynamic array to its ASCII code value. SEQS supports multibyte languages.",
                "detail": "SEQS($DynArr)",
                "snippet": "SEQS(${1:DynArr})"
            },
            {
                "key": "setAuthenticationDepth",
                "icon": 3,
                "documentation": "The setAuthenticationDepth() function sets how deeply UniData should verify before deciding that a certificate is not valid.",
                "detail": "setAuthenticationDepth($context, $depth, $serverOrClient)",
                "snippet": "setAuthenticationDepth(${1:context}, ${2:depth}, ${3:serverOrClient})"
            },
            {
                "key": "setCipherSuite",
                "icon": 3,
                "documentation": "The setCipherSuite() function enables you to identify which cipher suites to support for the specified context. It affects the cipher suites and public key algorithms supported during the SSL\/TLS handshake and subsequent data exchanges.",
                "detail": "setCipherSuite($context, $cipherSpecs)",
                "snippet": "setCipherSuite(${1:context}, ${2:cipherSpecs})"
            },
            {
                "key": "setClientAuthentication",
                "icon": 3,
                "documentation": "The setClientAuthentication() function turns client authentication for a server socket on or off. When option is set to on, during the initial SSL handshake, the server sends a client authentication request to the client. It will also receive the client certificate and perform authentication according to the issuer\u2019s certificate (or certificate chain) set in the security context.",
                "detail": "setClientAuthentication($context, $option)",
                "snippet": "setClientAuthentication(${1:context}, ${2:option})"
            },
            {
                "key": "SETENV",
                "icon": 3,
                "documentation": "Use the SETENV function to set an environment variable from UniBasic.",
                "detail": "SETENV($var_name, $value)",
                "snippet": "SETENV(${1:var_name}, ${2:value})"
            },
            {
                "key": "setHTTPDefault",
                "icon": 3,
                "documentation": "The setHTTPDefault function configures the default HTTP settings, including proxy server and port, buffer size, authentication credential, HTTP version, and request header values. UniBasic uses these settings with every HTTP request that follows.",
                "detail": "setHTTPDefault($opt, $val)",
                "snippet": "setHTTPDefault(${1:opt}, ${2:val})"
            },
            {
                "key": "setIpv",
                "icon": 3,
                "documentation": "The setIpv function configures which IP setting to use; IPv4 or IPv6. If the machine is IPv6 enabled, all server side sockets will use IPv6, which can accept client connections on both IPv4 and IPv6. If the machine is not IPv6 enabled, server and client will remain working on IPv4. This function can accept one or two options. For example, setIpv(IPV6) or setIpv(IPV6,SOCKET).",
                "detail": "setIpv($opt, $sockettype)",
                "snippet": "setIpv(${1:opt}, ${2:sockettype})"
            },
            {
                "key": "SETINDEX",
                "icon": 14,
                "documentation": "The UniBasic SETINDEX command sets a pointer to a key in an alternate key index.",
                "detail": "SETINDEX $indexname ON $filevar",
                "snippet": "SETINDEX ${1:indexname} ON ${2:filevar}"
            },
            {
                "key": "setPrivateKey",
                "icon": 3,
                "documentation": "The setPrivateKey() function loads the private key into a security context so that it can be used by SSL functions. If the context already had a set private key, it will be replaced.",
                "detail": "setPrivateKey($key, $format, $keyLoc, $passPhrase, $validate, $context)",
                "snippet": "setPrivateKey(${1:key}, ${2:format}, ${3:keyLoc}, ${4:passPhrase}, ${5:validate}, ${6:context})"
            },
            {
                "key": "setRandomSeed",
                "icon": 3,
                "documentation": "The setRandomSeed() function generates a random seed file from a series of source files and sets that file as the default seed file for the supplied security context.",
                "detail": "setRandomSeed($inFiles, $outFile, $length, $context)",
                "snippet": "setRandomSeed(${1:inFiles}, ${2:outFile}, ${3:length}, ${4:context})"
            },
            {
                "key": "setRequestHeader",
                "icon": 3,
                "documentation": "The setRequestHeader function allows the user to set additional headers for a request.",
                "detail": "setRequestHeader($request_handle, $header_name, $header_value)",
                "snippet": "setRequestHeader(${1:request_handle}, ${2:header_name}, ${3:header_value})"
            },
            {
                "key": "setSocketOptions",
                "icon": 3,
                "documentation": "The setSocketOptions() function sets the current value for a socket option associated with a socket of any type.",
                "detail": "setSocketOptions($socket_handle, $options)",
                "snippet": "setSocketOptions(${1:socket_handle}, ${2:options})"
            },
            {
                "key": "showSecurityContext",
                "icon": 3,
                "documentation": "The showSecurityContext() function dumps the SSL configuration parameters of a security context into a readable format.",
                "detail": "showSecurityContext($context, $config)",
                "snippet": "showSecurityContext(${1:context}, ${2:config})"
            },
            {
                "key": "SIGNATURE",
                "icon": 3,
                "documentation": "The SIGNATURE() function generates a digital signature or verifies a signature using the supplied key.",
                "detail": "SIGNATURE($algorithm, $action, $data, $dataLoc, $key, $keyLoc, $keyFmt, $pass, $sigIn, $result)",
                "snippet": "SIGNATURE(${1:algorithm}, ${2:action}, ${3:data}, ${4:dataLoc}, ${5:key}, ${6:keyLoc}, ${7:keyFmt}, ${8:pass}, ${9:sigIn}, ${10:result})"
            },
            {
                "key": "SIN",
                "icon": 3,
                "documentation": "The UniBasic SIN function returns the trigonometric sine of the numeric expression num.expr.",
                "detail": "SIN($expr)",
                "snippet": "SIN(${1:expr})"
            },
            {
                "key": "SLEEP",
                "icon": 14,
                "documentation": "The UniBasic SLEEP and RQM commands halt program execution for the time specified in seconds, or until the time specified.",
                "detail": "SLEEP $seconds",
                "snippet": "SLEEP ${1:seconds}"
            },
            {
                "key": "SMUL",
                "icon": 3,
                "documentation": "The UniBasic SMUL function multiplies two string numbers and returns the result as a string number. Arguments can be any valid numbers or string numbers of any magnitude or precision. Using string numbers rather than standard numbers degrades processing speed.",
                "detail": "SMUL($1, $2)",
                "snippet": "SMUL($1, $2)"
            },
            {
                "key": "SOAPCreateRequest",
                "icon": 0,
                "documentation": "Creates a SOAP request and returns a handle to the request.",
                "detail": "SOAPCreateRequest($URL, $soapAction, $Request)",
                "snippet": "SOAPCreateRequest(${1:URL}, ${2:soapAction}, ${3:Request})"
            },
            {
                "key": "SOAPCreateSecureRequest",
                "icon": 3,
                "documentation": "The SOAPCreateSecureRequest function creates a secure SOAP request and returns a handle to the request.",
                "detail": "SOAPCreateSecureRequest($URL, $soapAction, $Request, $security_context)",
                "snippet": "SOAPCreateSecureRequest(${1:URL}, ${2:soapAction}, ${3:Request}, ${4:security_context})"
            },
            {
                "key": "SOAPGetDefault",
                "icon": 0,
                "documentation": "Gets default SOAP settings, such as the SOAP version.",
                "detail": "SOAPGetDefault($option, $value)",
                "snippet": "SOAPGetDefault(${1:option}, ${2:value})"
            },
            {
                "key": "SOAPGetFault",
                "icon": 0,
                "documentation": "Parses the response data from SOAPSubmitRequest after receiving a SOAP Fault, into a dynamic array of SOAP Fault components.",
                "detail": "SOAPGetFault($respData, $soapFault)",
                "snippet": "SOAPGetFault(${1:respData}, ${2:soapFault})"
            },
            {
                "key": "SOAPGetResponseHeader",
                "icon": 0,
                "documentation": "Gets a specific response header after issuing a SOAP request.",
                "detail": "SOAPGetResponseHeader($Request, $headerName, $headerValue)",
                "snippet": "SOAPGetResponseHeader(${1:Request}, ${2:headerName}, ${3:headerValue})"
            },
            {
                "key": "SOAPRequestWrite",
                "icon": 0,
                "documentation": "Outputs the SOAP request in XML format to a string or to a file.",
                "detail": "SOAPRequestWrite($Request, $reqDoc, $docTypeFlag)",
                "snippet": "SOAPRequestWrite(${1:Request}, ${2:reqDoc}, ${3:docTypeFlag})"
            },
            {
                "key": "SOAPSetDefault",
                "icon": 0,
                "documentation": "Setup default SOAP settings, such as SOAP version.",
                "detail": "SOAPSetDefault($option, $value)",
                "snippet": "SOAPSetDefault(${1:option}, ${2:value})"
            },
            {
                "key": "SOAPSetParameters",
                "icon": 0,
                "documentation": "Sets up the SOAP request body, specifying a remote method to call along with the method's parameter list.",
                "detail": "SOAPSetParameters($Request, $URI, $serviceName, $value)",
                "snippet": "SOAPSetParameters(${1:Request}, ${2:URI}, ${3:serviceName}, ${4:value})"
            },
            {
                "key": "SOAPSetRequestBody",
                "icon": 3,
                "documentation": "Sets up a SOAP request body directly, as opposed to having it be constructed through the SOAPSetParameters function. With this function it also possible to attach multiple body blocks to the SOAP request.",
                "detail": "SOAPSetRequestBody($Request, $value)",
                "snippet": "SOAPSetRequestBody(${1:Request}, ${2:value})"
            },
            {
                "key": "SOAPSetRequestContent",
                "icon": 0,
                "documentation": "Sets the entire SOAP request's content from an input string or from a file.",
                "detail": "SOAPSetRequestContent($Request, $reqDoc, $docTypeFlag)",
                "snippet": "SOAPSetRequestContent(${1:Request}, ${2:reqDoc}, ${3:docTypeFlag})"
            },
            {
                "key": "SOAPSetRequestHeader",
                "icon": 0,
                "documentation": "Sets up a SOAP request header. By default, there is no SOAP header.",
                "detail": "SOAPSetRequestHeader($Request, $value)",
                "snippet": "SOAPSetRequestHeader(${1:Request}, ${2:value})"
            },
            {
                "key": "SOAPSubmitRequest",
                "icon": 0,
                "documentation": "Submits a request and gets the response.",
                "detail": "SOAPSubmitRequest($Request, $timeout, $respHeaders, $respData, $soapStatus)",
                "snippet": "SOAPSubmitRequest(${1:Request}, ${2:timeout}, ${3:respHeaders}, ${4:respData}, ${5:soapStatus})"
            },
            {
                "key": "SORT",
                "icon": 3,
                "documentation": "The SORT function enables you to sort a dynamic array.",
                "detail": "SORT($keycnt)",
                "snippet": "SORT(${1:keycnt})"
            },
            {
                "key": "SOUNDEX",
                "icon": 3,
                "documentation": "The UniBasic SOUNDEX function converts an expression into a phonetic code. This function can return unpredictable results with multibyte characters.",
                "detail": "SOUNDEX($str)",
                "snippet": "SOUNDEX(${1:str})"
            },
            {
                "key": "SPACE",
                "icon": 3,
                "documentation": "The UniBasic SPACE function returns a string containing the specified number of spaces.",
                "detail": "SPACE($cnt)",
                "snippet": "SPACE(${1:cnt})"
            },
            {
                "key": "SPACES",
                "icon": 3,
                "documentation": "The UniBasic SPACES function returns the number of spaces specified in each element of the dynamic array dyn.array.expr.",
                "detail": "SPACES($DynArr)",
                "snippet": "SPACES(${1:DynArr})"
            },
            {
                "key": "SPLICE",
                "icon": 3,
                "documentation": "The UniBasic SPLICE function concatenates two strings or arrays and inserts an expression between them.",
                "detail": "SPLICE($array1, $str, $array2)",
                "snippet": "SPLICE(${1:array1}, ${2:str}, ${3:array2})"
            },
            {
                "key": "SQLAllocConnect",
                "icon": 0,
                "documentation": "SQLAllocConnect allocates and initializes a connection environment in a UniData BCI environment.",
                "detail": "SQLAllocConnect($bcienv, $connectenv)",
                "snippet": "SQLAllocConnect(${1:bcienv}, ${2:connectenv})"
            },
            {
                "key": "SQLAllocEnv",
                "icon": 0,
                "documentation": "SQLAllocEnv creates an environment in which to execute UniData BCI calls.",
                "detail": "SQLAllocEnv($bcienv)",
                "snippet": "SQLAllocEnv(${1:bcienv})"
            },
            {
                "key": "SQLAllocStmt",
                "icon": 0,
                "documentation": "SQLAllocStmt creates an SQL statement environment in which to execute SQL statements.",
                "detail": "SQLAllocStmt($connect.env, $statement.env)",
                "snippet": "SQLAllocStmt(${1:connect}.env, ${2:statement}.env)"
            },
            {
                "key": "SQLBindCol",
                "icon": 3,
                "documentation": "Use this function to tell UniData BCI where to return the results of an SQLFetch call. SQLBindCol defines the name of the variable (column) to contain column results retrieved by SQLFetch, and specifies the data conversion (data.type) on the fetched data. SQLBindCol has no effect until SQLFetch is used.",
                "detail": "SQLBindCol($statementenv, $col, $datatype, $column)",
                "snippet": "SQLBindCol(${1:statementenv}, ${2:col}, ${3:datatype}, ${4:column})"
            },
            {
                "key": "SQLBindParameter",
                "icon": 0,
                "documentation": "SQLBindParameter specifies where to find values for input parameter markers when you issue an SQLExecute or SQLExecDirect call. For output parameter markers, SQLBindParameter specifies where to find the return value of a called procedure.",
                "detail": "SQLBindParameter($statementenv, $mrk, $datatype, $sqltype, $prec, $scale, $param, $paramtype)",
                "snippet": "SQLBindParameter(${1:statementenv}, ${2:mrk}, ${3:datatype}, ${4:sqltype}, ${5:prec}, ${6:scale}, ${7:param}, ${8:paramtype})"
            },
            {
                "key": "SQLCancel",
                "icon": 3,
                "documentation": "This function is equivalent to the SQLFreeStmt call with the SQL.CLOSE option. It closes any open cursor associated with the SQL statement environment and discards pending results at the data source.",
                "detail": "SQLCancel($statementenv)",
                "snippet": "SQLCancel(${1:statementenv})"
            },
            {
                "key": "SQLColAttributes",
                "icon": 3,
                "documentation": "Use this function to get information about a column. SQLColAttributes returns the specific information requested by the value of col.attribute.",
                "detail": "SQLColAttributes($statementenv, $col, $colattr, $textvar, $numvar)",
                "snippet": "SQLColAttributes(${1:statementenv}, ${2:col}, ${3:colattr}, ${4:textvar}, ${5:numvar})"
            },
            {
                "key": "SQLColumns",
                "icon": 3,
                "documentation": "This function returns a result set in statement.env as a cursor of 12 columns describing those columns found by the search pattern (see SQLTables). As with SQLTables, the search is done on the SQL catalog. This is a standard result set that can be accessed with SQLFetch. The ability to obtain descriptions of columns does not imply that a user has any privileges on those columns.",
                "detail": "SQLColumns($statementenv, $schema, $owner, $tablename, $columnname)",
                "snippet": "SQLColumns(${1:statementenv}, ${2:schema}, ${3:owner}, ${4:tablename}, ${5:columnname})"
            },
            {
                "key": "SQLConnect",
                "icon": 3,
                "documentation": "Use this function to connect to the ODBC data source specified by data.source. Use the login1 and login2 parameters to log in to the DBMS specified by the ODBC data.source.",
                "detail": "SQLConnect($connectenv, $datasource, $login1, $login2)",
                "snippet": "SQLConnect(${1:connectenv}, ${2:datasource}, ${3:login1}, ${4:login2})"
            },
            {
                "key": "SQLDescribeCol",
                "icon": 3,
                "documentation": "Use this function to get information about the column described by col#.",
                "detail": "SQLDescribeCol($statementenv, $col, $colname, $sqltype, $prec, $scale, $null)",
                "snippet": "SQLDescribeCol(${1:statementenv}, ${2:col}, ${3:colname}, ${4:sqltype}, ${5:prec}, ${6:scale}, ${7:null})"
            },
            {
                "key": "SQLDisconnect",
                "icon": 0,
                "documentation": "SQLDisconnect disconnects a connection environment from a data source.",
                "detail": "SQLDisconnect($connectenv)",
                "snippet": "SQLDisconnect(${1:connectenv})"
            },
            {
                "key": "SQLError",
                "icon": 0,
                "documentation": "SQLError returns error status information about one of the three environments you use.",
                "detail": "SQLError($bcienv, $connectenv, $statementenv, $sqlstate, $dbmscode, $error)",
                "snippet": "SQLError(${1:bcienv}, ${2:connectenv}, ${3:statementenv}, ${4:sqlstate}, ${5:dbmscode}, ${6:error})"
            },
            {
                "key": "SQLExecDirect",
                "icon": 0,
                "documentation": "SQLExecDirect accepts an SQL statement or procedure call and delivers it to the data source for execution. It uses the current values of any SQL statement parameter markers.",
                "detail": "SQLExecDirect($statementenv, $statement)",
                "snippet": "SQLExecDirect(${1:statementenv}, ${2:statement})"
            },
            {
                "key": "SQLExecute",
                "icon": 3,
                "documentation": "Use this function to repeatedly execute an SQL statement, using different values for parameter markers. You must use an SQLPrepare call to prepare the SQL statement before you can use SQLExecute. If the SQL statement specified in the SQLPrepare call contains parameter markers, you must also issue an SQLBindParameter call for each marker in the SQL statement before you use SQLExecute. After you load the parameter marker variables with data to send to the data source, you can issue the SQLExecute call. By setting new values in the parameter marker variables and calling SQLExecute, new data values are sent to the data source and the SQL statement is executed using those values",
                "detail": "SQLExecute($statementenv)",
                "snippet": "SQLExecute(${1:statementenv})"
            },
            {
                "key": "SQLFetch",
                "icon": 3,
                "documentation": "Use this function to retrieve the next row\u2019s column values from the result set at the data source and put them into the variables specified with SQLBindCol. SQLFetch performs any required data conversions.",
                "detail": "SQLFetch($statementenv)",
                "snippet": "SQLFetch(${1:statementenv})"
            },
            {
                "key": "SQLFreeConnect",
                "icon": 0,
                "documentation": "SQLFreeConnect releases a connection environment and its resources. You must use SQLDisconnect to disconnect the connection environment from the data source before you release the connection environment with SQLFreeConnect, otherwise an error is returned.",
                "detail": "SQLFreeConnect($connectenv)",
                "snippet": "SQLFreeConnect(${1:connectenv})"
            },
            {
                "key": "SQLFreeEnv",
                "icon": 0,
                "documentation": "SQLFreeEnv releases an SQL Client Interface environment and its resources. You must use SQLFreeConnect to release all connection environments attached to the UniData BCI environment before you release the UniData BCI environment with SQLFreeEnv, otherwise an error is returned.",
                "detail": "SQLFreeEnv($bcienv)",
                "snippet": "SQLFreeEnv(${1:bcienv})"
            },
            {
                "key": "SQLFreeStmt",
                "icon": 0,
                "documentation": "SQLFreeStmt frees some or all resources associated with an SQL statement environment.",
                "detail": "SQLFreeStmt($statementenv, $option)",
                "snippet": "SQLFreeStmt(${1:statementenv}, ${2:option})"
            },
            {
                "key": "SQLGetInfo",
                "icon": 3,
                "documentation": "SQLGetInfo returns general information about the ODBC driver and the data source. This function supports all of the possible requests for information defined in the ODBC 2.0 specification. The #defines for info.type are contained in the ODBC.H include file.",
                "detail": "SQLGetInfo($connectenv, $infotype, $infovalue)",
                "snippet": "SQLGetInfo(${1:connectenv}, ${2:infotype}, ${3:infovalue})"
            },
            {
                "key": "SQLGetTypeInfo",
                "icon": 0,
                "documentation": "SQLGetTypeInfo returns information about an SQL on the data source. You can use SQLGetTypeInfo only against ODBC data sources. SQLGetTypeInfo returns a standard result set ordered by DATA.TYPE and TYPE.NAME.",
                "detail": "SQLGetTypeInfo($statementenv, $sqltype)",
                "snippet": "SQLGetTypeInfo(${1:statementenv}, ${2:sqltype})"
            },
            {
                "key": "SQLNumParams",
                "icon": 3,
                "documentation": "SQLNumParams returns the number of parameters in an SQL statement. Use this function after preparing or executing an SQL statement or procedure call to find the number of parameters in an SQL statement. If the statement associated with statement.env contains no parameters, parameters is set to 0.",
                "detail": "SQLNumParams($statementenv, $params)",
                "snippet": "SQLNumParams(${1:statementenv}, ${2:params})"
            },
            {
                "key": "SQLNumResultCols",
                "icon": 3,
                "documentation": "SQLNumResultCols returns the number of columns in a result set. Use this function after executing an SQL statement to find the number of columns in the result set. If the executed statement was not a SELECT statement or a called procedure that produced a result set, the number of result columns returned is 0. Use this function when the number of columns to be bound to application variables is unknown, for example, when your program is processing SQL statements entered by users.",
                "detail": "SQLNumResultCols($statementenv, $cols)",
                "snippet": "SQLNumResultCols(${1:statementenv}, ${2:cols})"
            },
            {
                "key": "SQLParamOptions",
                "icon": 3,
                "documentation": "SQLParamOptions lets applications load an array of parameter markers in a single SQLExecDirect or SQLExecute function call. Use this function only when you are connected to an ODBC data source.",
                "detail": "SQLParamOptions($statementenv, $option, $value)",
                "snippet": "SQLParamOptions(${1:statementenv}, ${2:option}, ${3:value})"
            },
            {
                "key": "SQLPrepare",
                "icon": 0,
                "documentation": "SQLPrepare passes an SQL statement or procedure call to the data source in order to prepare it for execution by SQLExecute.",
                "detail": "SQLPrepare($statementenv, $statement)",
                "snippet": "SQLPrepare(${1:statementenv}, ${2:statement})"
            },
            {
                "key": "SQLRowCount",
                "icon": 0,
                "documentation": "SQLRowCount returns the number of rows changed by UPDATE, INSERT, or DELETE statements, or by a called procedure that executes one of these statements.",
                "detail": "SQLRowCount($statementenv, $rows)",
                "snippet": "SQLRowCount(${1:statementenv}, ${2:rows})"
            },
            {
                "key": "SQLSetConnectOption",
                "icon": 0,
                "documentation": "SQLSetConnectOption controls some aspects of the connection to a data source.",
                "detail": "SQLSetConnectOption($connectenv, $option, $value)",
                "snippet": "SQLSetConnectOption(${1:connectenv}, ${2:option}, ${3:value})"
            },
            {
                "key": "SQLSetParam",
                "icon": 0,
                "documentation": "SQLSetParam is a synonym for SQLBindParameter.",
                "detail": "SQLSetParam($statementenv, $mrk, $datatype, $sqltype, $prec, $scale, $param, $paramtype)",
                "snippet": "SQLSetParam(${1:statementenv}, ${2:mrk}, ${3:datatype}, ${4:sqltype}, ${5:prec}, ${6:scale}, ${7:param}, ${8:paramtype})"
            },
            {
                "key": "SQLSpecialColumns",
                "icon": 0,
                "documentation": "SQLSpecialColumns gets information about columns in a table.",
                "detail": "SQLSpecialColumns($statementenv, $coltype, $schema, $owner, $tablename, $IDscope, $null)",
                "snippet": "SQLSpecialColumns(${1:statementenv}, ${2:coltype}, ${3:schema}, ${4:owner}, ${5:tablename}, ${6:IDscope}, ${7:null})"
            },
            {
                "key": "SQLStatistics",
                "icon": 3,
                "documentation": "SQLStatistics gets a list of statistics about a single table and its indexes. Use this function only when you are connected to an ODBC data source. SQLStatistics returns information as a standard result set ordered by NON.UNIQUE, TYPE, INDEX.QUALIFIER, INDEX.NAME, and SEQ.IN.INDEX. The result set combines statistics for the table with statistics for each index.",
                "detail": "SQLStatistics($statementenv, $schema, $owner, $tablename, $indextype, $accuracy)",
                "snippet": "SQLStatistics(${1:statementenv}, ${2:schema}, ${3:owner}, ${4:tablename}, ${5:indextype}, ${6:accuracy})"
            },
            {
                "key": "SQLTables",
                "icon": 3,
                "documentation": "SQLTables returns a result set listing the tables matching the search patterns. Use this function only when you are connected to an ODBC data source.",
                "detail": "SQLTables($statementenv, $schema, $owner, $tablename, $type)",
                "snippet": "SQLTables(${1:statementenv}, ${2:schema}, ${3:owner}, ${4:tablename}, ${5:type})"
            },
            {
                "key": "SQLTransact",
                "icon": 3,
                "documentation": "SQLTransact requests a COMMIT or ROLLBACK for all SQL statements associated with a connection or all connections associated with an environment. Use this function only when you are connected to an ODBC data source.",
                "detail": "SQLTransact($bcienv, $connectenv, $type)",
                "snippet": "SQLTransact(${1:bcienv}, ${2:connectenv}, ${3:type})"
            },
            {
                "key": "SQRT",
                "icon": 3,
                "documentation": "The UniBasic SQRT function returns the square root of a positive numeric argument.",
                "detail": "SQRT($expr)",
                "snippet": "SQRT(${1:expr})"
            },
            {
                "key": "SQUOTE",
                "icon": 3,
                "documentation": "The UniBasic SQUOTE function encloses a string with single quotation marks.",
                "detail": "SQUOTE($expr)",
                "snippet": "SQUOTE(${1:expr})"
            },
            {
                "key": "SSUB",
                "icon": 3,
                "documentation": "The UniBasic SSUB function subtracts the second string number from the first string number and returns the result as a string number. Arguments can be any valid numbers or string numbers of any magnitude or precision.",
                "detail": "SSUB($1, $2)",
                "snippet": "SSUB($1, $2)"
            },
            {
                "key": "STATUS",
                "icon": 14,
                "documentation": "The UniBasic STATUS function returns a code indicating the condition of the command or function just executed. Several UniBasic commands and functions set STATUS function return values.",
                "detail": "STATUS()",
                "snippet": "STATUS()"
            },
            {
                "key": "STOP",
                "icon": 14,
                "documentation": "The UniBasic STOP command halts execution of the current program. If you specify an expression, UniData prints the expression on the display terminal before halting the program. expr can contain variables, functions, and arithmetic or string operators.",
                "detail": "STOP $1",
                "snippet": "STOP $1"
            },
            {
                "key": "STR",
                "icon": 3,
                "documentation": "The UniBasic STR function returns a string composed of a number of repetitions of a string.",
                "detail": "STR($str, $cnt)",
                "snippet": "STR(${1:str}, ${2:cnt})"
            },
            {
                "key": "STRS",
                "icon": 3,
                "documentation": "The UniBasic STRS function returns each element of dyn.array the number of times specified in expr.",
                "detail": "STRS($DynArr, $count)",
                "snippet": "STRS(${1:DynArr}, ${2:count})"
            },
            {
                "key": "submitRequest",
                "icon": 3,
                "documentation": "The submitRequest function submits a request and gets a response.",
                "detail": "submitRequest($request_handle, $time_out, $post_data, $response_headers, $response_data, $http_status)",
                "snippet": "submitRequest(${1:request_handle}, ${2:time_out}, ${3:post_data}, ${4:response_headers}, ${5:response_data}, ${6:http_status})"
            },
            {
                "key": "SUBROUTINE Skeleton",
                "icon": 14,
                "documentation": "The UniBasic SUBROUTINE command determines the beginning of an external subroutine.",
                "detail": "SUBROUTINE $1($2)\n*-----\n* Description : $3\n* Author      : $4\n* Date        : $5\n*-----\n     \\$INCLUDE Common\n*-----\n     Gosub Initialise\n*-----\n      $6\n*-----\nExitProgram:\n*-----\n     Return\n     End\n*-----\nInitialise:\n*-----\n\n     Return",
                "snippet": "SUBROUTINE $1($2)\n*-----\n* Description : $3\n* Author      : $4\n* Date        : $5\n*-----\n     \\${6:INCLUDE} Common\n*-----\n     Gosub Initialise\n*-----\n      $7\n*-----\nExitProgram:\n*-----\n     Return\n     End\n*-----\nInitialise:\n*-----\n\n     Return"
            },
            {
                "key": "SUBSTRINGS",
                "icon": 3,
                "documentation": "The UniBasic SUBSTRINGS function extracts strings from elements within a dynamic array. SUBSTRINGS supports multibyte languages.",
                "detail": "SUBSTRINGS($DynArr, $start, $length)",
                "snippet": "SUBSTRINGS(${1:DynArr}, ${2:start}, ${3:length})"
            },
            {
                "key": "SUM",
                "icon": 3,
                "documentation": "The UniBasic SUM function adds the numeric values in the dynamic array dyn.array according to dynamic array delimiters. SUM begins with the lowest level of delimiter and sums all values to the next level. You can input a range, starting position, and level at which to perform the sum.",
                "detail": "SUM($DynArr)",
                "snippet": "SUM(${1:DynArr})"
            },
            {
                "key": "SWAP",
                "icon": 14,
                "documentation": "The UniBasic SWAP command replaces all occurrences of one substring with a second substring. The search string does not have to be the same length as the replacement string. SWAP supports mulitbyte languages.",
                "detail": "SWAP $search WITH $replace IN $var",
                "snippet": "SWAP ${1:search} WITH ${2:replace} IN ${3:var}"
            },
            {
                "key": "SYSTEM",
                "icon": 14,
                "documentation": "The UniBasic SYSTEM function retrieves certain system-level parameters set by UniBasic statements or by ECL commands such as SETPTR, TERM, and query statements.",
                "detail": "SYSTEM($key)",
                "snippet": "SYSTEM(${1:key})"
            },
            {
                "key": "TAN",
                "icon": 3,
                "documentation": "The UniBasic TAN function returns the trigonometric tangent of a numeric expression, num.expr.",
                "detail": "TAN($expr)",
                "snippet": "TAN(${1:expr})"
            },
            {
                "key": "TIME",
                "icon": 3,
                "documentation": "The UniBasic TIME function returns the time of day in internal format, expressed as the number of seconds elapsed since midnight.",
                "detail": "TIME()",
                "snippet": "TIME()"
            },
            {
                "key": "TIMEDATE",
                "icon": 3,
                "documentation": "The UniBasic TIMEDATE function returns a string representation of the current time and date in the following external format: hh:mm:ss dd mmm yyyy",
                "detail": "TIMEDATE()",
                "snippet": "TIMEDATE()"
            },
            {
                "key": "TRANSACTION ABORT",
                "icon": 14,
                "documentation": "The UniBasic TRANSACTION ABORT command cancels the active transaction. UniData discards the pending writes. As a result, other users never know that the transaction was in progress, and none of the updates associated with the transaction take place.",
                "detail": "TRANSACTION ABORT",
                "snippet": "TRANSACTION ABORT"
            },
            {
                "key": "TRANSACTION COMMIT",
                "icon": 14,
                "documentation": "The UniBasic TRANSACTION COMMIT command concludes the active transaction. UniData writes all pending writes to the appropriate files. You must specify a THEN clause or an ELSE clause. You can specify both clauses.",
                "detail": "TRANSACTION COMMIT THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "TRANSACTION COMMIT THEN\n\t${1:then_statements}\nEND ELSE\n\t${2:else_statements}\nEND"
            },
            {
                "key": "TRANSACTION START",
                "icon": 14,
                "documentation": "The UniBasic TRANSACTION START command initiates a new transaction, storing all updates until a TRANSACTION COMMIT or TRANSACTION ABORT statement executes.",
                "detail": "TRANSACTION START THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "TRANSACTION START THEN\n\t${1:then_statements}\nEND ELSE\n\t${2:else_statements}\nEND"
            },
            {
                "key": "TRIM",
                "icon": 3,
                "documentation": "The UniBasic TRIM function removes all spaces or every occurrence of a specified character from a string expression. If UniData does not find an occurrence of the specified character, the string remains unchanged. TRIM removes leading or trailing occurrences of the specified character from a string, and converts embedded spaces or occurrences of the specified characters in a string to one space or a specified character. UniData does not remove single spaces or occurrences of the specified character embedded in the string.",
                "detail": "TRIM($str, $char, $mode)",
                "snippet": "TRIM(${1:str}, ${2:char}, ${3:mode})"
            },
            {
                "key": "TRIMB",
                "icon": 3,
                "documentation": "The UniBasic TRIMB function removes any trailing spaces from a string expression. If UniData does not find any trailing spaces, the string remains unchanged.",
                "detail": "TRIMB($str)",
                "snippet": "TRIMB(${1:str})"
            },
            {
                "key": "TRIMF",
                "icon": 3,
                "documentation": "The UniBasic TRIMF function removes any leading spaces from the string expression. If UniData does not find any leading spaces, the string remains unchanged.",
                "detail": "TRIMF($str)",
                "snippet": "TRIMF(${1:str})"
            },
            {
                "key": "TRIMS",
                "icon": 3,
                "documentation": "The UniBasic TRIMS function removes any spaces from each element of a dynamic array. If UniData does not find any spaces, the element remains unchanged. TRIMS removes any leading or trailing spaces from a string and converts any contiguous spaces in a string to one space. Single blanks between text are not removed.",
                "detail": "TRIMS($str, $char, $mode)",
                "snippet": "TRIMS(${1:str}, ${2:char}, ${3:mode})"
            },
            {
                "key": "UDOArrayAppendItem",
                "icon": 3,
                "documentation": "The UDOArrayAppendItem() function appends the item you specify to the UDO array.",
                "detail": "UDOArrayAppendItem($udoHandle, $value)",
                "snippet": "UDOArrayAppendItem(${1:udoHandle}, ${2:value})"
            },
            {
                "key": "UDOArrayDeleteItem",
                "icon": 3,
                "documentation": "The UDOArrayDeleteItem() function deletes the array item you specify by its index.",
                "detail": "UDOArrayDeleteItem($udoHandle, $index)",
                "snippet": "UDOArrayDeleteItem(${1:udoHandle}, ${2:index})"
            },
            {
                "key": "UDOArrayGetItem",
                "icon": 3,
                "documentation": "The UDOArrayGetItem() function returns a UDO array item by its index.",
                "detail": "UDOArrayGetItem($udoHandle, $index, $value, $value_type)",
                "snippet": "UDOArrayGetItem(${1:udoHandle}, ${2:index}, ${3:value}, ${4:value_type})"
            },
            {
                "key": "UDOArrayGetNextItem",
                "icon": 3,
                "documentation": "The UDOArrayGetNextItem() function returns the next UDO array item relative to the current position, which is the position of the array the last time it was accessed by this function. The initial position is 1.",
                "detail": "UDOArrayGetNextItem($udoHandle, $value, $type)",
                "snippet": "UDOArrayGetNextItem(${1:udoHandle}, ${2:value}, ${3:type})"
            },
            {
                "key": "UDOArrayGetSize",
                "icon": 3,
                "documentation": "The UDOArrayGetSize() function gets the size of a UDO array.",
                "detail": "UDOArrayGetSize($udoHandle, $size)",
                "snippet": "UDOArrayGetSize(${1:udoHandle}, ${2:size})"
            },
            {
                "key": "UDOArrayInsertItem",
                "icon": 3,
                "documentation": "The UDOArrayInsertItem() function inserts a UDO array element at the position you specify by index.",
                "detail": "UDOArrayInsertItem($udoHandle, $index, $value)",
                "snippet": "UDOArrayInsertItem(${1:udoHandle}, ${2:index}, ${3:value})"
            },
            {
                "key": "UDOArraySetItem",
                "icon": 3,
                "documentation": "The UDOArraySetItem() function sets or inserts a UDO array element at the position you specify.",
                "detail": "UDOArraySetItem($udoHandle, $index, $value)",
                "snippet": "UDOArraySetItem(${1:udoHandle}, ${2:index}, ${3:value})"
            },
            {
                "key": "UDOClone",
                "icon": 3,
                "documentation": "The UDOClone function clones a UDO object or array so that changes to the new object or array will not affect the original object.",
                "detail": "UDOClone($udoHandle, $newUdoHandle)",
                "snippet": "UDOClone(${1:udoHandle}, ${2:newUdoHandle})"
            },
            {
                "key": "UDOCreate",
                "icon": 3,
                "documentation": "The UDOCreate function creates a UDO item of the type you specify.",
                "detail": "UDOCreate($udoType, $udoHandle)",
                "snippet": "UDOCreate(${1:udoType}, ${2:udoHandle})"
            },
            {
                "key": "UDODeleteProperty",
                "icon": 3,
                "documentation": "The UDODeleteProperty function deletes a property from the UDO object.",
                "detail": "UDODeleteProperty($udoHandle, $name)",
                "snippet": "UDODeleteProperty(${1:udoHandle}, ${2:name})"
            },
            {
                "key": "UDOFree",
                "icon": 3,
                "documentation": "The UDOFree function forcefully removes a UDO object or array from memory.",
                "detail": "UDOFree($udoHandle)",
                "snippet": "UDOFree(${1:udoHandle})"
            },
            {
                "key": "UDOGetLastError",
                "icon": 3,
                "documentation": "If the previous UDO call returned UDO_ERROR, use the UDOGetLastError() function to return the error code and error message.",
                "detail": "UDOGetLastError($errorCode, $errorMessage)",
                "snippet": "UDOGetLastError(${1:errorCode}, ${2:errorMessage})"
            },
            {
                "key": "UDOGetNextProperty",
                "icon": 3,
                "documentation": "The UDOGetNextProperty function provides a convenient way to walk through all the properties in a UDO object, without needing to know the property names in advance.",
                "detail": "UDOGetNextProperty($udoHandle, $name, $value, $value_type)",
                "snippet": "UDOGetNextProperty(${1:udoHandle}, ${2:name}, ${3:value}, ${4:value_type})"
            },
            {
                "key": "UDOGetOption",
                "icon": 3,
                "documentation": "The UDOGetOption function gets the value of a UDO option.",
                "detail": "UDOGetOption($option, $value)",
                "snippet": "UDOGetOption(${1:option}, ${2:value})"
            },
            {
                "key": "UDOGetProperty",
                "icon": 3,
                "documentation": "The UDOGetProperty function returns the value and type of property on the UDO object.",
                "detail": "UDOGetProperty($udoHandle, $name, $value, $value_type)",
                "snippet": "UDOGetProperty(${1:udoHandle}, ${2:name}, ${3:value}, ${4:value_type})"
            },
            {
                "key": "UDOGetPropertyNames",
                "icon": 3,
                "documentation": "The UDOGetPropertyNames function returns a UDO array that holds the names of all the properties in the UDO object.",
                "detail": "UDOGetPropertyNames($udoHandle, $udoArray)",
                "snippet": "UDOGetPropertyNames(${1:udoHandle}, ${2:udoArray})"
            },
            {
                "key": "UDOGetType",
                "icon": 3,
                "documentation": "The UDOGetType() function gets the UDO value type of a UniBasic variable.",
                "detail": "UDOGetType($udoHandle, $type)",
                "snippet": "UDOGetType(${1:udoHandle}, ${2:type})"
            },
            {
                "key": "UDOIsTypeOf",
                "icon": 3,
                "documentation": "The UDOIsTypeOf() function tests the UDO value type of a UniBasic variable.",
                "detail": "UDOIsTypeOf($udoHandle, $type)",
                "snippet": "UDOIsTypeOf(${1:udoHandle}, ${2:type})"
            },
            {
                "key": "UDORead",
                "icon": 3,
                "documentation": "The UDORead function creates a UDO object from a JSON string.",
                "detail": "UDORead($inputString, $inputType, $udoHandle)",
                "snippet": "UDORead(${1:inputString}, ${2:inputType}, ${3:udoHandle})"
            },
            {
                "key": "UDOSetOption",
                "icon": 0,
                "documentation": "Sets the options for the UDO API.",
                "detail": "UDOSetOption($option, $value)",
                "snippet": "UDOSetOption(${1:option}, ${2:value})"
            },
            {
                "key": "UDOSetProperty",
                "icon": 3,
                "documentation": "The UDOSetProperty function creates or updates a property on a UDO object.",
                "detail": "UDOSetProperty($udoHandle, $name, $value, $type)",
                "snippet": "UDOSetProperty(${1:udoHandle}, ${2:name}, ${3:value}, ${4:type})"
            },
            {
                "key": "UDOWrite",
                "icon": 0,
                "documentation": "Writes a UDO object in JSON format.",
                "detail": "UDOWrite($udoHandle, $outputType, $outputString)",
                "snippet": "UDOWrite(${1:udoHandle}, ${2:outputType}, ${3:outputString})"
            },
            {
                "key": "UDTEXECUTE",
                "icon": 14,
                "documentation": "The UniBasic UDTEXECUTE command executes a command in ECLTYPE U, regardless of the BASICTYPE used when the program was compiled.",
                "detail": "UDTEXECUTE $expr",
                "snippet": "UDTEXECUTE ${1:expr}"
            },
            {
                "key": "UNASSIGNED",
                "icon": 3,
                "documentation": "The UniBasic UNASSIGNED function checks a variable in a program to see if it is currently assigned a value. If the variable is not assigned a value, the function returns 1. Otherwise, it returns 0.",
                "detail": "UNASSIGNED($variable)",
                "snippet": "UNASSIGNED(${1:variable})"
            },
            {
                "key": "UNLOCK",
                "icon": 14,
                "documentation": "The UniBasic UNLOCK command unlocks predefined computer resources reserved by the LOCK command. Resource numbers range from 0 through 63. If you do not specify a resource number, the system releases all locks you have set. If there are no locked resources at the time of execution, the statement does not have any effect.",
                "detail": "UNLOCK $num",
                "snippet": "UNLOCK ${1:num}"
            },
            {
                "key": "UPCASE",
                "icon": 3,
                "documentation": "The UniBasic UPCASE function converts lowercase characters to uppercase. Nonalphabetic values are not changed. Special characters, including the null value, are not converted by this function unless you use the U_UPCASE_DELIM UDT.OPTION 122. UPCASE does not support multibyte languages.",
                "detail": "UPCASE($str)",
                "snippet": "UPCASE(${1:str})"
            },
            {
                "key": "WAKE",
                "icon": 14,
                "documentation": "The UniBasic WAKE command activates a UniData process (pid) that has been paused with either the ECL PAUSE command or the UniBasic PAUSE command. If the specified process has not already been paused, UniData disregards the next PAUSE issued for the process indicated by pid.",
                "detail": "WAKE $pid",
                "snippet": "WAKE ${1:pid}"
            },
            {
                "key": "WEOF",
                "icon": 14,
                "documentation": "The UniBasic WEOF command writes an EOF (end-of-file) mark to a magnetic tape.",
                "detail": "WEOF THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "WEOF THEN\n\t${1:then_statements}\nEND ELSE\n\t${2:else_statements}\nEND"
            },
            {
                "key": "WEOFSEQ",
                "icon": 14,
                "documentation": "The UniBasic WEOFSEQ command writes an end-of-file mark at the record pointer position in a sequential file, which results in the file being truncated at the current position. Use WEOFSEQ after a series of WRITESEQ operations.",
                "detail": "WEOFSEQ $filevar ON ERROR $err_statements",
                "snippet": "WEOFSEQ ${1:filevar} ON ERROR ${2:err_statements}"
            },
            {
                "key": "WRITE",
                "icon": 14,
                "documentation": "The UniBasic WRITE command writes an expression to an opened file and releases locks set by the same process.",
                "detail": "WRITE $var TO $filevar,$recordkey",
                "snippet": "WRITE ${1:var} TO ${2:filevar},${3:recordkey}"
            },
            {
                "key": "WRITELIST",
                "icon": 14,
                "documentation": "The UniBasic WRITELIST command writes the contents of a variable to a saved list. The values saved can then be used as item IDs to retrieve the data record. WRITELIST saves only the first value of the attribute. UniData saves only the first value in a multivalued or multi-subvalued attribute.",
                "detail": "WRITELIST $ids TO $listname",
                "snippet": "WRITELIST ${1:ids} TO ${2:listname}"
            },
            {
                "key": "WRITESEQ",
                "icon": 14,
                "documentation": "The UniBasic WRITESEQ command writes an expression as a record on a sequential file at the current record pointer position.",
                "detail": "WRITESEQ $var TO $filevar ON ERROR $err_statements THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "WRITESEQ ${1:var} TO ${2:filevar} ON ERROR ${3:err_statements} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "WRITESEQF",
                "icon": 14,
                "documentation": "The UniBasic WRITESEQF command writes an expression as a record on a sequential file from a current record pointer position and forces UniData to immediately write the data to the disk.",
                "detail": "WRITESEQF $var TO $filevar ON ERROR $err_statements THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "WRITESEQF ${1:var} TO ${2:filevar} ON ERROR ${3:err_statements} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "writeSocket",
                "icon": 3,
                "documentation": "Use the writeSocket() function to write data to a socket connection.",
                "detail": "writeSocket($socket_handle, $socket_data, $time_out, $mode, $actual_write_size)",
                "snippet": "writeSocket(${1:socket_handle}, ${2:socket_data}, ${3:time_out}, ${4:mode}, ${5:actual_write_size})"
            },
            {
                "key": "WRITET",
                "icon": 14,
                "documentation": "The UniBasic WRITET command writes the value of an expression as a record onto tape.",
                "detail": "WRITET $expr THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "WRITET ${1:expr} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "WRITEU",
                "icon": 14,
                "documentation": "The UniBasic WRITEU command writes a record to a file without releasing locks. WRITEU writes regardless of lock status.",
                "detail": "WRITEU $var TO $filevar,$recordkey",
                "snippet": "WRITEU ${1:var} TO ${2:filevar},${3:recordkey}"
            },
            {
                "key": "WRITEV",
                "icon": 14,
                "documentation": "The UniBasic WRITEV command updates a specified attribute or multiple attributes in a file regardless of lock status. The WRITEV command releases locks set by the same process.",
                "detail": "WRITEV $var TO $filevar,$recordkey,$attr",
                "snippet": "WRITEV ${1:var} TO ${2:filevar},${3:recordkey},${4:attr}"
            },
            {
                "key": "WRITEVU",
                "icon": 14,
                "documentation": "The UniBasic WRITEVU command writes an expression to an attribute of a record regardless of lock status. This command retains locks. As with the WRITEV statement, the record ID and attribute number are mandatory.",
                "detail": "WRITEVU $var TO $filevar,$recordkey,$attr",
                "snippet": "WRITEVU ${1:var} TO ${2:filevar},${3:recordkey},${4:attr}"
            },
            {
                "key": "XDOMAddChild",
                "icon": 0,
                "documentation": "Finds the xpathString in the context xmlHandle in the DOM structure, and inserts a node as the last child of the found node. If the inserted node type is XDOM.ATTR.NODE, this node is inserted as an attribute.",
                "detail": "XDOMAddChild($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag, $nodeType)",
                "snippet": "XDOMAddChild(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:nodeHandle}, ${5:dupFlag}, ${6:nodeType})"
            },
            {
                "key": "XDOMAppend",
                "icon": 0,
                "documentation": "Finds the xpathString in the context xmlHandle in the DOM structure, and inserts nodeHandle into the DOM structure as next sibling of the found node. If the inserted node type is XDOM.ATTR.NODE, this node is inserted as an attribute",
                "detail": "XDOMAppend($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag)",
                "snippet": "XDOMAppend(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:nodeHandle}, ${5:dupFlag})"
            },
            {
                "key": "XDOMClone",
                "icon": 0,
                "documentation": "Duplicates the DOM subtree specified by xmlHandle to a new subtree specified by newXmlHandle. The duplicate node has no parent (parentNode returns null.). Cloning an element copies all attributes and their values, including those generated by the XML processor, to represent defaulted attributes, but this method does not copy any text it contains unless it is a deep clone, since the text is contained in a child Text node. Cloning any other type of node simply returns a copy of this node.",
                "detail": "XDOMClone($xmlHandle, $newXmlHandle, $depth)",
                "snippet": "XDOMClone(${1:xmlHandle}, ${2:newXmlHandle}, ${3:depth})"
            },
            {
                "key": "XDOMClose",
                "icon": 0,
                "documentation": "XDOMClose frees the DOM structure.",
                "detail": "XDOMClose($domHandle)",
                "snippet": "XDOMClose(${1:domHandle})"
            },
            {
                "key": "XDOMCreateNode",
                "icon": 0,
                "documentation": "XDOMCreateNode creates a new node in the DOM structure.",
                "detail": "XDOMCreateNode($xmlHandle, $nodeName, $nodeValue, $nodeType, $nodeHandle)",
                "snippet": "XDOMCreateNode(${1:xmlHandle}, ${2:nodeName}, ${3:nodeValue}, ${4:nodeType}, ${5:nodeHandle})"
            },
            {
                "key": "XDOMCreateRoot",
                "icon": 3,
                "documentation": "XDOMCreateRoot creates a new DOM structure with root only. You can use the result handle in other functions where a DOM handle or node handle is needed.",
                "detail": "XDOMCreateRoot($domHandle, $xmlOptions)",
                "snippet": "XDOMCreateRoot(${1:domHandle}, ${2:xmlOptions})"
            },
            {
                "key": "XDOMEvaluate",
                "icon": 0,
                "documentation": "XDOMEvaluate returns the value of the XPathString in the context xmlHandle in the DOM structure.",
                "detail": "XDOMEvaluate($xmlHandle, $xpathString, $nsMap, $aValue)",
                "snippet": "XDOMEvaluate(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:aValue})"
            },
            {
                "key": "XDOMGetAttribute",
                "icon": 0,
                "documentation": "XDOMGetAttribute gets the node's attribute node, whose attribute name is attrName.",
                "detail": "XDOMGetAttribute($nodeHandle, $attrName, $nodeHandle)",
                "snippet": "XDOMGetAttribute(${1:nodeHandle}, ${2:attrName}, ${3:nodeHandle})"
            },
            {
                "key": "XDOMGetChildNodes",
                "icon": 3,
                "documentation": "The XDOMGetChildNodes function returns all child nodes of xmlHandle.",
                "detail": "XDOMChildNodes($xmlHandle, $nodeListHandle)",
                "snippet": "XDOMChildNodes(${1:xmlHandle}, ${2:nodeListHandle})"
            },
            {
                "key": "XDOMGetElementById",
                "icon": 3,
                "documentation": "The XDOMGetElementByld function finds the first element with the ID you specify.",
                "detail": "XDOMGetElementById($xmlHandle, $idstr, $nodeHandle)",
                "snippet": "XDOMGetElementById(${1:xmlHandle}, ${2:idstr}, ${3:nodeHandle})"
            },
            {
                "key": "XDOMGetElementsByName",
                "icon": 3,
                "documentation": "The XDOMGetElementsByName function tries to find all elements with the name you specify.",
                "detail": "XDOMGetElementsByName($xmlHandle, $namestrnodeListHandle)",
                "snippet": "XDOMGetElementsByName(${1:xmlHandle}, ${2:namestrnodeListHandle})"
            },
            {
                "key": "XDOMGetElementsByTag",
                "icon": 3,
                "documentation": "The XDOMGetElementsByTag function tries to find all elements with the tag name you specify.",
                "detail": "XDOMGetElementsByTag($xmlHandle, $tagname, $nodeListHandle)",
                "snippet": "XDOMGetElementsByTag(${1:xmlHandle}, ${2:tagname}, ${3:nodeListHandle})"
            },
            {
                "key": "XDOMGetNodeName",
                "icon": 0,
                "documentation": "XDOMGetNodeName gets the node name.",
                "detail": "XDOMGetNodeName($nodeHandle, $nodeName)",
                "snippet": "XDOMGetNodeName(${1:nodeHandle}, ${2:nodeName})"
            },
            {
                "key": "XDOMGetNodeType",
                "icon": 0,
                "documentation": "XDOMGetNodeType gets the node type.",
                "detail": "XDOMGetNodeType($nodeHandle, $nodeType)",
                "snippet": "XDOMGetNodeType(${1:nodeHandle}, ${2:nodeType})"
            },
            {
                "key": "XDOMGetNodeValue",
                "icon": 0,
                "documentation": "XDOMGetNodeValue gets the node value.",
                "detail": "XDOMGetNodeValue($nodeHandle, $nodeValue)",
                "snippet": "XDOMGetNodeValue(${1:nodeHandle}, ${2:nodeValue})"
            },
            {
                "key": "XDOMGetOwnerDocument",
                "icon": 0,
                "documentation": "XDOMGetOwnerDocument gets the DOM handle to which the nodeHandle belongs.",
                "detail": "XDOMGetOwnerDocument($nodeHandle, $domHandle)",
                "snippet": "XDOMGetOwnerDocument(${1:nodeHandle}, ${2:domHandle})"
            },
            {
                "key": "XDOMGetUserData",
                "icon": 0,
                "documentation": "XDOMGetUserData gets the user data associated with the node.",
                "detail": "XDOMGetUserData($nodeHandle, $userData)",
                "snippet": "XDOMGetUserData(${1:nodeHandle}, ${2:userData})"
            },
            {
                "key": "XDOMImportNode",
                "icon": 3,
                "documentation": "The XDOMImportNode function imports a node from another document into the current document. The returned node has no parent. The source node is not altered or removed from the original document.",
                "detail": "XDOMImportNode($xmlHandle, $depth, $importedNodeHandle, $outNodeHandle)",
                "snippet": "XDOMImportNode(${1:xmlHandle}, ${2:depth}, ${3:importedNodeHandle}, ${4:outNodeHandle})"
            },
            {
                "key": "XDOMInsert",
                "icon": 0,
                "documentation": "XDOMInsert finds the xpathString in the context xmlHandle in the DOM structure, and inserts nodeHandle into the DOM structure as the previous sibling of the found node. If the inserted node type is XDOM.ATTR.NODE, this node is inserted as an attribute.",
                "detail": "XDOMInsert($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag)",
                "snippet": "XDOMInsert(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:nodeHandle}, ${5:dupFlag})"
            },
            {
                "key": "XDOMItem",
                "icon": 3,
                "documentation": "The XDOMItem function returns the index-th item in the list.",
                "detail": "XDOMItem($nodeListHandle, $index, $dataHandle, $dataType)",
                "snippet": "XDOMItem(${1:nodeListHandle}, ${2:index}, ${3:dataHandle}, ${4:dataType})"
            },
            {
                "key": "XDOMLength",
                "icon": 3,
                "documentation": "The XDOMLength function determines the number of nodes in the list. The range of the valid child node index is to 1 to length, inclusive.",
                "detail": "XDOMLength($nodeListHandle, $length)",
                "snippet": "XDOMLength(${1:nodeListHandle}, ${2:length})"
            },
            {
                "key": "XDOMLocate",
                "icon": 3,
                "documentation": "XDOMLocate finds a starting point for relative XPath searching in context xmlHandle in the DOM structure. The xpathString should specify only one node; otherwise, this function will return an error.",
                "detail": "XDOMLocate($xmlHandle, $xpathString, $nsMap, $nodeHandle)",
                "snippet": "XDOMLocate(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:nodeHandle})"
            },
            {
                "key": "XDOMLocateNode",
                "icon": 0,
                "documentation": "XDOMLocateNode traverses from nodeHandle and gets the next node according to direction and childIndex.",
                "detail": "XDOMLocateNode($nodeHandle, $direction, $childIndex, $nodeType, $newNodeHandle)",
                "snippet": "XDOMLocateNode(${1:nodeHandle}, ${2:direction}, ${3:childIndex}, ${4:nodeType}, ${5:newNodeHandle})"
            },
            {
                "key": "XDOMOpen",
                "icon": 0,
                "documentation": "XDOMOpen reads an XML document and creates a DOM structure. If the DTD is included in the document, UniData validates the document. The XML document can be from a string, or from a file, depending on the docLocation flag.",
                "detail": "XDOMOpen($xmlDocument, $docLocation, $domHandle)",
                "snippet": "XDOMOpen(${1:xmlDocument}, ${2:docLocation}, ${3:domHandle})"
            },
            {
                "key": "XDOMRemove",
                "icon": 0,
                "documentation": "XDOMRemove finds the xpathString in the context xmlHandle in the DOM structure, then removes the found node or its attribute with name attrName.",
                "detail": "XDOMRemove($xmlHandle, $xpathString, $nsMap, $attrName, $nodeHandle)",
                "snippet": "XDOMRemove(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:attrName}, ${5:nodeHandle})"
            },
            {
                "key": "XDOMReplace",
                "icon": 0,
                "documentation": "XDOMReplace finds the xpathString in the context xmlHandle in the DOM structure, and replaces the found node with nodeHandle.",
                "detail": "XDOMReplace($xmlHandle, $xpathString, $nsMap, $nodeHandle, $dupFlag)",
                "snippet": "XDOMReplace(${1:xmlHandle}, ${2:xpathString}, ${3:nsMap}, ${4:nodeHandle}, ${5:dupFlag})"
            },
            {
                "key": "XDOMSetNodeValue",
                "icon": 0,
                "documentation": "XDOMSetNodeValue sets the node value.",
                "detail": "XDOMSetNodeValue($nodeHandle, $nodeValue)",
                "snippet": "XDOMSetNodeValue(${1:nodeHandle}, ${2:nodeValue})"
            },
            {
                "key": "XDOMSetUserData",
                "icon": 0,
                "documentation": "XDOMSetUserData sets the user data associated with the node.",
                "detail": "XDOMSetUserData($nodeHandle, $userData)",
                "snippet": "XDOMSetUserData(${1:nodeHandle}, ${2:userData})"
            },
            {
                "key": "XDOMTransform",
                "icon": 0,
                "documentation": "XDOMTransform transforms the input DOM structure using the style sheet specified by styleSheetFile to output the DOM structure, file, or string.",
                "detail": "XDOMTransform($domHandle, $styleSheet, $ssLocation, $outHandle, $outFormat)",
                "snippet": "XDOMTransform(${1:domHandle}, ${2:styleSheet}, ${3:ssLocation}, ${4:outHandle}, ${5:outFormat})"
            },
            {
                "key": "XDOMValidate",
                "icon": 0,
                "documentation": "XDOMValidate validates the DOM document using an external nonamespace schema specified by noNsSchema and, optionally, external namespace schemas specified by NsSchemas.",
                "detail": "XDOMValidate($xmlDocument, $docLocation, $noNsSchema, $noNsSchemaLocation, $NsSchemas)",
                "snippet": "XDOMValidate(${1:xmlDocument}, ${2:docLocation}, ${3:noNsSchema}, ${4:noNsSchemaLocation}, ${5:NsSchemas})"
            },
            {
                "key": "XDOMValidateDom",
                "icon": 0,
                "documentation": "XDOMValidateDom validates the DOM document using an external no-namespace schema specified by noNsSchema and, optionally, external namespace schemas specified by NsSchemas.",
                "detail": "XDOMValidateDom($domHandle, $noNsSchema, $noNsSchemaLocation, $NsSchemas)",
                "snippet": "XDOMValidateDom(${1:domHandle}, ${2:noNsSchema}, ${3:noNsSchemaLocation}, ${4:NsSchemas})"
            },
            {
                "key": "XDOMWrite",
                "icon": 0,
                "documentation": "XDOMWrite writes the DOM structure to xmlDocument. xmlDocument can be a string or a file, depending on the value of the docLocation flag.",
                "detail": "XDOMWrite($domHandle, $xmlDocument, $docLocation, $xmlOptions)",
                "snippet": "XDOMWrite(${1:domHandle}, ${2:xmlDocument}, ${3:docLocation}, ${4:xmlOptions})"
            },
            {
                "key": "XLATE",
                "icon": 3,
                "documentation": "The UniBasic XLATE function returns the contents of an attribute, and takes additional action if the record does not exist or the attribute is empty. This function performs the same action as the TRANS virtual attribute function.",
                "detail": "XLATE($filename, $recordkey, $field, $actioncode)",
                "snippet": "XLATE(${1:filename}, ${2:recordkey}, ${3:field}, ${4:actioncode})"
            },
            {
                "key": "XMAPAppendRec",
                "icon": 3,
                "documentation": "The XMAPAppendRec function formats the specified record from the UniData file as a U2XMAP dataset record and appends it to the U2XMAP dataset.",
                "detail": "XMAPAppendRec($XMAPhandle, $file_name, $record)",
                "snippet": "XMAPAppendRec(${1:XMAPhandle}, ${2:file_name}, ${3:record})"
            },
            {
                "key": "XMAPClose",
                "icon": 3,
                "documentation": "The XMAPClose function closes the U2XMAP dataset handle and frees all related structures and memory.",
                "detail": "XMAPClose($XMAPhandle)",
                "snippet": "XMAPClose(${1:XMAPhandle})"
            },
            {
                "key": "XMAPCreate",
                "icon": 3,
                "documentation": "The XMAPCreate function creates an empty XML document for transferring data from the UniData database to XML according the mapping rules you define.",
                "detail": "XMAPCreate($u2xmapping_rules, $mapping_flag, $XMAPhandle)",
                "snippet": "XMAPCreate(${1:u2xmapping_rules}, ${2:mapping_flag}, ${3:XMAPhandle})"
            },
            {
                "key": "XMAPOpen",
                "icon": 3,
                "documentation": "The XMAPOpen function opens an XML document as a U2XMAP data set.",
                "detail": "XMAPOpen($xml_document, $doc_flag, $u2xmapping_rules, $u2xmap_flag, $XMAPhandle)",
                "snippet": "XMAPOpen(${1:xml_document}, ${2:doc_flag}, ${3:u2xmapping_rules}, ${4:u2xmap_flag}, ${5:XMAPhandle})"
            },
            {
                "key": "XMAPReadNext",
                "icon": 3,
                "documentation": "The XMAPReadNext function retrieves the next record from the U2XMAP dataset and formats it as a record of the UniData file that is being mapped.",
                "detail": "XMAPReadNext($XMAPhandle, $file_name, $record)",
                "snippet": "XMAPReadNext(${1:XMAPhandle}, ${2:file_name}, ${3:record})"
            },
            {
                "key": "XMAPToXMLDoc",
                "icon": 3,
                "documentation": "The XMAPToXMLDoc function generates an XML document from the data in the U2XMAP dataset using the mapping rules you define. The XML document can be either an XML DOM handle or an XML document. UniData writes the data to a file or a UniBasic variable.",
                "detail": "XMAPToXMLDoc($XMAPhandle, $xmlfile, $doc_flag, $xmlOptions)",
                "snippet": "XMAPToXMLDoc(${1:XMAPhandle}, ${2:xmlfile}, ${3:doc_flag}, ${4:xmlOptions})"
            },
            {
                "key": "XMLError",
                "icon": 3,
                "documentation": "Use the XMLError function to get the last error message.",
                "detail": "XMLError($errmsg)",
                "snippet": "XMLError(${1:errmsg})"
            },
            {
                "key": "XMLExecute",
                "icon": 3,
                "documentation": "The XMLExecute function enables you to create an XML document using the UniQuery LIST statement or the UniData SQL SELECT statement from a UniBasic program.",
                "detail": "XMLExecute($cmd, $options, $xmlvar, $xsdvar)",
                "snippet": "XMLExecute(${1:cmd}, ${2:options}, ${3:xmlvar}, ${4:xsdvar})"
            },
            {
                "key": "XMLGetError",
                "icon": 0,
                "documentation": "XMLGetError gets the error code and error message after the previous XML API failed.",
                "detail": "XMLGetError($errorCode, $errorMessage)",
                "snippet": "XMLGetError(${1:errorCode}, ${2:errorMessage})"
            },
            {
                "key": "XMLGetOptions",
                "icon": 3,
                "documentation": "Use this function in UniBasic programs to return the values for encoding and other XML options in effect in the current UniData session.",
                "detail": "XMLGetOptions($outOptions, $delimiterString)",
                "snippet": "XMLGetOptions(${1:outOptions}, ${2:delimiterString})"
            },
            {
                "key": "XMLGetOptionValue",
                "icon": 3,
                "documentation": "Use this function in UniBasic programs to return the value of encoding or any other XML option in effect in the current UniData session.",
                "detail": "XMLGetOptionValue($optionName, $outOptionValue)",
                "snippet": "XMLGetOptionValue(${1:optionName}, ${2:outOptionValue})"
            },
            {
                "key": "XMLSetOptions",
                "icon": 14,
                "documentation": "Use this function in UniBasic programs to set the encoding parameter and other XML options in the current UniData session. The settings specified in this API override the settings in the system-level and account-level xmlconfig files and in ECL commands during the current session.",
                "detail": "XMLSetOptions($options)",
                "snippet": "XMLSetOptions(${1:options})"
            },
            {
                "key": "XMLTODB",
                "icon": 3,
                "documentation": "The XMLTODB function populates the UniData database from UniBasic. If you want to transform specific data, use the XMAP API.",
                "detail": "XMLTODB($xml_document, $doc_flag, $u2xmapping_rules, $u2xmap_ flag, status)",
                "snippet": "XMLTODB(${1:xml_document}, ${2:doc_flag}, ${3:u2xmapping_rules}, ${4:u2xmap_} flag, status)"
            }
        ]
    }
}
