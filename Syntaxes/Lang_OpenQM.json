{
    "Language": {
        "Type": "QM Basic",
        "Keywords": [
            {
                "key": "$Include",
                "icon": 14,
                "documentation": "The $INCLUDE directive is used to direct the compiler to include text from another record. Include records may be in either directory or hashed files.",
                "detail": "INCLUDE programname\n$INCLUDE filename programname\nINCLUDE programname\n$INCLUDE filename programname\n$INSERT programname\n$INSERT filename programname",
                "snippet": "$INCLUDE ${1:programname}"
            },
            {
                "key": "@Am",
                "icon": 21,
                "documentation": "Attribute mark (synonym for @FM)",
                "detail": "@AM"
            },
            {
                "key": "@Abort.code",
                "icon": 21,
                "documentation": "A value indicating the cause of execution of the last abort. This variable is particularly useful within ON.ABORT paragraphs or programs invoked from them. Values are: 0  No abort has occurred 1  A QMBasic ABORT statement or the ABORT command has been used 2  The Abort option has been selected after the break key was pressed 3  An internal error has been detected  The value of @ABORT.CODE is initially zero and is reset to zero only by the EXECUTE statement",
                "detail": "@ABORT.CODE"
            },
            {
                "key": "@Abort.message",
                "icon": 21,
                "documentation": "Contains the text of any message associated with the most recent abort event.",
                "detail": "@ABORT.MESSAGE"
            },
            {
                "key": "@Acall.fno",
                "icon": 21,
                "documentation": "The field number associated with a CALL correlative in an A or S-type dictionary item.",
                "detail": "@ACALL.FNO"
            },
            {
                "key": "@Account",
                "icon": 21,
                "documentation": "Returns the name of the current jBASE user account",
                "detail": "@ACCOUNT"
            },
            {
                "key": "@Ans",
                "icon": 21,
                "documentation": "Contains the result of the last virtual attribute expression evaluated. This variable can be updated, usually only in C-type dictionary items.",
                "detail": "@ANS"
            },
            {
                "key": "@Bpv",
                "icon": 21,
                "documentation": "Previous value of breakpoint item when using X breakpoint control option.",
                "detail": "@BPV"
            },
            {
                "key": "@Build.Time",
                "icon": 21,
                "documentation": "Date\/time at which the program was compiled as an epoch value.",
                "detail": "@BUILD.TIME"
            },
            {
                "key": "@Command",
                "icon": 21,
                "documentation": "he last command entered at the command prompt or initiated using the QMBasic EXECUTE statement. This variable is stacked across an EXECUTE and reverts to its previous value on completion of the executed command. If multiple commands are executed in a single  EXECUTE statement, the @COMMAND variable will be updated at each command.",
                "detail": "@COMMAND"
            },
            {
                "key": "@Command.stack",
                "icon": 21,
                "documentation": "This variable holds the history of commands executed at the command prompt as a field mark delimited dynamic array. The most recent command is field 1.",
                "detail": "@COMMAND.STACK"
            },
            {
                "key": "@Conv",
                "icon": 21,
                "documentation": "Extended information for user defined conversion codes.",
                "detail": "@CONV"
            },
            {
                "key": "@Crthigh",
                "icon": 21,
                "documentation": "Contains the number of lines per page of the display.",
                "detail": "@CRTHIGH"
            },
            {
                "key": "@Crtwide",
                "icon": 21,
                "documentation": "Contains the column width of the display.",
                "detail": "@CRTWIDE"
            },
            {
                "key": "@Data",
                "icon": 21,
                "documentation": "Data from REFORMAT command.",
                "detail": "@DATA"
            },
            {
                "key": "@Data.pending",
                "icon": 21,
                "documentation": "Contains the data on the DATA queue, if any. Each item, including the last, is followed by an item mark character.",
                "detail": "@DATA.PENDING"
            },
            {
                "key": "@Date",
                "icon": 21,
                "documentation": "The internal format date value (days since 31 December 1967) at which the last command started execution. Any changes made to this variable will also be reflected in the values of the @DAY, @MONTH, @YEAR and @YEAR4 variables.",
                "detail": "@DATE"
            },
            {
                "key": "@Day",
                "icon": 21,
                "documentation": "The day of the month at which the last command started execution as a two digit value. Changing @DATE will also change this value.",
                "detail": "@DAY"
            },
            {
                "key": "@Dictrecs",
                "icon": 21,
                "documentation": "The query processor sets this variable to an item mark delimited copy of the dictionary records that were used to construct the display clause elements of the query (including any item with the BREAK.SUP prefix). For dictionary records that contain object code (C\/I types and A\/S types with correlatives), the object code is omitted. Field 1, value 2 of each element contains the item name. This variable can be of use in post-processing query processor output.",
                "detail": "@DICTRECS"
            },
            {
                "key": "@Drive",
                "icon": 21,
                "documentation": "The drive letter of the QMSYS directory (Windows only, null on other platforms).",
                "detail": "@DRIVE"
            },
            {
                "key": "@Ds",
                "icon": 21,
                "documentation": "Contains the operating system specific directory delimiter character, \\ on Windows, \/ on other platforms.",
                "detail": "@DS"
            },
            {
                "key": "@Exception",
                "icon": 21,
                "documentation": "Contains the name of the last exception thrown by the QMBasic THROW statement. This variable can be modified by applications.",
                "detail": "@EXCEPTION"
            },
            {
                "key": "@Exception.Data",
                "icon": 21,
                "documentation": "Contains any qualifying data associated with the last exception thrown by the QMBasic THROW statement. This variable can be modified by applications.",
                "detail": "@EXCEPTION.DATA"
            },
            {
                "key": "@Exception.Origin",
                "icon": 21,
                "documentation": "Contains the program name and line number at which the last exception was thrown separated by a field mark. If the program has no cross-reference tables, the line number will be -1. This variable can be modified by applications.",
                "detail": "@EXCEPTION.ORIGIN"
            },
            {
                "key": "@Exception.Stack",
                "icon": 21,
                "documentation": "Dynamic array containing a full stack dump in the form created by SYSTEM(1002) at the point of throwing an exception for which the SAVE.STACK option of the CATCH clause was used. This variable can be modified by applications.",
                "detail": "@EXCEPTION.STACK"
            },
            {
                "key": "@False",
                "icon": 21,
                "documentation": "Boolean value. Used as a number, this evaluates to zero.",
                "detail": "@FALSE"
            },
            {
                "key": "@File.Name",
                "icon": 21,
                "documentation": "The name of the file referenced in the most recent query processor command. This variable may be updated by a QMBasic program.",
                "detail": "@FILE.NAME"
            },
            {
                "key": "@Filename",
                "icon": 21,
                "documentation": "Synonym for @FILE.NAME",
                "detail": "@FILENAME"
            },
            {
                "key": "@Fm",
                "icon": 21,
                "documentation": "Field mark",
                "detail": "@FM"
            },
            {
                "key": "@Fmt",
                "icon": 21,
                "documentation": "The query processor sets this variable to a field mark delimited list of the width and justification codes for each item in the display clause of the query (including any item with the BREAK.SUP prefix). This variable can be of use in post-processing query processor output.",
                "detail": "@FMT"
            },
            {
                "key": "@Gid",
                "icon": 21,
                "documentation": "User's group id number for all platforms except Windows. Same as SYSTEM(29).",
                "detail": "@GID"
            },
            {
                "key": "@Hostname",
                "icon": 21,
                "documentation": "The name of the server computer system. Same as SYSTEM(1015).",
                "detail": "@HOSTNAME"
            },
            {
                "key": "@Id",
                "icon": 21,
                "documentation": "The record id of the record being processed by a query processor command or an I-type function. This variable may be updated by a QMBasic program.",
                "detail": "@ID"
            },
            {
                "key": "@Im",
                "icon": 21,
                "documentation": "Item mark.",
                "detail": "@Im"
            },
            {
                "key": "@Ip.Addr",
                "icon": 21,
                "documentation": "The IP address associated with a network user. Same as SYSTEM(42).",
                "detail": "@IP.ADDR"
            },
            {
                "key": "@Itype.Mode",
                "icon": 21,
                "documentation": "This variable can be used to determine the mode of execution of an I-type. It has three possible values: 0 Normal  1 Evaluation of the old index value when updating or deleting a record from a file with an alternate key index. 2 Evaluation of the new index value when updating or adding a record to a file with an alternate key index.",
                "detail": "@ITYPE.MODE"
            },
            {
                "key": "@Level",
                "icon": 21,
                "documentation": "The current command processor depth (EXECUTE level). The initial command processor is level one, each EXECUTE level increments this by one, decrementing on return from that level.",
                "detail": "@LEVEL"
            },
            {
                "key": "@Line",
                "icon": 21,
                "documentation": "The current source line number in the module being compiled, possibly useful in error messages. See also @WHERE.",
                "detail": "@LINE"
            },
            {
                "key": "@Logname",
                "icon": 21,
                "documentation": "User's login name. On Windows, this is converted to uppercase.",
                "detail": "@LOGNAME"
            },
            {
                "key": "@Lptrhigh",
                "icon": 21,
                "documentation": "Contains the number of lines per page of print unit zero. Depending on the current setting of the PRINTER flag, this may refer to the display or to the printer.",
                "detail": "@LPTRHIGH"
            },
            {
                "key": "@Lptrwide",
                "icon": 21,
                "documentation": "Contains the width of print unit zero. Depending on the current setting of the PRINTER flag, this may refer to the display or to the printer.",
                "detail": "@LPTRWIDE"
            },
            {
                "key": "@Mbutton",
                "icon": 21,
                "documentation": "The button number related to the most recent mouse click trapped by KEYCODE() or KEYCODEV().",
                "detail": "@MBUTTON"
            },
            {
                "key": "@Mcol",
                "icon": 21,
                "documentation": "The screen column number related to the most recent mouse click trapped by KEYCODE() or KEYCODEV().",
                "detail": "@MCOL"
            },
            {
                "key": "@Month",
                "icon": 21,
                "documentation": "The month in which the last command started execution as a two digit value. Changing @DATE will also change this value.",
                "detail": "@MONTH"
            },
            {
                "key": "@Mrow",
                "icon": 21,
                "documentation": "The screen row number related to the most recent mouse click trapped by KEYCODE() or KEYCODEV().",
                "detail": "@MROw"
            },
            {
                "key": "@Nb",
                "icon": 21,
                "documentation": "Break number level. Set to zero on detail lines and one upwards on break lines. A value of 255 represents the grand total line.",
                "detail": "@NB"
            },
            {
                "key": "@Ni",
                "icon": 21,
                "documentation": "Item counter. Used in I-types, this holds the number of records retrieved by the query processor command. This variable can be updated, primarily for interaction with I-type dictionary items.",
                "detail": "@NB"
            },
            {
                "key": "@Null",
                "icon": 21,
                "documentation": "SQL style null data constant for compatibility with data collections that may be converted to JSON string format.",
                "detail": "@NULL"
            },
            {
                "key": "@Option",
                "icon": 21,
                "documentation": "Contains a copy of field 4 of the V-type VOC entry when a verb starts execution. Use of this variable enables related commands to be handled by a single program.",
                "detail": "@OPTION"
            },
            {
                "key": "@Parasentence",
                "icon": 21,
                "documentation": "The sentence that invoked the most recent paragraph or sentence. On entering a command at the keyboard, this variable will be set to the same value as @COMMAND. If the command is a paragraph or sentence which invokes a further paragraph or sentence, the value will be updated to be the command which started this new paragraph or sentence.",
                "detail": "@PARASENTENCE"
            },
            {
                "key": "@Path",
                "icon": 21,
                "documentation": "The pathname of the current account.",
                "detail": "@PATH"
            },
            {
                "key": "@Pib",
                "icon": 21,
                "documentation": "The PROC primary input buffer. This variable can be modified by applications.",
                "detail": "@PID"
            },
            {
                "key": "@Pob",
                "icon": 21,
                "documentation": "The PROC primary output buffer. This variable can be modified by applications.",
                "detail": "@POB"
            },
            {
                "key": "@Pstat",
                "icon": 21,
                "documentation": "May be set by an application to contain diagnostic text that will be included in the output of the PSTAT command.",
                "detail": "@PSTAT"
            },
            {
                "key": "@Qm.Group",
                "icon": 21,
                "documentation": "The QM user group to which the user running this session belongs, a null string if none.",
                "detail": "@QM.GROUP"
            },
            {
                "key": "@Qmsys",
                "icon": 21,
                "documentation": "The pathname of the system account.",
                "detail": "@QMSYS"
            },
            {
                "key": "@Record",
                "icon": 21,
                "documentation": "The data of the record being processed by an I-type function. This variable may be updated by a QMBasic program",
                "detail": "@RECORD"
            },
            {
                "key": "@Selected",
                "icon": 21,
                "documentation": "Contains the total record count for the most recent SELECT or SSELECT operation. Note that a QMBasic SELECT operation against a dynamic file processes the file one group at a time and this variable will show the record count for the group being processed. Note also that processing items from the select list does not decrement this value. To find the current state of a select list, use the SELECTINFO() function.",
                "detail": "@SELECTED"
            },
            {
                "key": "@Sentence",
                "icon": 21,
                "documentation": "The currently active sentence. This is different from @COMMAND if the command runs a paragraph, sentence or menu.",
                "detail": "@SENTENCE"
            },
            {
                "key": "@Seqno",
                "icon": 21,
                "documentation": "Hold file sequence number for most recent print job using uniquely sequenced file numbers.",
                "detail": "@SEQNO"
            },
            {
                "key": "@Sib",
                "icon": 21,
                "documentation": "The PROC secondary input buffer. This variable can be modified by applications.",
                "detail": "@SIB"
            },
            {
                "key": "@Sm",
                "icon": 21,
                "documentation": "Subvalue mark.",
                "detail": "@SM"
            },
            {
                "key": "@Sob",
                "icon": 21,
                "documentation": "The PROC secondary output buffer. This variable can be modified by applications.",
                "detail": "@SOB"
            },
            {
                "key": "@Socket",
                "icon": 21,
                "documentation": "Socket file variable in a phantom process started with socket inheritability enabled. This variable can be modified by applications.",
                "detail": "@SOCKET"
            },
            {
                "key": "@Stdfil",
                "icon": 21,
                "documentation": "Default file variable.",
                "detail": "@STDFIL"
            },
            {
                "key": "@Svm",
                "icon": 21,
                "documentation": "Subvalue mark (synonym for @SM).",
                "detail": "@SVM"
            },
            {
                "key": "@System.Return.Code",
                "icon": 21,
                "documentation": "A status value returned from most commands.",
                "detail": "@SYSTEM.RETURN.CODE"
            },
            {
                "key": "@Sys.Bell",
                "icon": 21,
                "documentation": "This variable is available to QMBasic programs and initially contains the ASCII BEL character (character 7) which, when sent to the display, causes the audible warning to sound. The BELL OFF command changes @SYS.BELL to a null string and BELL ON reverts to the default character. Thus use of @SYS.BELL in QMBasic programs results in an audible alarm which can be disabled by the user.",
                "detail": "@SYS.BELL"
            },
            {
                "key": "@Term.Type",
                "icon": 21,
                "documentation": "Terminal type.",
                "detail": "@TERM.TYPE"
            },
            {
                "key": "@Time",
                "icon": 21,
                "documentation": "The internal format time value (seconds since midnight) at which the last command started execution. This value may be updated by a QMBasic program.",
                "detail": "@TIME"
            },
            {
                "key": "@Tm",
                "icon": 21,
                "documentation": "Inserts a text mark CHAR(251)",
                "detail": "@TM"
            },
            {
                "key": "@Transaction.Id",
                "icon": 21,
                "documentation": "The unique id number for the currently active transaction. Zero if no transaction is active. Same as SYSTEM(1007).",
                "detail": "@TRANSACTION.ID"
            },
            {
                "key": "@Transaction.Level",
                "icon": 21,
                "documentation": "The transaction depth. Zero when no transaction is active, incremented for each active transaction, decremented when a transaction terminates. Same as SYSTEM(1008).",
                "detail": "@TRANSACTION.LEVEL"
            },
            {
                "key": "@Trigger.Return.Code",
                "icon": 21,
                "documentation": "A status value returned set by trigger functions that return a STATUS() value of ER$TRIGGER.",
                "detail": "@TRIGGER.RETURN.CODE"
            },
            {
                "key": "@True",
                "icon": 21,
                "documentation": "Boolean value. Used as a number, this evaluates to one.",
                "detail": "@TRUE"
            },
            {
                "key": "@Tty",
                "icon": 21,
                "documentation": "Terminal device name. This variable is provided for compatibility with other systems. It contains one of the following values: console QMConsole interactive session on Windows \/dev\/... QMConsole interactive session on other platforms telnet Telnet session phantom Phantom process port Serial port connection startup Process started from STARTUP configuration parameter vbsrvr QMClient process Other process types may be added in future.",
                "detail": "@TTY"
            },
            {
                "key": "@Uid",
                "icon": 21,
                "documentation": "User's user id number for all platforms except Windows. Same as SYSTEM(27).",
                "detail": "@UID"
            },
            {
                "key": "@User",
                "icon": 21,
                "documentation": "Synonym for @LOGNAME.",
                "detail": "@USER"
            },
            {
                "key": "@User0",
                "icon": 21,
                "documentation": "These variables are initially set to zero and may be updated by QMBasic programs to provide status information, etc. QM places no rules on the use of these variables and does not update them at any time.",
                "detail": "@USER0"
            },
            {
                "key": "@User1",
                "icon": 21,
                "documentation": "These variables are initially set to zero and may be updated by QMBasic programs to provide status information, etc. QM places no rules on the use of these variables and does not update them at any time.",
                "detail": "@USER1"
            },
            {
                "key": "@User2",
                "icon": 21,
                "documentation": "These variables are initially set to zero and may be updated by QMBasic programs to provide status information, etc. QM places no rules on the use of these variables and does not update them at any time.",
                "detail": "@USER2"
            },
            {
                "key": "@User3",
                "icon": 21,
                "documentation": "These variables are initially set to zero and may be updated by QMBasic programs to provide status information, etc. QM places no rules on the use of these variables and does not update them at any time.",
                "detail": "@USER3"
            },
            {
                "key": "@User4",
                "icon": 21,
                "documentation": "These variables are initially set to zero and may be updated by QMBasic programs to provide status information, etc. QM places no rules on the use of these variables and does not update them at any time.",
                "detail": "@USER4"
            },
            {
                "key": "@Userno",
                "icon": 21,
                "documentation": "User number.",
                "detail": "@USERNO"
            },
            {
                "key": "@User.No",
                "icon": 21,
                "documentation": "Synonym for @USERNO.",
                "detail": "@USER.NO"
            },
            {
                "key": "@User.Return.Code",
                "icon": 21,
                "documentation": "This variable is initially set to zero and may be updated by QMBasic programs to provide status information, etc. QM places no rules on the use of this variable and does not update it at any time.",
                "detail": "@USER.RETURN.CODE"
            },
            {
                "key": "@Vm",
                "icon": 21,
                "documentation": "Value mark.",
                "detail": "@VM"
            },
            {
                "key": "@Voc",
                "icon": 21,
                "documentation": "This @VOC variable can be used as the file variable for the VOC in place of opening it explicitly within user written application code.",
                "detail": "@VOC"
            },
            {
                "key": "@Where",
                "icon": 21,
                "documentation": "The current source line number in the module being compiled together with line numbers in nested include records in the form \"21.4.3\". Possibly useful in error messages. See also @LINE.",
                "detail": "@WHERE"
            },
            {
                "key": "@Who",
                "icon": 21,
                "documentation": "User's account name.",
                "detail": "@WHO"
            },
            {
                "key": "@Year",
                "icon": 21,
                "documentation": "The last two digits of the year in which the last command started execution. Changing @DATE will also change this value.",
                "detail": "@YEAR"
            },
            {
                "key": "@Year4",
                "icon": 21,
                "documentation": "The four digit year number in which the last command started execution. Changing @DATE will also change this value.",
                "detail": "@YEAR4"
            },
            {
                "key": "Abort",
                "icon": 14,
                "documentation": "The ABORT statement terminates the current program, returning to the command prompt. ABORTE and ABORTM provide compatibility with other multivalue database products.",
                "detail": "ABORT {message}",
                "snippet": "ABORT ${1:messagenum}, ${2:expression}"
            },
            {
                "key": "Aborte",
                "icon": 14,
                "documentation": "The ABORT statement terminates the current program, returning to the command prompt. ABORTE and ABORTM provide compatibility with other multivalue database products.",
                "detail": "ABORTE {message}",
                "snippet": "ABORTE ${1:messagenum}, ${2:expression}"
            },
            {
                "key": "Abortm",
                "icon": 14,
                "documentation": "The ABORT statement terminates the current program, returning to the command prompt. ABORTE and ABORTM provide compatibility with other multivalue database products.",
                "detail": "ABORTM {message}",
                "snippet": "ABORTM ${1:messagenum}, ${2:expression}"
            },
            {
                "key": "Abs",
                "icon": 3,
                "documentation": "The ABS() function returns the absolute (positive) value of a numeric expression.",
                "detail": "ABS(expr)",
                "snippet": "ABS(${1:math_expression})"
            },
            {
                "key": "Abss",
                "icon": 3,
                "documentation": "The ABSS() function is similar to ABS() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results. ",
                "detail": "ABSS(dynamic array)",
                "snippet": "ABSS(${1:DynArr})"
            },
            {
                "key": "Accept.Socket.Connection",
                "icon": 3,
                "documentation": "The ACCEPT.SOCKET.CONNECTION() function opens a data socket on a server to handle an incoming stream connection.",
                "detail": "ACCEPT.SOCKET.CONNECTION(srvr.skt, timeout)",
                "snippet": "ACCEPT.SOCKET.CONNECTION(${1:srvr_skt}, ${2:timeout})"
            },
            {
                "key": "Account.Path",
                "icon": 3,
                "documentation": "The ACCOUNT.PATH() function returns the pathname corresponding to the supplied account name.",
                "detail": "ACCOUNT.PATH(account)",
                "snippet": "ACCOUNT.PATH(${1:account})"
            },
            {
                "key": "Acos",
                "icon": 3,
                "documentation": "The ACOS() function returns the arc-cosine (inverse cosine) of a value.",
                "detail": "ACOS(expr)",
                "snippet": "ACOS(${1:expr})"
            },
            {
                "key": "Alpha",
                "icon": 3,
                "documentation": "The ALPHA() function tests whether a string contains only alphabetic characters.",
                "detail": "ALPHA(string)",
                "snippet": "ALPHA(${1:value})"
            },
            {
                "key": "Ands",
                "icon": 3,
                "documentation": "The ANDS() function performs a logical AND operation on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "ANDS(expr1, expr2)",
                "snippet": "ANDS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Arg",
                "icon": 3,
                "documentation": "The ARG() function returns and argument value based on its position in the argument list. It is intended for use with subroutines declared with the VAR.ARGS option.",
                "detail": "ARG(n)",
                "snippet": "ARG(${1:n})"
            },
            {
                "key": "Arg.Count",
                "icon": 3,
                "documentation": "The ARG.COUNT() function returns the number of arguments passed into the current subroutine. It is intended for use with subroutines declared with the VAR.ARGS option.",
                "detail": "ARG.COUNT()",
                "snippet": "ARG.COUNT()"
            },
            {
                "key": "Arg.Present",
                "icon": 3,
                "documentation": "The ARG.PRESENT() function tests whether an argument variable was passed by the caller of a subroutine or function declared with the VAR.ARGS option.",
                "detail": "ARG.PRESENT(var)",
                "snippet": "ARG.PRESENT(${1:var})"
            },
            {
                "key": "Ascii",
                "icon": 3,
                "documentation": "The ASCII() function converts an EBCDIC string to ASCII.",
                "detail": "ASCII(expr)",
                "snippet": "ASCII(${1:expression})"
            },
            {
                "key": "Asin",
                "icon": 3,
                "documentation": "The ASIN() function returns the arc-sine (inverse sine) of a value.",
                "detail": "ASIN(expr)",
                "snippet": "ASIN(${1:expr})"
            },
            {
                "key": "Assigned",
                "icon": 3,
                "documentation": "The ASSIGNED() function tests whether a variable is assigned.",
                "detail": "ASSIGNED(var)",
                "snippet": "ASSIGNED(${1:variable})"
            },
            {
                "key": "Atan",
                "icon": 3,
                "documentation": "The ATAN() function returns the arc-tangent (inverse tangent) of a value.",
                "detail": "ATAN(expr)",
                "snippet": "ATAN(${1:expr})"
            },
            {
                "key": "Begin Case",
                "icon": 14,
                "documentation": "The CASE statement provides conditional execution dependant on the result of expression evaluation.",
                "detail": "BEGIN CASE\n\tCASE expr\n\t\tstatement(s)\n\tCASE expr\n\t\tstatement(s)\nEND CASE",
                "snippet": "BEGIN CASE\n\tCASE $1\n\t\t$2\nEND CASE"
            },
            {
                "key": "Begin Transaction",
                "icon": 14,
                "documentation": "The BEGIN TRANSACTION statement marks the start of a new transaction.",
                "detail": "BEGIN TRANSACTION\n\t{statements}\n\tCOMMIT \/ ROLLBACK\n\t...\nEND TRANSACTION",
                "snippet": "BEGIN TRANSACTION\n\t$1\n\t${2:COMMIT_ROLLBACK}\nEND TRANSACTION"
            },
            {
                "key": "Bindkey",
                "icon": 3,
                "documentation": "The BINDKEY() function sets, removes, queries, saves or restores key bindings.",
                "detail": "BINDKEY(key.string, action)",
                "snippet": "BINDKEY(${1:keystring}, ${2:action})"
            },
            {
                "key": "Bitand",
                "icon": 3,
                "documentation": "The BITAND() function forms the bitwise logical AND of two integer values.",
                "detail": "BITAND(expr1, expr2)",
                "snippet": "BITAND(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Bitnot",
                "icon": 3,
                "documentation": "The BITNOT() function forms the bitwise logical NOT of an integer value.",
                "detail": "BITNOT(expr)",
                "snippet": "BITNOT(${1:expression})"
            },
            {
                "key": "Bitor",
                "icon": 3,
                "documentation": "The BITOR() function forms the bitwise logical OR of two integer values.",
                "detail": "BITOR(expr1, expr2)",
                "snippet": "BITOR(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Bitreset",
                "icon": 3,
                "documentation": "The BITRESET() function turns off a specified bit in an integer value.",
                "detail": "BITRESET(expr, bit)",
                "snippet": "BITRESET(${1:expr}, ${2:bit})"
            },
            {
                "key": "Bitset",
                "icon": 3,
                "documentation": "The BITSET() function turns on a specified bit in an integer value.",
                "detail": "BITSET(expr, bit)",
                "snippet": "BITSET(${1:expr}, ${2:bit})"
            },
            {
                "key": "Bittest",
                "icon": 3,
                "documentation": "The BITTEST() function tests the state of a specified bit in an integer value.",
                "detail": "BITTEST(expr, bit)",
                "snippet": "BITTEST(${1:expression}, ${2:bit})"
            },
            {
                "key": "Bitxor",
                "icon": 3,
                "documentation": "The BITXOR() function forms the bitwise logical exclusive-OR of two integer values.",
                "detail": "BITXOR(expr1, expr2)",
                "snippet": "BITXOR(${1:expression1}, ${2:expression2})"
            },
            {
                "key": "Bool",
                "icon": 14,
                "documentation": "The BOOL() function converts a value to Boolean form.",
                "detail": "BOOL(expr)",
                "snippet": "BOOL(${1:expr})"
            },
            {
                "key": "Break",
                "icon": 14,
                "documentation": "The BREAK statement allows the action of the break key to be changed during program execution.",
                "detail": "BREAK {KEY} OFF\nBREAK {KEY} ON\nBREAK {KEY} CLEAR\nBREAK {KEY} RESET\nBREAK {KEY} expr",
                "snippet": "BREAK $1"
            },
            {
                "key": "Break.Count",
                "icon": 3,
                "documentation": "The BREAK.COUNT() function returns the current value of the break inhibit counter.",
                "detail": "BREAK.COUNT()",
                "snippet": "BREAK.COUNT()"
            },
            {
                "key": "Call",
                "icon": 14,
                "documentation": "The CALL statement calls a catalogued subroutine. The ENTER statement is a synonym for CALL unless the PICK.ENTER option of the $MODE directive is used.",
                "detail": "CALL name {(arg.list)}\nCALL @var {(arg.list)}\nCALL \"file name\" {(arg.list)}",
                "snippet": "CALL ${1:subroutine_name}(${2:arguments})"
            },
            {
                "key": "Catalogued",
                "icon": 14,
                "documentation": "The CATALOGUED() function determines whether a subroutine can be found using the search process described for the CALL statement.",
                "detail": "CATALOGUED(name)",
                "snippet": "CATALOGUED(${1:name})"
            },
            {
                "key": "Cats",
                "icon": 3,
                "documentation": "The CATS() function concatenates corresponding elements of a dynamic array.",
                "detail": "CATS(string1, string2)",
                "snippet": "CATS(${1:str1}, ${2:str2})"
            },
            {
                "key": "Caught",
                "icon": 3,
                "documentation": "The CAUGHT() function allows an application to test whether there is a handler established for a named exception.",
                "detail": "CAUGHT(exception, modes)",
                "snippet": "CAUGHT(${1:exception}, ${2:modes})"
            },
            {
                "key": "Ceil",
                "icon": 3,
                "documentation": "The CEIL() function returns the smallest integer not less than the argument value. ",
                "detail": "CEIL(value)",
                "snippet": "CEIL(${1:value})"
            },
            {
                "key": "Chain",
                "icon": 14,
                "documentation": "The CHAIN statement terminates the current program and executes a command.",
                "detail": "CHAIN expr",
                "snippet": "CHAIN ${1:expression}"
            },
            {
                "key": "Change",
                "icon": 14,
                "documentation": "The CHANGE() function replaces occurrences of a substring within a string by another substring. The synonym SWAP() can be used.",
                "detail": "CHANGE(string, old, new{, occurrence{, start}})",
                "snippet": "CHANGE(${1:string}, ${2:old}, ${3:new}, ${4:occurrence}, ${5:start})"
            },
            {
                "key": "Char",
                "icon": 3,
                "documentation": "The CHAR() function returns the character with a given ASCII value.",
                "detail": "CHAR(seq)",
                "snippet": "CHAR(${1:expression})"
            },
            {
                "key": "CHARS",
                "icon": 3,
                "documentation": "The CHARS() function takes a dynamic array seq and returns a similarly structured dynamic array in which each element contains the character with the ASCII value from the corresponding element of seq.",
                "detail": "CHARS($DynArr)",
                "snippet": "CHARS(${1:DynArr})"
            },
            {
                "key": "Checksum",
                "icon": 3,
                "documentation": "The CHECKSUM() function returns a checksum value for supplied data.",
                "detail": "CHECKSUM(data {, mode})",
                "snippet": "CHECKSUM(${1:expression}, ${2:mode})"
            },
            {
                "key": "Child",
                "icon": 3,
                "documentation": "The CHILD() function tests whether a phantom process started from the current session is still running.",
                "detail": "CHILD(userno)",
                "snippet": "CHILD(${1:userno})"
            },
            {
                "key": "Class",
                "icon": 3,
                "documentation": "The CLASS statement declares a class module.",
                "detail": "CLASS name {MAX.ARGS limit} {INHERITS class.list}",
                "snippet": "CLASS ${1:name}\n\t${2:statements}\nEND"
            },
            {
                "key": "Clear",
                "icon": 14,
                "documentation": "The CLEAR statement sets all local variables to zero.",
                "detail": "CLEAR",
                "snippet": "CLEAR"
            },
            {
                "key": "Clearcommon",
                "icon": 14,
                "documentation": "The CLEARCOMMON statement sets all variables in the unnamed common area to zero. Used with a common block name, it clears the named common.",
                "detail": "CLEARCOMMON {name}\nCLEAR COMMON {name}",
                "snippet": "CLEARCOMMON $1"
            },
            {
                "key": "Cleardata",
                "icon": 14,
                "documentation": "The CLEARDATA statement clears any data stored by previous DATA statements or DATA verbs and not yet processed by INPUT statements.",
                "detail": "CLEARDATA",
                "snippet": "CLEARDATA"
            },
            {
                "key": "Clearfile",
                "icon": 14,
                "documentation": "The CLEARFILE statement clears a file previously opened using the OPEN statement, deleting all records.",
                "detail": "CLEARFILE file.var {ON ERROR statement(s)}",
                "snippet": "CLEARFILE ${1:variable}"
            },
            {
                "key": "Clearinput",
                "icon": 14,
                "documentation": "The CLEARINPUT statement clears any keyboard data that has been entered but not yet processed by INPUT or KEYIN() statements.",
                "detail": "CLEARINPUT\nCLEAR INPUT",
                "snippet": "CLEARINPUT"
            },
            {
                "key": "Clearselect",
                "icon": 14,
                "documentation": "The CLEARSELECT statement clears one or all select lists.",
                "detail": "CLEARSELECT {list.no}\nCLEARSELECT ALL\nCLEARSELECT var",
                "snippet": "CLEARSELECT ${1:ListName}"
            },
            {
                "key": "Close",
                "icon": 14,
                "documentation": "The CLOSE statement closes a file previously opened using the OPEN or OPENPATH statement.",
                "detail": "CLOSE file.var {ON ERROR statement(s)}",
                "snippet": "CLOSE ${1:variable}"
            },
            {
                "key": "Close.Socket",
                "icon": 14,
                "documentation": "The CLOSE.SOCKET statement closes a socket.",
                "detail": "CLOSE.SOCKET skt",
                "snippet": "CLOSE.SOCKET ${1:skt}"
            },
            {
                "key": "Closeseq",
                "icon": 14,
                "documentation": "The CLOSESEQ statement closes an item previously opened using OPENSEQ.",
                "detail": "CLOSESEQ file.var {ON ERROR statement(s)}",
                "snippet": "CLOSESEQ ${1:filevar}"
            },
            {
                "key": "Col1",
                "icon": 3,
                "documentation": "The COL1() function returns the character position immediately preceding the substring extracted by the last FIELD() or LAST() function.",
                "detail": "COL1()",
                "snippet": "COL1()"
            },
            {
                "key": "Col2",
                "icon": 3,
                "documentation": "The COL2() function returns the character position immediately following the substring extracted by the last FIELD() or LAST() function.",
                "detail": "COL2()",
                "snippet": "COL2()"
            },
            {
                "key": "Collection",
                "icon": 3,
                "documentation": "The COLLECTION() function creates a data collection variable.",
                "detail": "COLLECTION()\nCOLLECTION(var)",
                "snippet": "COLLECTION($1)"
            },
            {
                "key": "Commit",
                "icon": 14,
                "documentation": "The BEGIN TRANSACTION statement starts a new transaction. All updates until a corresponding END TRANSACTION are cached and only applied to the database when a COMMIT statement is executed.",
                "detail": "COMMIT",
                "snippet": "COMMIT"
            },
            {
                "key": "Common",
                "icon": 14,
                "documentation": "The COMMON statement declares variables in a common block.",
                "detail": "COMMON {\/name\/} var1 {,var2...}",
                "snippet": "COMMON $1"
            },
            {
                "key": "Compare",
                "icon": 3,
                "documentation": "The COMPARE() function compares two strings using the same rules as the LOCATE statement.",
                "detail": "COMPARE(expression1, expression2{, justification})",
                "snippet": "COMPARE(expression1, expression2, ${1:justification})"
            },
            {
                "key": "Compares",
                "icon": 3,
                "documentation": "The COMPARES() function is similar to the COMPARE() function but operates on a multivalued list of strings.",
                "detail": "COMPARES(string1, string2 {, justification})",
                "snippet": "COMPARES(string1, string2, ${1:justification})"
            },
            {
                "key": "Config",
                "icon": 3,
                "documentation": "The CONFIG() function returns the value of a configuration parameter.",
                "detail": "CONFIG(param)",
                "snippet": "CONFIG(${1:param})"
            },
            {
                "key": "Connect.Port",
                "icon": 3,
                "documentation": "The CONNECT.PORT() function converts a phantom process into an interactive session, using a serial port as its terminal device.",
                "detail": "CONNECT.PORT(port, baud, parity, bits, stop)",
                "snippet": "CONNECT.PORT(${1:port}, ${2:baud}, ${3:parity}, ${4:bits}, ${5:stop})"
            },
            {
                "key": "Continue",
                "icon": 14,
                "documentation": "The CONTINUE statement continues execution of the next cycle of a LOOP\/REPEAT or FOR\/NEXT structure.",
                "detail": "CONTINUE",
                "snippet": "CONTINUE"
            },
            {
                "key": "Convert",
                "icon": 3,
                "documentation": "The CONVERT() function replaces selected characters by others in a string. The CONVERT() function leaves the source string unchanged and returns the modified value.",
                "detail": "CONVERT(from.chars, to.string, source.string)",
                "snippet": "CONVERT(${1:from_chars}, ${2:to_string}, ${3:source_string})"
            },
            {
                "key": "Convert",
                "icon": 14,
                "documentation": "The CONVERT statement replaces selected characters by others in a string. The CONVERT statement performs this conversion in-situ.",
                "detail": "CONVERT from.chars TO to.string IN var",
                "snippet": "CONVERT ${1:from_chars} TO ${2:to_string} IN ${3:var}"
            },
            {
                "key": "Cos",
                "icon": 3,
                "documentation": "The COS() function returns the cosine of a value.",
                "detail": "COS(expr)",
                "snippet": "COS(${1:expression})"
            },
            {
                "key": "Count",
                "icon": 3,
                "documentation": "The COUNT() function counts occurrences of a substring within a string. ",
                "detail": "COUNT(string, substring)",
                "snippet": "COUNT(${1:expression}, ${2:delimiter})"
            },
            {
                "key": "Counts",
                "icon": 3,
                "documentation": "The COUNTS() function is similar to COUNT() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "COUNTS(string, substring)",
                "snippet": "COUNTS(${1:dynamic_array}, ${2:substring})"
            },
            {
                "key": "Create",
                "icon": 14,
                "documentation": "The CREATE statement creates an empty sequential file record after a previous OPENSEQ has reported that the record did not exist.",
                "detail": "CREATE file.var\n{ON ERROR statement(s)}\n{THEN statement(s)}\n{ELSE statement(s)}",
                "snippet": "CREATE ${1:filevar} THEN ${2:then_statement} ELSE ${3:else_statement}"
            },
            {
                "key": "Create.File",
                "icon": 14,
                "documentation": "The CREATE.FILE statement creates the operating system representation of a directory or dynamic hash file.",
                "detail": "CREATE.FILE path {DIRECTORY | DYNAMIC}\n{GROUP.SIZE grpsz}\n{BIG.REC.SIZE bigrec}\n{MIN.MODULUS minmod}\n{SPLIT.LOAD split}\n{MERGE.LOAD merge}\n{VERSION ver}\n{ON ERROR statement(s)}",
                "snippet": "CREATE.FILE ${1:path} ${2:DIRECTORY_DYNAMIC}"
            },
            {
                "key": "Create.Server.Socket",
                "icon": 3,
                "documentation": "The CREATE.SERVER.SOCKET() function creates a server socket on which a program may wait for incoming connections.",
                "detail": "CREATE.SERVER.SOCKET(addr, port, flags)",
                "snippet": "CREATE.SERVER.SOCKET(${1:addr}, ${2:port}, ${3:flags})"
            },
            {
                "key": "Crop",
                "icon": 3,
                "documentation": "The CROP() function removes redundant mark characters from a string.",
                "detail": "CROP(string)",
                "snippet": "CROP(${1:string})"
            },
            {
                "key": "Crt",
                "icon": 14,
                "documentation": "The CRT statement sends data to the display. ",
                "detail": "CRT {print.list}",
                "snippet": "CRT ${1:expression}"
            },
            {
                "key": "Crt @",
                "icon": 14,
                "documentation": "The CRT statement sends data to the display. ",
                "detail": "CRT @($col, $row):$expression",
                "snippet": "CRT @(${1:col}, ${2:row}):${3:expression}"
            },
            {
                "key": "Csvdq",
                "icon": 3,
                "documentation": "The CSVDQ() function de-quotes a CSV (comma separated variable) string.",
                "detail": "CSVDQ(string {, delimiter})",
                "snippet": "CSVDQ(${1:string}, ${2:delimiter})"
            },
            {
                "key": "Csv.Mode",
                "icon": 3,
                "documentation": "The CSV.MODE statement sets the conversion mode for CSV (comma separated variable) construction.",
                "detail": "CSV.MODE mode {, delim}",
                "snippet": "CSV.MODE ${1:mode}, ${2:delim}"
            },
            {
                "key": "Data",
                "icon": 14,
                "documentation": "The DATA statement adds one or more items to the input data queue",
                "detail": "DATA expr{, expr...}",
                "snippet": "DATA ${1:expression}"
            },
            {
                "key": "Date()",
                "icon": 3,
                "documentation": "The DATE() function returns the internal value of the current date.",
                "detail": "DATE()",
                "snippet": "DATE()"
            },
            {
                "key": "Dcount",
                "icon": 3,
                "documentation": "The DCOUNT() function counts delimited substrings within a string.",
                "detail": "DCOUNT(string, delimiter)",
                "snippet": "DCOUNT(${1:expression}, ${2:delimiter})"
            },
            {
                "key": "Debug",
                "icon": 14,
                "documentation": "The DEBUG statement enters the interactive debugger.",
                "detail": "DEBUG",
                "snippet": "DEBUG"
            },
            {
                "key": "Decrypt",
                "icon": 3,
                "documentation": "The DECRYPT() function decrypts data that has been encrypted for secure storage or transmission.",
                "detail": "DECRYPT(data, key)",
                "snippet": "DECRYPT(${1:string}, ${2:key})"
            },
            {
                "key": "Deffun",
                "icon": 14,
                "documentation": "The DEFFUN statement defines a function.",
                "detail": "DEFFUN name {(arg1 {, arg2 ...})} {CALLING \"func\" | expr} {VAR.ARGS} {KEY key}\nDEFFUN name {(arg1 {, arg2 ...})} LOCAL\nDEFFUN name {(arg1 {, arg2 ...})} EXTERNAL {CALLING \"libname\"}\nDEFFUN name {(arg1 {, arg2 ...})} EXTERNAL {CALLING \"libname:funcname\"}",
                "snippet": "DEFFUN ${1:FuncName}(${2:args})"
            },
            {
                "key": "Del",
                "icon": 14,
                "documentation": "The DEL statement and DELETE() function delete a field, value or subvalue from a dynamic array. Used with a data collection, the DEL statement deletes an element.",
                "detail": "DEL dyn.array\nDELETE(dyn.array, field {, value {, subvalue}})\nDEL collection{path}",
                "snippet": "DEL ${1:variable}"
            },
            {
                "key": "Delete",
                "icon": 14,
                "documentation": "The DELETE statement deletes a record from an open file.",
                "detail": "DELETE file.var, record.id {ON ERROR statement(s)}",
                "snippet": "DELETE ${1:filevar},${2:recordkey}"
            },
            {
                "key": "Deletelist",
                "icon": 14,
                "documentation": "The DELETELIST statement deletes a select list from the $SAVEDLISTS file.",
                "detail": "DELETELIST name",
                "snippet": "DELETELIST ${1:expression}"
            },
            {
                "key": "Deleteseq",
                "icon": 14,
                "documentation": "The DELETESEQ statement deletes an operating system file.",
                "detail": "DELETESEQ filename, id {NO.MAP} {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}\nor\nDELETESEQ pathname {NO.MAP} {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "DELETESEQ ${1:filename}, ${2:id}  THEN ${3:then_statement} ELSE ${4:else_statement}"
            },
            {
                "key": "Deleteu",
                "icon": 14,
                "documentation": "The DELETEU statement is similar to the DELETE statment but preserves locks.",
                "detail": "DELETEU file.var, record.id {ON ERROR statement(s)}",
                "snippet": "DELETEU ${1:filevar},${2:recordkey}"
            },
            {
                "key": "Dfpart",
                "icon": 3,
                "documentation": "The DFPART() function returns a file variable that references an individual part of a distributed file.",
                "detail": "DFPART(dist.file, part)",
                "snippet": "DFPART(${1:distfile}, ${2:part})"
            },
            {
                "key": "Digest",
                "icon": 3,
                "documentation": "The DIGEST() function returns the message digest string for a supplied string or file.",
                "detail": "DIGEST(string, is.file, mode)",
                "snippet": "DIGEST(${1:string}, ${2:isfile}, ${3:mode})"
            },
            {
                "key": "Dimension",
                "icon": 14,
                "documentation": "The DIMENSION statement is used to set the dimensions of a matrix. The short form DIM may be used in place of DIMENSION. The REDIMENSION or REDIM statement is identical except where the matrix is a subroutine argument.",
                "detail": "DIMENSION mat(rows {, cols})\nREDIMENSION mat(rows {, cols})\nDIMENSION var",
                "snippet": "DIM ${1:variable}(${2:numbers})"
            },
            {
                "key": "Dim",
                "icon": 14,
                "documentation": "The DIMENSION statement is used to set the dimensions of a matrix. The short form DIM may be used in place of DIMENSION. The REDIMENSION or REDIM statement is identical except where the matrix is a subroutine argument.",
                "detail": "DIM $variable($numbers)",
                "snippet": "DIM ${1:variable}(${2:numbers})"
            },
            {
                "key": "Dir",
                "icon": 3,
                "documentation": "The DIR() function returns the contents of an operating system directory.",
                "detail": "DIR(pathname)",
                "snippet": "DIR(${1:filename})"
            },
            {
                "key": "Disinherit",
                "icon": 14,
                "documentation": "The DISINHERIT statement used in a class module removes an inherited object.",
                "detail": "DISINHERIT object",
                "snippet": "DISINHERIT ${1:object}"
            },
            {
                "key": "Display",
                "icon": 14,
                "documentation": "The DISPLAY statement sends data to the display. The synonym CRT can be used in place of DISPLAY.",
                "detail": "DISPLAY {print.list}",
                "snippet": "DISPLAY ${1:expression}"
            },
            {
                "key": "Display.Width",
                "icon": 3,
                "documentation": "The DISPLAY.WIDTH() function returns the number of character positions required to display a string.",
                "detail": "DISPLAY.WIDTH(string)",
                "snippet": "DISPLAY.WIDTH(${1:str})"
            },
            {
                "key": "Display.Widths",
                "icon": 3,
                "documentation": "The DISPLAY.WIDTHS() function is similar to DISPLAY.WIDTH() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "DISPLAY.WIDTHS(dyn.array)",
                "snippet": "DISPLAY.WIDTHS(${1:dynarr})"
            },
            {
                "key": "Disable.Key",
                "icon": 14,
                "documentation": "The DISABLE.KEY statement is used to disable access to a secure encryption key previously enabled with ENABLE.KEY.",
                "detail": "DISABLE.KEY keyname",
                "snippet": "DISABLE.KEY ${1:keyname}"
            },
            {
                "key": "Div",
                "icon": 3,
                "documentation": "The DIV() function returns the quotient from a division operation.",
                "detail": "DIV(dividend, divisor)",
                "snippet": "DIV(${1:dividend}, ${2:divisor})"
            },
            {
                "key": "Downcase",
                "icon": 3,
                "documentation": "The DOWNCASE() function returns a string with all letters converted to lower case.",
                "detail": "DOWNCASE(string)",
                "snippet": "DOWNCASE(${1:expression})"
            },
            {
                "key": "Dparse",
                "icon": 14,
                "documentation": "The DPARSE statement splits the elements of a delimited string into other variables.",
                "detail": "DPARSE string, delimiter, var1, var2,...",
                "snippet": "DPARSE ${1:str}, ${2:delim}, ${3:vars}"
            },
            {
                "key": "Dparse.Csv",
                "icon": 14,
                "documentation": "DPARSE.CSV is similar to DPARSE but unquotes strings according to the rules in the CSV standard.",
                "detail": "DPARSE.CSV string, delimiter, var1, var2,...",
                "snippet": "DPARSE.CSV ${1:str}, ${2:delim}, ${3:vars}"
            },
            {
                "key": "Dquote",
                "icon": 3,
                "documentation": "The DQUOTE() function returns a copy of its argument string enclosed in double quotes.",
                "detail": "DQUOTE(expr)",
                "snippet": "DQUOTE(${1:expression})"
            },
            {
                "key": "Dquotes",
                "icon": 3,
                "documentation": "The DQUOTES() functions is similar to the DQUOTE() function but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "DQUOTES(expr)",
                "snippet": "DQUOTE(${1:expression})"
            },
            {
                "key": "Dtx",
                "icon": 3,
                "documentation": "The DTX() function converts a number to hexadecimal.",
                "detail": "DTX(expr {, min.width})",
                "snippet": "DTX(${1:expression})"
            },
            {
                "key": "Ebcdic",
                "icon": 3,
                "documentation": "The EBCDIC() function converts an ASCII string to EBCDIC.",
                "detail": "EBCDIC(expr)",
                "snippet": "EBCDIC(${1:expression})"
            },
            {
                "key": "Echar",
                "icon": 3,
                "documentation": "The ECHAR() function returns the ECS character with a given code point value.",
                "detail": "ECHAR(seq)",
                "snippet": "ECHAR(${1:seq})"
            },
            {
                "key": "Echars",
                "icon": 3,
                "documentation": "The ECHARS() function is similar to ECHAR() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "ECHAR(dyn.arr)",
                "snippet": "ECHARS(${1:arr})"
            },
            {
                "key": "Echo",
                "icon": 14,
                "documentation": "The ECHO statement enables or disables echoing of keyboard input.",
                "detail": "ECHO OFF\nECHO ON\nECHO expr",
                "snippet": "ECHO ${1:expression}"
            },
            {
                "key": "Element.Exists",
                "icon": 3,
                "documentation": "The ELEMENT.EXISTS() function tests whether an element exists in a data collection.",
                "detail": "ELEMENT.EXISTS(var{path})",
                "snippet": "ELEMENT.EXISTS(${1:var})"
            },
            {
                "key": "Enable.Key",
                "icon": 14,
                "documentation": "The ENABLE.KEY statement is used to enter the password for a secure encryption key.",
                "detail": "ENABLE.KEY keyname, password {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "ENABLE.KEY ${1:keyname}, ${2:password} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Encrypt",
                "icon": 3,
                "documentation": "The ENCRYPT() function encrypts data for secure storage or transmission.",
                "detail": "ENCRYPT(data, key)",
                "snippet": "ENCRYPT(${1:string}, ${2:key})"
            },
            {
                "key": "Encryptx",
                "icon": 3,
                "documentation": "The ENCRYPTX() function encrypts data for secure storage or transmission. The function uses a random initialisation vector that it included in the returned encrypted string. This results in greater security.",
                "detail": "ENCRYPTX(data, key)",
                "snippet": "ENCRYPTX(${1:string}, ${2:key})"
            },
            {
                "key": "End",
                "icon": 14,
                "documentation": "The END statement terminates a program, subroutine or a block of statements conditioned by the THEN, ELSE, LOCKED or ON ERROR keywords.",
                "detail": "END",
                "snippet": "END"
            },
            {
                "key": "End Transaction",
                "icon": 14,
                "documentation": "The END TRANSACTION statement marks the end of a transaction. There should be a corresponding BEGIN TRANSACTION.",
                "detail": "END TRANSACTION",
                "snippet": "END TRANSACTION"
            },
            {
                "key": "Enter",
                "icon": 14,
                "documentation": "The ENTER statement is a synonym for CALL unless the PICK.ENTER option of the $MODE directive is used.",
                "detail": "ENTER name {(arg.list)}\nENTER @var {(arg.list)}\nENTER \"file name\" {(arg.list)}",
                "snippet": "ENTER ${1:name} ${2:arglist}"
            },
            {
                "key": "Enter.Package",
                "icon": 3,
                "documentation": "The ENTER.PACKAGE() function attempts to enter a licensed software package.",
                "detail": "ENTER.PACKAGE(package.name)",
                "snippet": "ENTER.PACKAGE(${1:name})"
            },
            {
                "key": "Enumerate",
                "icon": 3,
                "documentation": "The ENUMERATE() function identifies the elements in a data collection.",
                "detail": "ENUMERATE(var)",
                "snippet": "ENUMERATE(${1:var})"
            },
            {
                "key": "Env",
                "icon": 3,
                "documentation": "The ENV() function retrieves an operating system environment variable.",
                "detail": "ENV(var.name)",
                "snippet": "ENV(${1:varname})"
            },
            {
                "key": "Epoch",
                "icon": 3,
                "documentation": "The EPOCH() function returns the internal value of the current date and time in epoch format.",
                "detail": "EPOCH()",
                "snippet": "EPOCH()"
            },
            {
                "key": "Eqs",
                "icon": 3,
                "documentation": "The EQS() function processes two dynamic arrays, returning a similarly structured result array indicating whether corresponding elements are equal.",
                "detail": "EQS(expr1, expr2)",
                "snippet": "EQS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Equate",
                "icon": 14,
                "documentation": "The EQUATE statement, often abbreviated to EQU, defines a symbolic name to represent a QMBasic expression.",
                "detail": "EQUATE name LITERALLY \"string\"\nEQUATE name TO expression",
                "snippet": "EQUATE ${1:symbol} TO ${2:expression}"
            },
            {
                "key": "Ereplace",
                "icon": 3,
                "documentation": "The EREPLACE() function replaces occurrences of a substring within a string by another substring.",
                "detail": "EREPLACE(string, old, new{, occurrence{, start}})",
                "snippet": "EREPLACE(${1:expression}, ${2:substring}, ${3:replacement}, ${4:occurrence}, ${5:begin})"
            },
            {
                "key": "Errmsg",
                "icon": 3,
                "documentation": "The ERRMSG statement displays a Pick style message from the ERRMSG file.",
                "detail": "ERRMSG msg.id {, arg...}",
                "snippet": "ERRMSG ${1:msgid}"
            },
            {
                "key": "Evaluate",
                "icon": 3,
                "documentation": "The EVALUATE statement evaluates an I-type expression, trapping errors.",
                "detail": "EVALUATE var FROM i.type {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "EVALUATE ${1:var} FROM ${2:itype} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Execute",
                "icon": 14,
                "documentation": "The EXECUTE statement enables a QMBasic program to execute any command. The synonym PERFORM can be used in place of EXECUTE.",
                "detail": "EXECUTE expr {TRAPPING ABORTS}\n{CAPTURING var}\n{NO.TTY}\n{PASSLIST {src.list }}\n{RTNLIST tgt.list }\n{SILENT}\n{STACKLIST}\n{SETTING status.var} or {RETURNING status.var}",
                "snippet": "EXECUTE ${1:expression}"
            },
            {
                "key": "Exit",
                "icon": 14,
                "documentation": "The EXIT statement terminates execution of  a LOOP\/REPEAT or FOR\/NEXT structure.",
                "detail": "EXIT",
                "snippet": "EXIT"
            },
            {
                "key": "Exit.Package",
                "icon": 3,
                "documentation": "The EXIT.PACKAGE() function exits from a software package.",
                "detail": "EXIT.PACKAGE(package.name)",
                "snippet": "EXIT.PACKAGE(${1:pkgname})"
            },
            {
                "key": "Exp",
                "icon": 3,
                "documentation": "The EXP() function returns the exponential (the natural anti-log) of a value.",
                "detail": "EXP(expr)",
                "snippet": "EXP(${1:expression})"
            },
            {
                "key": "Expand",
                "icon": 3,
                "documentation": "The EXPAND() function merges a data collection with a linked item.",
                "detail": "EXPAND(link.item)\nEXPAND(link.item, fvar)",
                "snippet": "EXPAND(${1:linkitem}, ${2:fvar})"
            },
            {
                "key": "Extract",
                "icon": 3,
                "documentation": "The EXTRACT() function extracts a field, value or subvalue from a dynamic array.",
                "detail": "EXTRACT(dyn.array, field {, value {, subvalue}})",
                "snippet": "EXTRACT(${1:DynArr}, ${2:attr})"
            },
            {
                "key": "Fcontrol",
                "icon": 3,
                "documentation": "The FCONTROL() function performs control actions on an open file.",
                "detail": "FCONTROL(fvar, action {, qualifier})",
                "snippet": "FCONTROL(${1:fvar}, ${2:action}, ${3:qualifier})"
            },
            {
                "key": "Field",
                "icon": 3,
                "documentation": "The FIELD() function returns one or more delimited substrings from a string.",
                "detail": "FIELD(string, delimiter, occurrence {, count})",
                "snippet": "FIELD(${1:string}, ${2:delimiter}, ${3:occurrence})"
            },
            {
                "key": "Fields",
                "icon": 3,
                "documentation": "The FIELDS() function is similar to FIELD() but operates on a multivalued string, returning a similarly structured dynamic array of results.",
                "detail": "FIELDS(dyn.arr, delimiter, occurrence {, count})",
                "snippet": "FIELDS(${1:DynArr}, ${2:delimiter}, ${3:occurrence}, ${4:extractCount})"
            },
            {
                "key": "Fieldstore",
                "icon": 3,
                "documentation": "The FIELDSTORE() function provides delimited substring assignment. It is closely related to the GROUPSTORE statement.",
                "detail": "FIELDSTORE(string, delimiter, i, n, rep.string)",
                "snippet": "FIELDSTORE(${1:string}, ${2:delimiter}, ${3:i}, ${4:n}, ${5:repstring})"
            },
            {
                "key": "File",
                "icon": 3,
                "documentation": "The FILE statement provides a way to reference data in files using field names defined in the dictionary. This statement is provided for compatibility with other systems and its use is discouraged.",
                "detail": "FILE name, ...",
                "snippet": "FILE ${1:name}"
            },
            {
                "key": "File.Event",
                "icon": 3,
                "documentation": "The FILE.EVENT() function creates a file event monitoring variable (Windows only).",
                "detail": "FILE.EVENT(path, event)",
                "snippet": "FILE.EVENT(${1:path}, ${2:event})"
            },
            {
                "key": "Fileinfo",
                "icon": 3,
                "documentation": "The FILEINFO() function returns information about an open file.",
                "detail": "FILEINFO(file.var, key)",
                "snippet": "FILEINFO(${1:file_variable}, ${2:key})"
            },
            {
                "key": "Filelock",
                "icon": 14,
                "documentatin": "The FILELOCK statement sets a file lock on a file.",
                "detail": "FILELOCK file.var {ON ERROR statement(s)} {LOCKED statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "FILELOCK filevar LOCKED ${1:lock_statements} ON ERROR ${2:error_statements} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND",
                "snippetDoc": "The FILELOCK statement sets a file lock on a file."
            },
            {
                "key": "Fileunlock",
                "icon": 14,
                "documentation": "The FILEUNLOCK statement releases a file lock previously obtained using the FILELOCK statement.",
                "detail": "FILEUNLOCK file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "FILEUNLOCK ${1:file_variable} ON ERROR ${2:statements} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Find",
                "icon": 14,
                "documentation": "The FIND statement searches a dynamic array for a given string in any position.",
                "detail": "FIND string IN dyn.array {, occurrence} {SETTING field{, value {, subvalue}}} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "FIND ${1:expression1} IN ${2:Var1} SETTING ${3:Var2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Findstr",
                "icon": 14,
                "documentation": "The FINDSTR statement searches a dynamic array for a given substring in any position.",
                "detail": "FINDSTR string IN dyn.array {, occurrence} {SETTING field{, value {, subvalue}}} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "FINDSTR ${1:expression1} IN ${2:Var1} SETTING ${3:Var2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Fix",
                "icon": 3,
                "documentation": "The FIX() function returns a string representation of a floating point value with a specified precision and optional truncation.",
                "detail": "FIX(expr {, prec{, truncate}})",
                "snippet": "FIX(${1:expr}, ${2:prec}, ${3:truncate})"
            },
            {
                "key": "Floor",
                "icon": 3,
                "documentation": "The FLOOR() function returns the largest integer not greater than the argument value.",
                "detail": "FLOOR(value)",
                "snippet": "FLOOR(${1:value})"
            },
            {
                "key": "Flush",
                "icon": 14,
                "documentation": "The FLUSH statement flushes the internal buffers for a directory file record previously opened for sequential access.",
                "detail": "FLUSH file.var {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "FLUSH ${1:file_variable} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Flush.Dh.Cache",
                "icon": 14,
                "documentation": "The FLUSH.DH.CACHE statement flushes the dynamic file cache.",
                "detail": "FLUSH.DH.CACHE {LOCAL | NO.WAIT}",
                "snippet": "FLUSH.DH.CACHE ${1:LOCAL_NOWAIT}"
            },
            {
                "key": "Fmt",
                "icon": 3,
                "documentation": "The FMT() function performs data formatting according to a format template. It is typically used to convert data for display or printing. ",
                "detail": "FMT(expr, fmt.spec)",
                "snippet": "FMT(${1:var}, ${2:code})"
            },
            {
                "key": "Fmtdw",
                "icon": 3,
                "documentation": "The FMTDW() function performs data formatting according to a format template based on display width.",
                "detail": "FMTDW(expr, fmt.spec)",
                "snippet": "FMTDW(${1:expr}, ${2:fmtspec})"
            },
            {
                "key": "Fmtdws",
                "icon": 3,
                "documentation": "The FMTDWS() function is identical to FMTDW() except that it works on each element of a dynamic array in turn, returning the result in a similarly delimited dynamic array.",
                "detail": "FMTDWS(expr, fmt.spec)",
                "snippet": "FMTDWS(${1:expr}, ${2:fmtspec})"
            },
            {
                "key": "Fmts",
                "icon": 3,
                "documentation": "The FMTS() function is identical to FMT() except that it works on each element of a dynamic array in turn, returning the result in a similarly delimited dynamic array.",
                "detail": "FMTS(expr, fmt.spec)",
                "snippet": "FMTS(${1:DynArr}, ${2:format})"
            },
            {
                "key": "Fold",
                "icon": 3,
                "documentation": "The FOLD() function breaks a string into field mark delimited sections no longer than a given width, placing breaks on spaces where possible.",
                "detail": "FOLD(string, width {, delim})",
                "snippet": "FOLD(${1:str}, ${2:width}, ${3:delim})"
            },
            {
                "key": "Folddw",
                "icon": 3,
                "documentation": "The FOLDDW() function breaks a string into field mark delimited sections no longer than a given display width, placing breaks on spaces where possible.",
                "detail": "FOLDDW(string, width {, delim})",
                "snippet": "FOLDDW(${1:str}, ${2:width}, ${3:delim})"
            },
            {
                "key": "Folddws",
                "icon": 3,
                "documentation": "The FOLDDWS() function is similar to FOLDDW() but works on each field, value or subvalue of string separately, returning a similarly structured dynamic array of folded strings",
                "detail": "FOLDDWS(string, width {, delim})",
                "snippet": "FOLDDWS(${1:str}, ${2:width}, ${3:delim})"
            },
            {
                "key": "Folds",
                "icon": 3,
                "documentation": "The FOLDS() function is similar to FOLD() but works on each field, value or subvalue of string separately, returning a similarly structured dynamic array of folded strings.",
                "detail": "FOLDS(string, width {, delim})",
                "snippet": "FOLDS(${1:str}, ${2:width}, ${3:delim})"
            },
            {
                "key": "Footing",
                "icon": 14,
                "documentation": "The FOOTING statement defines text to be printed or displayed at the foot of each page of output.",
                "detail": "FOOTING {ON print.unit} text",
                "snippet": "FOOTING ${1:expression}"
            },
            {
                "key": "For",
                "icon": 14,
                "documentation": "The FOR statement defines the start of a group of statements to be executed with an iterative control variable.",
                "detail": "FOR $var = $start TO $limit\n\t$statement\nNEXT $var",
                "snippet": "FOR ${1:var} = ${2:start} TO ${3:limit}\n\t${4:statement}\nNEXT ${5:var}"
            },
            {
                "key": "For Each",
                "icon": 14,
                "documentation": "The FOR statement defines the start of a group of statements to be executed with an iterative control variable.",
                "detail": "FOR EACH $var IN $str\n\t$statements\nNEXT $var",
                "snippet": "FOR EACH ${1:var} IN ${2:str}\n\t${3:statements}\nNEXT ${4:var}"
            },
            {
                "key": "Formcsv",
                "icon": 3,
                "documentation": "The FORMCSV() function transforms a string to a CSV standard compliant item.",
                "detail": "FORMCSV(string)",
                "snippet": "FORMCSV(${1:str})"
            },
            {
                "key": "FormList",
                "icon": 14,
                "documentation": "The FORMLIST statement creates a numbered select list from a dynamic array.",
                "detail": "FORMLIST dyn.array {TO list.no}",
                "snippet": "FORMLIST ${1:dynarr} TO ${2:listno}"
            },
            {
                "key": "FormListv",
                "icon": 14,
                "documentation": "The FORMLISTV statement is similar to FORMLIST but creates a select list variable.",
                "detail": "FORMLISTV dyn.array TO var",
                "snippet": "FORMLISTV ${1:dynarr} TO ${2:var}"
            },
            {
                "key": "Function",
                "icon": 14,
                "documentation": "The FUNCTION statement introduces a user written function and arguments.",
                "detail": "FUNCTION name{(arg1 {, arg2...}) {VAR.ARGS}}",
                "snippet": "FUNCTION ${1:name}(${2:arguments})\n\t${3:statements}\nRETURN ${4:var}"
            },
            {
                "key": "Ges",
                "icon": 3,
                "documentation": "The GES() function processes two dynamic arrays, returning a similarly structured result array indicating whether elements of the first array are greater than or equal to corresponding elements of the second array.",
                "detail": "GES(expr1, expr2)",
                "snippet": "GES(${1:array1}, ${2:array2})"
            },
            {
                "key": "Get",
                "icon": 14,
                "index": 246,
                "documentation": "Synonym for PUBLIC function",
                "detail": "GET var, mat(rows, cols), ...\nGET SUBROUTINE name{(arg1, arg2)} {VAR.ARGS} ...statements... END\nGET FUNCTION name{(arg1, arg2)} {VAR.ARGS} ...statements... END",
                "snippet": "GET ${1:Var} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Get(Arg.)",
                "icon": 14,
                "index": 247,
                "documentation": "The GET(ARG.) statement fetches command line arguments.",
                "detail": "GET(ARG. {, argno}) var  {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "GET(ARG. ${1:arg}) ${2:var}  THEN ${3:then_statement} ELSE ${4:else_statement}"
            },
            {
                "key": "Get.Messages",
                "icon": 3,
                "documentation": "The GET.MESSAGES() function returns any messages currently queued for display.",
                "detail": "GET.MESSAGES()",
                "snippet": "GET.MESSAGES()"
            },
            {
                "key": "Get.Port.Params",
                "icon": 3,
                "documentation": "The GET.PORT.PARAMS() function retrieves the communications parameters for a serial port.",
                "detail": "GET.PORT.PARAMS(fvar)",
                "snippet": "GET.PORT.PARAMS(${1:fvar})"
            },
            {
                "key": "Getlist",
                "icon": 14,
                "documentation": "The GETLIST statement restores a select list from the $SAVEDLISTS file.",
                "detail": "GETLIST name {TO list.no} {SETTING count.var} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "GETLIST ${1:listname} TO ${2:variable1} SETTING ${3:variable2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Getlistv",
                "icon": 14,
                "documentation": "The GETLISTV statement is similar to the GETLIST() but creates a select list variable.",
                "detail": "GETLISTV name TO list.var {SETTING count.var} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "GETLISTV ${1:listname} TO ${2:variable1} SETTING ${3:variable2} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Getlocks",
                "icon": 14,
                "documentation": "The GETLOCKS() function returns information about file and record locks.",
                "detail": "GETLOCKS(file, user)",
                "snippet": "GETLOCKS(${1:file}, ${2:user})"
            },
            {
                "key": "Getnls",
                "icon": 3,
                "index": 253,
                "documentation": "The GETNLS() function returns the value of a national language support parameter.",
                "detail": "GETNLS(key)",
                "snippet": "GETNLS(${1:key})"
            },
            {
                "key": "Getpu",
                "icon": 3,
                "index": 254,
                "documentation": "The GETPU() function gets the characteristics of a print unit.",
                "detail": "The GETPU() function gets the characteristics of a print unit.",
                "snippet": "GETPU(${1:key}, ${2:unit})"
            },
            {
                "key": "Getrem",
                "icon": 3,
                "index": 255,
                "documentation": "The GETREM() function returns the remove pointer position into a string.",
                "detail": "GETREM(string)",
                "snippet": "GETREM(${1:str})"
            },
            {
                "key": "Gosub",
                "icon": 14,
                "documentation": "The GOSUB statement calls an internal subroutine.",
                "detail": "GOSUB label{:}\nGOSUB label{:}(args)",
                "snippet": "GOSUB ${1:label}"
            },
            {
                "key": "Goto",
                "icon": 14,
                "documentation": "The GOTO statement continues program execution at a given label.",
                "detail": "GOTO label{:}\nGO {TO} label{:}",
                "snippet": "GOTO ${1:nope}"
            },
            {
                "key": "Groupstore",
                "icon": 14,
                "documentation": "The GROUPSTORE statement inserts, deletes or replaces elements of a delimited string. It is closely related to the FIELDSTORE() function.",
                "detail": "GROUPSTORE rep.string IN string USING i, n {, delimiter}",
                "snippet": "GROUPSTORE ${1:repstr} IN ${2:str} USING ${3:i}, ${4:n}"
            },
            {
                "key": "Gts",
                "icon": 3,
                "index": 259,
                "documentation": "The GTS() function processes two dynamic arrays, returning a similarly structured result array indicating whether elements of the first array are greater than corresponding elements of the second array.",
                "detail": "GTS(expr1, expr2)",
                "snippet": "GTS(${1:expr1}, ${2:expr2})"
            },
            {
                "key": "Heading",
                "icon": 14,
                "documentation": "The HEADING statement defines text to be printed or displayed at the top of each page of output.",
                "detail": "HEADING {NO.EJECT}  {ON print.unit} text",
                "snippet": "HEADING ${1:expression}"
            },
            {
                "key": "Hush",
                "icon": 14,
                "documentation": "The HUSH statement enables or disables display output.",
                "detail": "HUSH OFF {SETTING var}\nHUSH ON {SETTING var}\nHUSH expr {SETTING var}",
                "snippet": "HUSH ${1:expression}"
            },
            {
                "key": "Iconv",
                "icon": 3,
                "documentation": "The ICONV() function performs input conversion. Data is converted from its external representation to the internal form. This function is typically used to convert data entered at the keyboard.",
                "detail": "ICONV(expr, conv.spec)",
                "snippet": "ICONV(${1:subject}, ${2:convcode})"
            },
            {
                "key": "Iconvs",
                "icon": 3,
                "documentation": "The ICONVS() function is identical to ICONV() except that it works on each element of a dynamic array, returning the result in a similarly delimited dynamic array.",
                "detail": "ICONVS(expr, conv.spec)",
                "snippet": "ICONVS(${1:DynArr}, ${2:conversion})"
            },
            {
                "key": "Idiv",
                "icon": 3,
                "documentation": "The IDIV() function divides one integer by another and returns an integer result.",
                "detail": "IDIV(dividend, divisor)",
                "snippet": "IDIV(${1:dividend}, ${2:divisor})"
            },
            {
                "key": "If",
                "icon": 14,
                "documentation": "The IF statement provides conditional execution of one or more statements.",
                "detail": "IF expr {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "IF ${1:expr} THEN ${2:then_statement} ELSE ${3:else_statement}"
            },
            {
                "key": "Ifs",
                "icon": 3,
                "documentation": "The IFS() function returns a dynamic array constructed from elements chosen from two other dynamic arrays depending on the content of a third dynamic array",
                "detail": "IFS(control.array, true.array, false.array)",
                "snippet": "IFS(${1:dynamic_array}, ${2:true_array}, ${3:false_array})"
            },
            {
                "key": "In",
                "icon": 14,
                "documentation": "The IN statement reads a single character from the terminal with an optional timeout.",
                "detail": "IN var  {FOR timeout {THEN statement(s)} {ELSE statement(s)}}",
                "snippet": "IN ${1:var} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Include",
                "icon": 14,
                "documentation": "The INCLUDE directive is used to direct the compiler to include text from another record. Include records may be in either directory or hashed files.",
                "detail": "INCLUDE { filename } record.id",
                "snippet": "INCLUDE ${1:filename} ${2:recordid}"
            },
            {
                "key": "Index",
                "icon": 3,
                "documentation": "The INDEX() function returns the position of a specified occurrence of a substring within a string.",
                "detail": "INDEX(string, substring {, occurrence})",
                "snippet": "INDEX(${1:subject}, ${2:search}, ${3:occurrence})"
            },
            {
                "key": "Indexs",
                "icon": 3,
                "documentation": "The INDEXS() function is similar to INDEX() but operates on each element of a dynamic array element separately, locating the required occurrence of substring and returning a similarly structured dynamic array of results.",
                "detail": "INDEXS(dyn.arr, substring {, occurrence})",
                "snippet": "INDEXS(${1:subject}, ${2:search}, ${3:occurrence})"
            },
            {
                "key": "Indices",
                "icon": 3,
                "documentation": "The INDICES() function returns information about alternate key indices.",
                "detail": "INDICES(file.var)        To retrieve a list of indices\nINDICES(file.var, index.name)        To retrieve information for a specific index",
                "snippet": "INDICES(${1:filevar}, ${2:indexname})"
            },
            {
                "key": "Inherit",
                "icon": 14,
                "documentation": "The INHERIT statement used in a class module makes the public variables, functions and subroutines of another object visible as part of this object.",
                "detail": "INHERIT object",
                "snippet": "INHERIT ${1:obj}"
            },
            {
                "key": "Inmat",
                "icon": 3,
                "documentation": "The INMAT() function provides qualifying information after certain statements are executed.",
                "detail": "INMAT({mat})",
                "snippet": "INMAT(${1:array})"
            },
            {
                "key": "Input",
                "icon": 14,
                "documentation": "The INPUT statement enables entry of data from the keyboard or from previously stored DATA statements.",
                "detail": "INPUT var {= default}{, length {, fill}} {_} {:} {modes} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "INPUT ${1:var}"
            },
            {
                "key": "Input @",
                "icon": 14,
                "documentation": "The INPUT @ statement enables entry of data from the keyboard at a specific screen position or from previously stored DATA statements.",
                "detail": "INPUT @(x, y) {,} {:} var {, length {, fill}} {_} {:} {format} {modes} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "INPUT @(${1:col}, ${2:row}): ${3:var}"
            },
            {
                "key": "Inputclear",
                "icon": 14,
                "documentation": "The INPUTCLEAR statement clears any keyboard data that has been entered but not yet processed by INPUT or KEYIN() statements.",
                "detail": "INPUTCLEAR",
                "snippet": "INPUTCLEAR"
            },
            {
                "key": "Inputcsv",
                "icon": 14,
                "documentation": "The INPUTCSV statement enables entry of CSV format data from the keyboard or from previously stored DATA statements.",
                "detail": "INPUTCSV var1, var2, ...",
                "snippet": "INPUTCSV ${1:vars}"
            },
            {
                "key": "Inputerr",
                "icon": 14,
                "documentation": "The INPUTERR statement displays an error message which is removed from the screen when the next input is entered. The synonym PRINTERR can be used in place of INPUTERR.",
                "detail": "INPUTERR expr",
                "snippet": "INPUTERR ${1:expr}"
            },
            {
                "key": "Inputfield",
                "icon": 14,
                "documentation": "The INPUTFIELD statement enables entry of data from the keyboard at a specific screen position or from previously stored DATA statements.",
                "detail": "INPUTFIELD @(x, y) {,} {:} var, length {, fill} {_} {:} {format} {modes} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "INPUTFIELD @(${1:x}, ${2:y}) ${3:var}, ${4:length}"
            },
            {
                "key": "Inputfieldv",
                "icon": 14,
                "documentation": "The INPUTFIELDV statement enables entry of data from the keyboard at a specific screen position or from previously stored DATA statements.",
                "detail": "INPUTFIELDV @(x, y) {,} {:} var, length {, fill} {_} {:} {format} {modes} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "INPUTFIELDV @(${1:x}, ${2:y}) ${3:var}, ${4:length}"
            },
            {
                "key": "Inputnull",
                "icon": 14,
                "documentation": "The INPUTNULL statement sets a special character to cause INPUT @ and INPUTFIELD to return a null string.",
                "detail": "INPUTNULL expr",
                "snippet": "INPUTNULL ${1:expression}"
            },
            {
                "key": "Inputtrap",
                "icon": 14,
                "documentation": "The INPUTTRAP statement defines special actions for INPUT @ and INPUTFIELD.",
                "detail": "INPUTTRAP expr GOTO label1 {, label2...}\nINPUTTRAP expr GOSUB label1 {, label2...}",
                "snippet": "INPUTTRAP ${1:expr} GOTO ${2:label1}"
            },
            {
                "key": "Ins",
                "icon": 14,
                "documentation": "The INS statement inserts a field, value or subvalue into a dynamic array. Used with a data collection, the INS statement inserts a name\/value pair.",
                "detail": "INS string BEFORE dyn.array\nINS item AS collection{path}",
                "snippet": "INS ${1:expression} BEFORE ${2:Var}<${3:attr}, ${4:value}, ${5:subvalue}>"
            },
            {
                "key": "Insert",
                "icon": 3,
                "documentation": "The INSERT() function inserts a field, value or subvalue into a dynamic array. ",
                "detail": "INSERT(dyn.array, field {, value {, subvalue}} , string)",
                "snippet": "INSERT(${1:DynArr}, ${2:attr}, ${3:value}, ${4:subvalue}; ${5:expression})"
            },
            {
                "key": "Int",
                "icon": 3,
                "documentation": "The INT() function returns the integer part of a value.",
                "detail": "INT(expr)",
                "snippet": "INT(${1:expression})"
            },
            {
                "key": "Ioctl",
                "icon": 3,
                "documentation": "The purpose of the IOCTL function is to allow commands to be sent to the database driver for a particular file, and then to receive a reply from that same databasedriver. ",
                "detail": "IOCTL(Filevar, Command, Parameter)",
                "snippet": "IOCTL(${1:Filevar}, ${2:Command}, ${3:Parameter})"
            },
            {
                "key": "Is.Alnum",
                "icon": 3,
                "documentation": "The IS.ALNUM() function tests whether a character is defined as being either a letter or a digit.",
                "detail": "IS.ALNUM(char)",
                "snippet": "IS.ALNUM(${1:expression})"
            },
            {
                "key": "Is.Alpha",
                "icon": 3,
                "documentation": "The IS.ALPHA() function tests whether a character is defined as being a letter.",
                "detail": "IS.ALPHA(char)",
                "snippet": "IS.ALPHA(${1:expression})"
            },
            {
                "key": "Is.Digit",
                "icon": 3,
                "documentation": "The IS.DIGIT() function tests whether a character is defined as being a digit.",
                "detail": "IS.DIGIT(char)",
                "snippet": "IS.DIGIT(${1:expression})"
            },
            {
                "key": "Is.Ecs",
                "icon": 3,
                "documentation": "The IS.ECS() function tests whether a character string contains ECS characters.",
                "detail": "IS.ECS(string)",
                "snippet": "IS.ECS(${1:expression})"
            },
            {
                "key": "Is.Graph",
                "icon": 3,
                "documentation": "The IS.GRAPH() function tests whether a character is defined as being a graphical (printing) character. Note that the space is not included.",
                "detail": "IS.GRAPH(char)",
                "snippet": "IS.GRAPH(${1:expression})"
            },
            {
                "key": "Is.Mark",
                "icon": 3,
                "documentation": "The IS.MARK() function tests whether a character is defined as being a mark character (251- 255). The position of these in the character set and their meaning cannot be changed in user defined character maps.",
                "detail": "IS.MARK(char)",
                "snippet": "IS.MARK(${1:expression})"
            },
            {
                "key": "Is.Null",
                "icon": 3,
                "documentation": "The IS.NULL() function tests whether a data item holds the SQL style null value.",
                "detail": "IS.NULL(var)",
                "snippet": "IS.NULL(${1:expression})"
            },
            {
                "key": "Is.Space",
                "icon": 3,
                "documentation": "The IS.SPACE() function tests whether a character is defined as being whitespace. Unicode defines several code points as being spaces of various types.",
                "detail": "IS.SPACE(char)",
                "snippet": "IS.SPACE(${1:expression})"
            },
            {
                "key": "Is.User.Char",
                "icon": 3,
                "documentation": "The IS.USER.CHAR() function tests whether a character has the user defined attribute set.",
                "detail": "IS.USER.CHAR(char)",
                "snippet": "IS.USER.CHAR(${1:expression})"
            },
            {
                "key": "Is.Wide",
                "icon": 3,
                "documentation": "The IS.WIDE() function tests whether a character requires two display positions.",
                "detail": "IS.WIDE(char)",
                "snippet": "IS.WIDE(${1:expression})"
            },
            {
                "key": "Is.Widestr",
                "icon": 3,
                "documentation": "The IS.WIDESTR() function determines whether a string contains any wide characters.",
                "detail": "IS.WIDESTR(string)",
                "snippet": "IS.WIDESTR(${1:expression})"
            },
            {
                "key": "Itype",
                "icon": 3,
                "documentation": "The ITYPE() function executes a compiled I or C-type dictionary record or an A or S-type with a correlative.",
                "detail": "ITYPE(itype)",
                "snippet": "ITYPE(${1:itype})"
            },
            {
                "key": "Jbuild",
                "icon": 3,
                "documentation": "The JBUILD() function constructs a JSON string from a data collection.",
                "detail": "JBUILD(var)\nJBUILD(var, mode)",
                "snippet": "JBUILD(${1:var})"
            },
            {
                "key": "Jparse",
                "icon": 3,
                "documentation": "The JPARSE() function parses a JSON string into a data collection.",
                "detail": "JPARSE(var)",
                "snippet": "JPARSE(${1:var})"
            },
            {
                "key": "Keep.Select",
                "icon": 14,
                "documentation": "The KEEP.SELECT statement indicates that the default select list should be retained on return to the command processor.",
                "detail": "KEEP.SELECT",
                "snippet": "KEEP.SELECT"
            },
            {
                "key": "Keycode",
                "icon": 3,
                "documentation": "The KEYCODE() function reads a single keystroke from the keyboard.",
                "detail": "KEYCODE({timeout})",
                "snippet": "KEYCODE(${1:timeout})"
            },
            {
                "key": "Keycodev",
                "icon": 3,
                "documentation": "The KEYCODEV() function is similar to KEYCODE() but returns the code point value of the key rather than the character corresponding to the key.",
                "detail": "KEYCODEV({timeout})",
                "snippet": "KEYCODEV(${1:timeout})"
            },
            {
                "key": "Keyedit",
                "icon": 14,
                "documentation": "The KEYEDIT statement defines editing keys for use with INPUT @.",
                "detail": "KEYEDIT (action, key), (action, key), ...",
                "snippet": "KEYEDIT(${1:action}, ${2:key})"
            },
            {
                "key": "Keyexit",
                "icon": 14,
                "documentation": "The KEYEXIT statement defines exit keys for use with INPUT @.",
                "detail": "KEYEXIT (action, key), (action, key), ...",
                "snippet": "KEYEXIT(${1:action}, ${2:key})"
            },
            {
                "key": "Keyin",
                "icon": 3,
                "documentation": "The KEYIN() function read a single keystroke from the keyboard.",
                "detail": "KEYIN({timeout})",
                "snippet": "KEYIN(${1:timeout})"
            },
            {
                "key": "Keyinc",
                "icon": 3,
                "documentation": "The KEYINC() function read a single keystroke from the keyboard.",
                "detail": "KEYINC({timeout})",
                "snippet": "KEYINC(${1:timeout})"
            },
            {
                "key": "Keyincv",
                "icon": 3,
                "documentation": "The KEYINCV() function reads a single keystroke from the keyboard",
                "detail": "KEYINCV({timeout})",
                "snippet": "KEYINCV(${1:timeout})"
            },
            {
                "key": "Keyinr",
                "icon": 3,
                "documentation": "The KEYINR() function is a synonym for the KEYIN() function",
                "detail": "KEYINR({timeout})",
                "snippet": "KEYINR(${1:timeout})"
            },
            {
                "key": "Keyinv",
                "icon": 3,
                "documentation": "The KEYINV() function reads a single keystroke from the keyboard",
                "detail": "KEYINVC($timeout)",
                "snippet": "KEYINVC(${1:timeout})"
            },
            {
                "key": "Keyinvc",
                "icon": 3,
                "documentation": "The KEYINV() and KEYINCV() functions read a single keystroke from the keyboard.",
                "detail": "KEYINV($timeout)",
                "snippet": "KEYINV(${1:timeout})"
            },
            {
                "key": "Keyready",
                "icon": 3,
                "documentation": "The KEYREADY() function tests for data entered at the keyboard.",
                "detail": "KEYREADY()",
                "snippet": "KEYREADY()"
            },
            {
                "key": "Keytrap",
                "icon": 14,
                "documentation": "The KEYTRAP statement defines trap keys for use with INPUT @.",
                "detail": "KEYTRAP (action, key), (action, key), ...",
                "snippet": "KEYTRAP(${1:action}, ${2:key})"
            },
            {
                "key": "Last",
                "icon": 3,
                "documentation": "The LAST() function returns the final element of a string delimited by a specified character.",
                "detail": "LAST(string, delimiter)",
                "snippet": "LAST(${1:str}, ${2:delim})"
            },
            {
                "key": "Lasts",
                "icon": 3,
                "documentation": "The LASTS() function is similar to LAST() but operates on a multivalued string, returning a similarly structured dynamic array of results.",
                "detail": "LASTS(dyn.arr, delimiter)",
                "snippet": "LASTS(${1:dynarr}, ${2:delimiter})"
            },
            {
                "key": "Left",
                "icon": 3,
                "documentation": "The LEFT() function returns the leading part of a string.",
                "detail": "LEFT(string, len)",
                "snippet": "LEFT(${1:expression}, ${2:length})"
            },
            {
                "key": "Len",
                "icon": 3,
                "documentation": "The LEN() function returns the length of a string.",
                "detail": "LEN(string)",
                "snippet": "LEN(${1:expression})"
            },
            {
                "key": "Lens",
                "icon": 3,
                "documentation": "The LENS() function is similar to LEN() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "LENS(dyn.arr)",
                "snippet": "LENS(${1:dynarr})"
            },
            {
                "key": "Les",
                "icon": 3,
                "documentation": "The LES() function processes two dynamic arrays, returning a similarly structured result array indicating whether elements of the first array are less than or equal to corresponding elements of the second array.",
                "detail": "LES(expr1, expr2)",
                "snippet": "LES(${1:array1}, ${2:array2})"
            },
            {
                "key": "ListIndex",
                "icon": 3,
                "documentation": "The LISTINDEX() function returns the position of an item in a delimited list.",
                "detail": "LISTINDEX(list, delimiter, item)",
                "snippet": "LISTINDEX(${1:list}, ${2:delimiter}, ${3:item})"
            },
            {
                "key": "Ln",
                "icon": 3,
                "documentation": "The LN() function returns the natural log of a value.",
                "detail": "LN(expr)",
                "snippet": "LN(${1:expression})"
            },
            {
                "key": "Local",
                "icon": 14,
                "documentation": "The LOCAL statement introduces an internal function or subroutine that may have private local variables.",
                "detail": "LOCAL {FUNCTION | SUBROUTINE} name{(args)}\nPRIVATE vars\n...statements...\nEND",
                "snippet": "LOCAL ${1:FUNCTION_SUBROUTINE} ${2:name}(${3:args})\n\tPRIVATE ${4:vars}\n\t${5:statements}\nEND"
            },
            {
                "key": "Locate",
                "icon": 14,
                "documentation": "The LOCATE statement searches a dynamic array for a given field, value or subvalue.",
                "detail": "LOCATE string IN dyn.array {BY order} {SETTING var} {THEN statement(s)} {ELSE statement(s)}\nLOCATE string IN dyn.array{} {, start}  {BY order} SETTING var {THEN statement(s)} {ELSE statement(s)}\nLOCATE(string, dyn.array{, field {, value {, start }}}; var {; order}) {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "LOCATE ${1:search} IN ${2:subject} SETTING ${3:returnVar} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Locate",
                "icon": 3,
                "documentation": "The LOCATE() function provides similar capabilities to the LOCATE statment and is particularly suited to use in dictionary I-type items.",
                "detail": "LOCATE(string, dyn.array, field {,value {, subvalue }} {; order})",
                "snippet": "LOCATE(${1:string}, ${2:dynarray}, ${3:field})"
            },
            {
                "key": "Lock",
                "icon": 14,
                "documentation": "The LOCK statement obtains one of 64 system wide task locks.",
                "detail": "LOCK lock.num {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "LOCK ${1:expression} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Logmsg",
                "icon": 14,
                "documentation": "The LOGMSG statement adds a line to the system error log.",
                "detail": "LOGMSG text",
                "snippet": "LOGMSG ${1:text}"
            },
            {
                "key": "Loop",
                "icon": 14,
                "documentation": "The LOOP statement introduces a sequence of statements to be executed repeatedly.",
                "detail": "LOOP {statement(s)} {WHILE expr} {UNTIL expr} {statement(s)} REPEAT",
                "snippet": "LOOP ${1:statements1} ${2|WHILE,UNTIL|} ${3:statements2} REPEAT"
            },
            {
                "key": "Lower",
                "icon": 3,
                "documentation": "The LOWER function lowers system delimiters in a string to the next lowest delimiter.",
                "detail": "LOWER(expression)",
                "snippet": "LOWER(${1:expression})"
            },
            {
                "key": "Lts",
                "icon": 3,
                "documentation": "The LTS() function processes two dynamic arrays, returning a similarly structured result array indicating whether elements of the first array are less than corresponding elements of the second array.",
                "detail": "LTS(expr1, expr2)",
                "snippet": "LTS(${1:expr1}, ${2:expr2})"
            },
            {
                "key": "Mark.Mapping",
                "icon": 14,
                "documentation": "The MARK.MAPPING statement determines how field marks are handled when reading or writing from a directory file.",
                "detail": "MARK.MAPPING file.var, OFF\nMARK.MAPPING file.var, ON\nMARK.MAPPING file.var, expr",
                "snippet": "MARK.MAPPING ${1:filevar}, ${2:expr}"
            },
            {
                "key": "Mat",
                "icon": 14,
                "documentation": "The MAT statement assigns a value to all elements of a matrix, copies one matrix to another, or tests for equivalent matrices.",
                "detail": "MAT matrix = expr\nMAT matrix2 = MAT matrix1\nIF MAT matrix1 = MAT matrix2 THEN ...",
                "snippet": "MAT ${1:array} = ${2:expression}"
            },
            {
                "key": "Mat",
                "icon": 3,
                "documentation": "The MAT() function creates an array for insertion into a data collection.",
                "detail": "MAT($array, $elements)",
                "snippet": "MAT(${1:array}, ${2:elements})"
            },
            {
                "key": "Matbuild",
                "icon": 14,
                "documentation": "The MATBUILD statement constructs a dynamic array from the elements of a matrix.",
                "detail": "MATBUILD var  FROM mat {, start.expr {, end.expr} {USING delimiter}",
                "snippet": "MATBUILD ${1:variable} FROM ${2:array}, ${3:startexpr}, ${4:endexpr}"
            },
            {
                "key": "Matchess",
                "icon": 3,
                "documentation": "The MATCHESS() function compares each element of a dynamic array with a pattern template, returning an equivalently structured dynamic array of True\/False values. Note the spelling of this function name with the trailing S to \"pluralise\" the name in common with other multivalue function names.",
                "detail": "MATCHESS(dyn.arr, pattern)",
                "snippet": "MATCHESS(${1:dynarr}, ${2:pattern})"
            },
            {
                "key": "Matchfield",
                "icon": 3,
                "documentation": "The MATCHFIELD() function extracts a portion of a string that matches a pattern element.",
                "detail": "MATCHFIELD(string, pattern, element)",
                "snippet": "MATCHFIELD(${1:string}, ${2:pattern}, ${3:element})"
            },
            {
                "key": "Matchfields",
                "icon": 3,
                "documentation": "The MATCHFIELDS() function performs the MATCHFIELD() operation on each element of a dynamic array.",
                "detail": "MATCHFIELDS(dyn.arr, pattern, element)",
                "snippet": "MATCHFIELDS(${1:dynarr}, ${2:pattern}, ${3:element})"
            },
            {
                "key": "Matparse",
                "icon": 14,
                "documentation": "The MATPARSE statement breaks a delimited string into component substrings, assigning each to an element of a matrix.",
                "detail": "MATPARSE mat FROM string {, delimiter} {SETTING var}\nMATPARSE mat FROM string {USING delimiter} {SETTING var}",
                "snippet": "MATPARSE ${1:mat} FROM ${2:str} SETTING ${3:var}"
            },
            {
                "key": "Matread",
                "icon": 14,
                "documentation": "The MATREAD statement reads a record from a file, assigning each field to an element of a matrix.",
                "detail": "MATREAD mat {ENCODING name} FROM file.var, record.id {ON ERROR statement(s)} {LOCKED statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "MATREAD ${1:mat} FROM ${2:filevar}, ${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Matreadcsv",
                "icon": 14,
                "documentation": "The MATREADCSV statement reads a CSV format line of text from a directory file record previously opened for sequential access and parses it into the elements of a dimensioned matrix.",
                "detail": "MATREADCSV matrix {ENCODING name} FROM file.var {DELIMITER delim} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "MATREADCSV ${1:mat} ENCODING ${2:name} FROM ${3:filevar} DELIMITER ${4:delim} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Matreadl",
                "icon": 14,
                "documentation": "The MATREADL statement is similar to MATREAD but sets a read lock on the record.",
                "detail": "MATREADL mat {ENCODING name} FROM file.var, record.id {ON ERROR statement(s)} {LOCKED statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "MATREADL ${1:mat} FROM ${2:filevar}, ${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Matreadu",
                "icon": 14,
                "documentation": "The MATREADU statement is similar to MATREAD but sets a update lock on the record.",
                "detail": "MATREADU mat {ENCODING name} FROM file.var, record.id {ON ERROR statement(s)} {LOCKED statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "MATREADU ${1:mat} FROM ${2:filevar}, ${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Matstr",
                "icon": 3,
                "documentation": "The MATSTR() function builds a dynamic array from a matrix.",
                "detail": "MATSTR(array)",
                "snippet": "MATSTR(${1:arr})"
            },
            {
                "key": "Matwrite",
                "icon": 14,
                "documentation": "The MATWRITE statement builds a record from successive elements of a matrix and writes this to a file.",
                "detail": "MATWRITE mat {ENCODING name} TO file.var, record.id {ON ERROR statement(s)}",
                "snippet": "MATWRITE ${1:mat} TO ${2:filevar}, ${3:recordkey}"
            },
            {
                "key": "Matwritecsv",
                "icon": 14,
                "documentation": "The MATWRITECSV statement builds a CSV from successive elements of a matrix and writes this to a file opened for sequential processing.",
                "detail": "MATWRITECSV mat {ENCODING name} TO file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "MATWRITECSV ${1:mat} ENCODING ${2:name} TO ${3:filevar} ON ERROR ${4:err_statements} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Matwriteu",
                "icon": 14,
                "documentation": "The MATWRITEU statement is similar to the MATWRITE statement but preserves any lock on the record being written.",
                "detail": "MATWRITEU mat {ENCODING name} TO file.var, record.id {ON ERROR statement(s)}",
                "snippet": "MATWRITEU ${1:mat} TO ${2:filevar}, ${3:recordkey}"
            },
            {
                "key": "Max",
                "icon": 3,
                "documentation": "The MAX() function returns the greater of two values.",
                "detail": "MAX(a, b)",
                "snippet": "MAX(${1:a}, ${2:b})"
            },
            {
                "key": "Maximum",
                "icon": 3,
                "documentation": "The MAXIMUM() function returns the greatest value in a dynamic array.",
                "detail": "MAXIMUM(dyn.array)",
                "snippet": "MAXIMUM(${1:DynArr})"
            },
            {
                "key": "Md5",
                "icon": 3,
                "documentation": "The MD5() function returns the 32 digit hexadecimal message digest value for a given string.",
                "detail": "MD5(string)",
                "snippet": "MD5(${1:str})"
            },
            {
                "key": "Mergelist",
                "icon": 3,
                "documentation": "The MERGELIST() function combines two field mark delimited sorted lists, returning the intersection, union or difference as a result list.",
                "detail": "MERGELIST(list1, list2, modes)",
                "snippet": "MERGELIST(${1:list1}, ${2:list2}, ${3:modes})"
            },
            {
                "key": "Min",
                "icon": 3,
                "documentation": "The MIN() function returns the lesser of two values.",
                "detail": "MIN(a, b)",
                "snippet": "MIN(${1:a}, ${2:b})"
            },
            {
                "key": "Minimum",
                "icon": 3,
                "documentation": "The MINIMUM() function returns the lowest value in a dynamic array.",
                "detail": "MINIMUM(dyn.array)",
                "snippet": "MINIMUM(${1:DynArr})"
            },
            {
                "key": "Mod",
                "icon": 3,
                "documentation": "The MOD() function returns the modulus value of one value divided by another.",
                "detail": "MOD(dividend, divisor)",
                "snippet": "MOD(${1:dividend}, ${2:divisor})"
            },
            {
                "key": "Mods",
                "icon": 3,
                "documentation": "The MODS() function is similar to MOD() but operates on successive elements of two dynamic arrays, returning a similarly structured dynamic array of results.",
                "detail": "MODS(dyn.array1, dyn.array2)",
                "snippet": "MODS(${1:array1}, ${2:array2})"
            },
            {
                "key": "Mouse",
                "icon": 14,
                "documentation": "The MOUSE statement enables or disables mouse input.",
                "detail": "MOUSE ON {SETTING var}\nMOUSE OFF {SETTING var}\nMOUSE expr {SETTING var}",
                "snippet": "MOUSE ${1:expr}"
            },
            {
                "key": "Mvdate",
                "icon": 3,
                "documentation": "The MVDATE() function returns the multivalue style date value (days since 31 December 1967) for a supplied epoch value using the currently selected time zone.",
                "detail": "MVDATE(epoch.value)",
                "snippet": "MVDATE(${1:epoch})"
            },
            {
                "key": "Mvdate.Time",
                "icon": 3,
                "documentation": "The MVDATE.TIME() function returns the multivalue style date and time values (days since 31 December 1967 and seconds since midnight) for a supplied epoch value using the currently selected time zone.",
                "detail": "MVDATE.TIME(epoch.value)",
                "snippet": "MVDATE.TIME(${1:epoch})"
            },
            {
                "key": "Mvepoch",
                "icon": 3,
                "documentation": "The MVEPOCH() function returns the epoch value corresponding to a multivalue style date and time combination (days since 31 December 1967 and seconds since midnight) using the currently selected time zone.",
                "detail": "MVEPOCH(time.string)\nMVEPOCH(date, time)",
                "snippet": "MVEPOCH($1)"
            },
            {
                "key": "Mvtime",
                "icon": 3,
                "documentation": "The MVTIME() function returns the multivalue style time value (seconds since midnight) for a supplied epoch value using the currently selected time zone.",
                "detail": "MVTIME(epoch.value)",
                "snippet": "MVTIME(${1:epoch})"
            },
            {
                "key": "Nap",
                "icon": 14,
                "documentation": "The NAP statement causes the program in which it is executed to pause for a given number of milliseconds.",
                "detail": "NAP time",
                "snippet": "NAP ${1:time}"
            },
            {
                "key": "Neg",
                "icon": 3,
                "documentation": "The NEG() function returns the arithmetic inverse of a value.",
                "detail": "NEG(expr)",
                "snippet": "NEG(${1:expression})"
            },
            {
                "key": "Negs",
                "icon": 3,
                "documentation": "The NEGS() function is similar to NEG() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results",
                "detail": "NEGS(dyn.arr)",
                "snippet": "NEGS(${1:DynArr})"
            },
            {
                "key": "Nes",
                "icon": 3,
                "documentation": "The NES() function processes two dynamic arrays, returning a similarly structured result array indicating whether corresponding elements are not equal.",
                "detail": "NES(expr1, expr2)",
                "snippet": "NES(${1:expr1}, ${2:expr2})"
            },
            {
                "key": "Next",
                "icon": 14,
                "documentation": "The NEXT statement terminates a FOR loop. Control is passed back to the FOR statement and the variable is incremented or decremented.",
                "detail": "NEXT variable",
                "snippet": "NEXT ${1:variable}"
            },
            {
                "key": "Nobuf",
                "icon": 14,
                "documentation": "The NOBUF statement turns off buffering for a record opened using OPENSEQ.",
                "detail": "NOBUF file.var {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "NOBUF ${1:file_variable} THEN \n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Not",
                "icon": 3,
                "documentation": "The NOT() function returns the logical inverse of its argument.",
                "detail": "NOT(expr)",
                "snippet": "NOT(${1:expression})"
            },
            {
                "key": "Nots",
                "icon": 3,
                "documentation": "The NOTS() function is similar to NOT() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "NOTS(dyn.arr)",
                "snippet": "NOTS(${1:DynArr})"
            },
            {
                "key": "Ns",
                "icon": 3,
                "documentation": "The NS() function returns a dynamic array containing ascending subvalue position numbers corresponding to a supplied dynamic array. ",
                "detail": "NS(string)",
                "snippet": "NS(${1:str})"
            },
            {
                "key": "Null",
                "icon": 14,
                "documentation": "The NULL statement performs no action.",
                "detail": "NULL",
                "snippet": "NULL"
            },
            {
                "key": "Num",
                "icon": 3,
                "documentation": "The NUM() function tests whether a string can be converted to a number.",
                "detail": "NUM(string)",
                "snippet": "NUM(${1:str})"
            },
            {
                "key": "Numeric",
                "icon": 3,
                "documentation": "The NUMERIC() function converts a value to Numeric form.",
                "detail": "NUMERIC($expr)",
                "snippet": "NUMERIC(${1:expr})"
            },
            {
                "key": "Nums",
                "icon": 3,
                "documentation": "The NUMS() function is similar to NUM() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "NUMS(dyn.arr)",
                "snippet": "NUMS(${1:DynArr})"
            },
            {
                "key": "Nv",
                "icon": 3,
                "documentation": "The NV() function returns a dynamic array containing ascending value position numbers corresponding to a supplied dynamic array. ",
                "detail": "NV(string {, repeat})",
                "snippet": "NV(${1:str}, ${2:repeat})"
            },
            {
                "key": "Object",
                "icon": 3,
                "documentation": "The OBJECT() function instantiates an object for object oriented programming.",
                "detail": "OBJECT(cat.name, {args...})\nOBJECT(obj.var)",
                "snippet": "OBJECT(${1:obj})"
            },
            {
                "key": "Objinfo",
                "icon": 3,
                "documentation": "The OBJINFO() function returns information about an object variable.",
                "detail": "OBJINFO(var, key)",
                "snippet": "OBJINFO(${1:var}, ${2:key})"
            },
            {
                "key": "Oconv",
                "icon": 3,
                "documentation": "The OCONV() function performs output conversion. Data is converted from its internal representation to the external form. This function is typically used to convert data for display or printing.",
                "detail": "OCONV(expr, conv.spec)",
                "snippet": "OCONV(${1:subject}, ${2:conversion})"
            },
            {
                "key": "Oconvs",
                "icon": 3,
                "documentation": "The OCONVS() function is identical to OCONV() except that it works on each element of a dynamic array, returning the result in a similarly delimited dynamic array.",
                "detail": "OCONVS(dyn.arr, conv.spec)",
                "snippet": "OCONVS(${1:DynArr}, ${2:conversion})"
            },
            {
                "key": "On Gosub",
                "icon": 3,
                "documentation": "The ON GOSUB statement enters one of a list of internal subroutines depending on the value of an expression.",
                "detail": "ON expr GOSUB label1{:}, label2{:}, label3{:}",
                "snippet": "ON ${1:expr} GOSUB ${2:labels}"
            },
            {
                "key": "On Goto",
                "icon": 3,
                "documentation": "The ON GOTO statement jumps to one of a list of labels depending on the value of an expression.",
                "detail": "ON expr GOTO label1{:}, label2{:}, label3{:}\nON expr GO {TO} label1{:}, label2{:}, label3{:}",
                "snippet": "ON ${1:expr} GOTO ${2:labels}"
            },
            {
                "key": "Open",
                "icon": 14,
                "documentation": "The OPEN statement opens a directory file or dynamic file, associating it with a file variable.",
                "detail": "OPEN {dict.expr,} filename.expr {options} TO file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "OPEN ${1:filename} TO ${2:filevar} ELSE ${3:else_statements}"
            },
            {
                "key": "Openpath",
                "icon": 14,
                "documentation": "The OPENPATH statement opens a directory file or dynamic file by pathname, associating it with a file variable.",
                "detail": "OPENPATH pathname {options} TO file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "OPENPATH ${1:pathname} TO ${2:filevar} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Openseq",
                "icon": 14,
                "documentation": "The OPENSEQ statement opens a record of a directory file, a device or a pipe for sequential access.",
                "detail": "OPENSEQ $Path $options TO $FileVar ON ERROR $err LOCKED $lock THEN\n\t$then_statements\nEND ELSE\n\t$else_statements\nEND",
                "snippet": "OPENSEQ ${1:Path} ${2:options} TO ${3:FileVar} ON ERROR ${4:err} LOCKED ${5:lock} THEN\n\t${6:then_statements}\nEND ELSE\n\t${7:else_statements}\nEND"
            },
            {
                "key": "Opentemp",
                "icon": 14,
                "documentation": "The OPENTEMP statement creates and opens a temporary dynamic file by pathname, associating it with a file variable.",
                "detail": "OPENTEMP {pathname} {options} TO file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "OPENTEMP ${1:Path} ${2:options} TO ${3:FileVar} ON ERROR ${4:err} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Open.Socket",
                "icon": 14,
                "documentation": "The OPEN.SOCKET() function opens a data socket for an outgoing connection.",
                "detail": "OPEN.SOCKET(addr, port, flags {, timeout})",
                "snippet": "OPEN.SOCKET(${1:addr}, ${2:port}, ${3:flags}, ${4:timeout})"
            },
            {
                "key": "Option",
                "icon": 3,
                "documentation": "The OPTION() function returns or changes the setting of an option flag.",
                "detail": "OPTION(optno)\nOPTION(optno, value)",
                "snippet": "OPTION(${1:optno}, ${2:value})"
            },
            {
                "key": "Ors",
                "icon": 3,
                "documentation": "The ORS() function performs a logical OR operation on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "ORS(expr1, expr2)",
                "snippet": "ORS(${1:expr1}, ${2:expr2})"
            },
            {
                "key": "Os.Error",
                "icon": 3,
                "documentation": "The OS.ERROR() function returns the error number associated with the last recorded operating system level error.",
                "detail": "OS.ERROR()",
                "snippet": "OS.ERROR()"
            },
            {
                "key": "Os.Execute",
                "icon": 14,
                "documentation": "The OS.EXECUTE statement executes an operating system command.",
                "detail": "OS.EXECUTE expr {CAPTURING var} {SILENT}",
                "snippet": "OS.EXECUTE ${1:expr} CAPTURING ${2:var} ${3:SILENT}"
            },
            {
                "key": "Osdelete",
                "icon": 14,
                "documentation": "The OSDELETE deletes an operating system file or directory by pathname.",
                "detail": "OSDELETE path",
                "snippet": "OSDELETE ${1:path}"
            },
            {
                "key": "Ospath",
                "icon": 3,
                "documentation": "The OSPATH() function performs actions on operating system files.",
                "detail": "OSPATH(path, key)\nOSPATH(path, key, qualifier)",
                "snippet": "OSPATH(${1:path}, ${2:key}, ${3:qualifier})"
            },
            {
                "key": "Osread",
                "icon": 14,
                "documentation": "The OSREAD statement reads an operating system file by pathname.",
                "detail": "OSREAD var FROM path {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "OSREAD ${1:var} FROM ${2:path} ON ERROR ${3:err} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Osrename",
                "icon": 3,
                "documentation": "The OSRENAME() function renames an operating system file or directory.",
                "detail": "OSRENAME(old.name, new.name)",
                "snippet": "OSRENAME(${1:oldname}, ${2:newname})"
            },
            {
                "key": "Oswrite",
                "icon": 14,
                "documentation": "The OSWRITE statement writes an operating system file by pathname.",
                "detail": "OSWRITE expr TO path {ON ERROR statement(s)}",
                "snippet": "OSWRITE ${1:expr} TO ${2:path} ON ERROR ${3:err}"
            },
            {
                "key": "Outerjoin",
                "icon": 3,
                "documentation": "The OUTERJOIN() function returns the record ids of records in a file where a field holds a specified value.",
                "detail": "OUTERJOIN({DICT} file.name, field.name, value)",
                "snippet": "OUTERJOIN(${1:filename}, ${2:field}, ${3:value})"
            },
            {
                "key": "Page",
                "icon": 14,
                "documentation": "The PAGE statement advances a print unit to a new page.",
                "detail": "PAGE {ON print.unit} {page.no}",
                "snippet": "PAGE $1"
            },
            {
                "key": "Parse",
                "icon": 3,
                "documentation": "The PARSE() function matches a string against a pattern, inserting a delimiter between each pattern element.",
                "detail": "PARSE(string, pattern, delimiter)",
                "snippet": "PARSE(${1:string_pattern}, ${2:delimiter})"
            },
            {
                "key": "Pause",
                "icon": 14,
                "documentation": "The PAUSE statement pauses execution until awoken by another process.",
                "detail": "PAUSE {timeout}",
                "snippet": "PAUSE ${1:timeout}"
            },
            {
                "key": "Pdump",
                "icon": 3,
                "documentation": "The PDUMP statement causes an immediate process dump of the process in which it is used.",
                "detail": "PDUMP",
                "snippet": "PDUMP"
            },
            {
                "key": "Perform",
                "icon": 14,
                "documentation": "The EXECUTE or PERFORM statement allows the currently executing program to pause and execute any other UNIX\/NT program, including another jBC program or a jBASE command.",
                "detail": "PERFORM expr {TRAPPING ABORTS}\n{CAPTURING var}\n{NO.TTY}\n{PASSLIST {src.list }}\n{RTNLIST tgt.list }\n{SILENT}\n{STACKLIST}\n{SETTING status.var} or {RETURNING status.var}",
                "snippet": "PERFORM ${1:expression}"
            },
            {
                "key": "Phantom",
                "icon": 3,
                "documentation": "The PHANTOM statement starts a phantom process from a QMBasic program without the overheads of using EXECUTE.",
                "detail": "PHANTOM command {options} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "PHANTOM ${1:cmd} ${2:options} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Pool.Idle",
                "icon": 14,
                "documentation": "The POOL.IDLE statement moves a phantom process into the idle state when using connection pooling.",
                "detail": "POOL.IDLE",
                "snippet": "POOL.IDLE"
            },
            {
                "key": "Precision",
                "icon": 14,
                "documentation": "The PRECISION statement sets the maximum number of decimal places to appear when converting numeric values to strings.",
                "detail": "PRECISION expr\nPRECISION INHERIT",
                "snippet": "PRECISION ${1:integer}"
            },
            {
                "key": "Print",
                "icon": 14,
                "documentation": "The PRINT statement outputs data to a print unit.",
                "detail": "PRINT {NO.ENCODING} {ON print.unit} {print.list}",
                "snippet": "PRINT ${1:expression}"
            },
            {
                "key": "Printcsv",
                "icon": 14,
                "documentation": "The PRINTCSV statement outputs CSV format data to a print unit.",
                "detail": "PRINTCSV {ON print.unit} var1, var2, ...",
                "snippet": "PRINTCSV ${1:vars}"
            },
            {
                "key": "Printer Close",
                "icon": 14,
                "documentation": "The PRINTER CLOSE statement closes one or all print units.",
                "detail": "PRINTER CLOSE {ON print.unit}",
                "snippet": "PRINTER CLOSE"
            },
            {
                "key": "Printer Display",
                "icon": 14,
                "documentation": "The PRINTER DISPLAY statement directs output sent to a print unit to the display.",
                "detail": "PRINTER DISPLAY {ON print.unit} {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "PRINTER DISPLAY $1 ON ERROR ${2:err} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Printer File",
                "icon": 14,
                "documentation": "The PRINTER FILE statement directs printer output to a named record in a directory file.",
                "detail": "PRINTER FILE {ON print.unit} file.name, record.name {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "PRINTER FILE $1 ${2:filename}, ${3:recordname} ON ERROR ${4:err} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Printer Name",
                "icon": 14,
                "documentation": "The PRINTER NAME statement associates a named printer device with a print unit.",
                "detail": "PRINTER NAME {ON print.unit} printer.name {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "PRINTER NAME $1 ${2:printername} ON ERROR ${3:err} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Printer Off",
                "icon": 14,
                "documentation": "The PRINTER ON and OFF statements determine whether output from PRINT statements to the default print unit (unit 0) is directed to the display or to the printer.",
                "detail": "PRINTER OFF",
                "snippet": "PRINTER OFF"
            },
            {
                "key": "Printer On",
                "icon": 14,
                "documentation": "The PRINTER ON and OFF statements determine whether output from PRINT statements to the default print unit (unit 0) is directed to the display or to the printer.",
                "detail": "PRINTER ON",
                "snippet": "PRINTER ON"
            },
            {
                "key": "Printer Reset",
                "icon": 14,
                "documentation": "The PRINTER RESET statement resets the default print unit and display output..",
                "detail": "PRINTER RESET",
                "snippet": "PRINTER RESET"
            },
            {
                "key": "Printerr",
                "icon": 14,
                "documentation": "The PRINTERR statement displays an error message which is removed from the screen when the next input is entered.",
                "detail": "PRINTERR $expression",
                "snippet": "PRINTERR ${1:expression}"
            },
            {
                "key": "Printer Settting",
                "icon": 14,
                "documentation": "The PRINTER SETTING statement sets a control parameter for a print unit. This statement is obsolete. The SETPU statement should be used in its place.",
                "detail": "PRINTER SETTING {ON print.unit} param, new.value",
                "snippet": "PRINTER SETTING ${1:param}, ${2:newvalue}"
            },
            {
                "key": "Printer.Settting",
                "icon": 3,
                "documentation": "The PRINTER.SETTING() function sets or retrieves a control parameter for a print unit. This function is obsolete. The SETPU statement or GETPU() function should be used in its place.",
                "detail": "PRINTER SETTING {ON print.unit} param, new.value",
                "snippet": "PRINTER SETTING ${1:param}, ${2:newvalue}"
            },
            {
                "key": "Private",
                "icon": 14,
                "documentation": "The PRIVATE statement defines private variables in a local subroutine or in a class module.",
                "detail": "PRIVATE var, mat(rows, cols)",
                "snippet": "PRIVATE ${1:var}, ${2:mat}(${3:rows}, ${4:cols})"
            },
            {
                "key": "Procread",
                "icon": 14,
                "documentation": "The PROCREAD statement reads data from the PROC primary input buffer.",
                "detail": "PROCREAD var {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "PROCREAD ${1:variable} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Procwrite",
                "icon": 14,
                "documentation": "The PROCWRITE statement writes data to the PROC primary input buffer.",
                "detail": "PROCWRITE expr",
                "snippet": "PROCWRITE ${1:expression}"
            },
            {
                "key": "Program",
                "icon": 14,
                "documentation": "The PROGRAM statement introduces a program.",
                "detail": "PROGRAM name",
                "snippet": "PROGRAM ${1:progname}"
            },
            {
                "key": "Prompt",
                "icon": 14,
                "documentation": "The PROMPT statement sets the character to be used as the prompt in INPUT statements.",
                "detail": "PROMPT expr",
                "snippet": "PROMPT ${1:expression}"
            },
            {
                "key": "Pterm",
                "icon": 3,
                "documentation": "The PTERM() function sets, clears or queries a terminal setting.",
                "detail": "PTERM(action, value)",
                "snippet": "PTERM(${1:action}, ${2:value})"
            },
            {
                "key": "Public",
                "icon": 14,
                "documentation": "The PUBLIC statement defines public property variables, subroutines and functions in a class module.",
                "detail": "PUBLIC var, mat(rows, cols), ...\nPUBLIC SUBROUTINE name{(arg1, arg2)} {VAR.ARGS} ...statements... END\nPUBLIC FUNCTION name{(arg1, arg2)} {VAR.ARGS} ...statements... END",
                "snippet": "PUBLIC $1"
            },
            {
                "key": "Put",
                "icon": 14,
                "documentation": "Synonym for PUBLIC ",
                "detail": "PUT var, mat(rows, cols), ...\nPUT SUBROUTINE name{(arg1, arg2)} {VAR.ARGS} ...statements... END\nPUT FUNCTION name{(arg1, arg2)} {VAR.ARGS} ...statements... END",
                "snippet": "PUT ${1:var}, mat(${2:rows}, ${3:cols})"
            },
            {
                "key": "Pwr",
                "icon": 3,
                "documentation": "The PWR() function returns the value of a number raised to a given power.",
                "detail": "PWR(expr, pwr.expr)",
                "snippet": "PWR(${1:expression1}, ${2:pwrexpr})"
            },
            {
                "key": "Quote",
                "icon": 3,
                "documentation": "The QUOTE() function returns a copy of its argument string enclosed in double quotes. The DQUOTE() synonym is identical.",
                "detail": "QUOTE(expr)",
                "snippet": "QUOTE(${1:expression})"
            },
            {
                "key": "Quotes",
                "icon": 3,
                "documentation": "The QUOTE() function returns a copy of its argument string enclosed in double quotes. The DQUOTE() synonym is identical. The QUOTES() and DQUOTES() functions are similar but operate on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "QUOTES(expr)",
                "snippet": "QUOTES(${1:expression})"
            },
            {
                "key": "Raise",
                "icon": 3,
                "documentation": "The RAISE() function converts mark characters in a string to the next higher level mark.",
                "detail": "RAISE(string)",
                "snippet": "RAISE(${1:str})"
            },
            {
                "key": "Randomize",
                "icon": 14,
                "documentation": "The RANDOMIZE statement initialises the random number generator. See also RND()",
                "detail": "RANDOMIZE expr",
                "snippet": "RANDOMIZE ${1:expression}"
            },
            {
                "key": "Rdiv",
                "icon": 3,
                "documentation": "The RDIV() function returns the rounded integer result of dividing two values",
                "detail": "RDIV(dividend, divisor)",
                "snippet": "RDIV(${1:dividend}, ${2:divisor})"
            },
            {
                "key": "Read",
                "icon": 14,
                "documentation": "The READ statement reads a record from a previously opened file.",
                "detail": "READ var {ENCODING name} FROM file.var, record.id {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READ ${1:var} FROM ${2:filevar},${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Read.Socket",
                "icon": 3,
                "documentation": "The READ.SOCKET() function reads data from a socket.",
                "detail": "READ.SOCKET(skt, max.len, flags, timeout)",
                "snippet": "READ.SOCKET(${1:skt}, ${2:maxlen}, ${3:flags}, ${4:timeout})"
            },
            {
                "key": "Readblk",
                "icon": 14,
                "documentation": "The READBLK statement reads a given number of bytes from the current file position in a record previously opened using OPENSEQ.",
                "detail": "READBLK var {ENCODING name} FROM file.var, bytes {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READBLK ${1:var} ${2:ENCODING} FROM ${3:filevariable}, ${4:blocksize} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Readcsv",
                "icon": 14,
                "documentation": "The READCSV statement reads a CSV format line of text from a directory file record previously opened for sequential access and parses it into multiple variables.",
                "detail": "READCSV {ENCODING name} FROM file.var {DELIMITER delim} TO var1, var2,... {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READCSV ${1:ENCODING} FROM ${2:filevar} DELIMITER ${3:delim} TO ${4:vars} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Readl",
                "icon": 14,
                "documentation": "The READL statement reads a record from a previously opened file, setting a read lock.",
                "detail": "READL var {ENCODING name} FROM file.var, record.id {ON ERROR statement(s)} {LOCKED statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READL ${1:var} FROM ${2:filevar},${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Readlist",
                "icon": 14,
                "documentation": "The READLIST statement reads a select list into a dynamic array.",
                "detail": "READLIST var {FROM list.no} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READLIST ${1:var} FROM ${2:listnum} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "ReadNext",
                "icon": 14,
                "documentation": "The READNEXT statement returns the next item from an active select list.",
                "detail": "READNEXT var {, val.pos {, subval.pos}} {FROM list.no} {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READNEXT ${1:var} FROM ${2:list}"
            },
            {
                "key": "Readseq",
                "icon": 14,
                "documentation": "The READSEQ statement reads the next field (line of text)from a directory file record previously opened for sequential access.",
                "detail": "READSEQ var {ENCODING name} FROM file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READSEQ ${1:var} ${2:ENCODING} FROM ${3:filevar} ON ERROR ${4:err_statements} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Readu",
                "icon": 14,
                "documentation": "The READU statement reads a record from a previously opened file, setting an update lock.",
                "detail": "READU var {ENCODING name} FROM file.var, record.id {ON ERROR statement(s)} {LOCKED statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READU ${1:var} FROM ${2:filevar},${3:recordkey} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Readv",
                "icon": 14,
                "documentation": "The READV statement reads a specific field from a record of a previously opened file.",
                "detail": "READV var {ENCODING name} FROM file.var, record.id, field.expr {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READV ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Readvl",
                "icon": 14,
                "documentation": "The READVL statement reads a specific field from a record of a previously opened file, setting a read lock.",
                "detail": "READVL var {ENCODING name} FROM file.var, record.id, field.expr {ON ERROR statement(s)} {LOCKED statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READVL ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Readvu",
                "icon": 14,
                "documentation": "The READVU statement is similar to the READVL statement but sets an update lock.",
                "detail": "READVU var {ENCODING name} FROM file.var, record.id, field.expr {ON ERROR statement(s)} {LOCKED statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "READVU ${1:var} FROM ${2:filevar},${3:recordkey},${4:attr} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Recordlocked",
                "icon": 3,
                "documentation": "The RECORDLOCKED() function indicates whether a given record is locked.",
                "detail": "RECORDLOCKED(file.var, record.id)",
                "snippet": "RECORDLOCKED(${1:filevar}, ${2:recordkey})"
            },
            {
                "key": "Recordlockl",
                "icon": 14,
                "documentation": "The RECORDLOCKL statement sets a read lock on a record.",
                "detail": "RECORDLOCKL file.var, record.id {ON ERROR statement(s)} {LOCKED statement(s)}",
                "snippet": "RECORDLOCKL ${1:filevar}, ${2:recordkey} ON ERROR ${3:err_statements} LOCKED ${4:lock_statements}"
            },
            {
                "key": "Recordlocku",
                "icon": 3,
                "documentation": "The RECORDLOCKU statement is similar to the RECORDLOCKL statment but sets an update lock.",
                "detail": "RECORDLOCKU file.var, record.id {ON ERROR statement(s)} {LOCKED statement(s)}",
                "snippet": "RECORDLOCKU ${1:filevar}, ${2:recordkey} ON ERROR ${3:err_statements} LOCKED ${4:lock_statements}"
            },
            {
                "key": "Redim",
                "icon": 14,
                "documentation": "The REDIM statement is identical to the DIM statement except where the matrix is a subroutine argument.",
                "detail": "REDIM mat(rows {, cols})",
                "snippet": "DIM ${1:variable}(${2:numbers})"
            },
            {
                "key": "Redimension",
                "icon": 14,
                "documentation": "The REDIMENSION statement is identical to the DIMENSION statement except where the matrix is a subroutine argument.",
                "detail": "REDIMENSION mat(rows {, cols})",
                "snippet": "DIM ${1:variable}(${2:numbers})"
            },
            {
                "key": "Regex",
                "icon": 3,
                "documentation": "The REGEX() function tests whether a string matches a regular expression. This function is not available on Windows systems.",
                "detail": "REGEX(str, regex{, modes})",
                "snippet": "REGEX(${1:str}, ${2:regex}, ${3:modes})"
            },
            {
                "key": "Release",
                "icon": 14,
                "documentation": "The RELEASE statement releases read, update or file locks.",
                "detail": "RELEASE {file.var{, record.id}} {ON ERROR statement(s)}",
                "snippet": "RELEASE ${1:filevar}, ${2:expression} ON ERROR ${3:err_statements}"
            },
            {
                "key": "Rem",
                "icon": 3,
                "documentation": "The REM() function returns the remainder when one value is divided by another.",
                "detail": "REM(dividend, divisor)",
                "snippet": "REM(${1:dividend}, ${2:divisor})"
            },
            {
                "key": "Remark",
                "icon": 14,
                "documentation": "The REMARK statement, which may be abbreviated to REM, enters comment text into a program.",
                "detail": "REMARK text",
                "snippet": "REMARK ${1:text}"
            },
            {
                "key": "Remove",
                "icon": 3,
                "documentation": "The REMOVE function removes characters from a dynamic array up to the next mark character.",
                "detail": "REMOVE(dyn.array, var)",
                "snippet": "REMOVE(${1:dynarray}, ${2:var})"
            },
            {
                "key": "Remove",
                "icon": 14,
                "documentation": "The REMOVE statement removes characters from a dynamic array up to the next mark character.",
                "detail": "REMOVE string FROM dyn.array SETTING var",
                "snippet": "REMOVE ${1:string} FROM ${2:dynarray} SETTING ${3:var}"
            },
            {
                "key": "Removef",
                "icon": 3,
                "documentation": "The REMOVEF() function extracts data from a delimited character string.",
                "detail": "REMOVEF(string{, delimiter{, count}})",
                "snippet": "REMOVEF(${1:str}, ${2:delimiter}, ${3:count})"
            },
            {
                "key": "Remove.Break.Handler",
                "icon": 14,
                "documentation": "The REMOVE.BREAK.HANDLER statement allows a program to remove a handler subroutine established using SET.BREAK.HANDLER.",
                "detail": "REMOVE.BREAK.HANDLER",
                "snippet": "REMOVE.BREAK.HANDLER"
            },
            {
                "key": "Repeat",
                "icon": 14,
                "documentation": "REPEAT causes the loop to start again with the first statement following the LOOP statement.",
                "detail": "REPEAT",
                "snippet": "REPEAT"
            },
            {
                "key": "Replace",
                "icon": 3,
                "documentation": "The REPLACE() function replaces a field, value or subvalue of a dynamic array, returning the result.",
                "detail": "REPLACE(dyn.array, field {, value {, subvalue}} , string)",
                "snippet": "REPLACE(${1:var}, ${2:attr}, ${3:value}, ${4:subvalue}; ${5:replace})"
            },
            {
                "key": "Restore.Screen",
                "icon": 14,
                "documentation": "The RESTORE.SCREEN statement restores a rectangular portion of the display screen image previously saved using SAVE.SCREEN().",
                "detail": "RESTORE.SCREEN image, restore.state",
                "snippet": "RESTORE.SCREEN ${1:image}, ${2:restorestate}"
            },
            {
                "key": "Return",
                "icon": 14,
                "documentation": "The RETURN statement returns from an internal subroutine entered by GOSUB or an external subroutine entered by CALL.",
                "detail": "RETURN {expr}\nRETURN TO label{:}\nRETURN FROM PROGRAM",
                "snippet": "RETURN $1"
            },
            {
                "key": "Reuse",
                "icon": 3,
                "documentation": "The REUSE() function determines how arithmetic operators applied to numeric arrays handle unequal numbers of fields, values or subvalues. sIt can also be used with arguments to the multivalue functions.",
                "detail": "REUSE(dyn.array)",
                "snippet": "REUSE(${1:dynarr})"
            },
            {
                "key": "Right",
                "icon": 3,
                "documentation": "The RIGHT() function returns the trailing part of a string.",
                "detail": "RIGHT(string, len)",
                "snippet": "RIGHT(${1:str}, ${2:length})"
            },
            {
                "key": "Rmvd",
                "icon": 3,
                "documentation": "The RMVD() function extracts characters from a dynamic array up to the next delimiter character. It is closely related to REMOVE().",
                "detail": "RMVD(dyn.array, var)",
                "snippet": "RMVD(${1:dynarr}, ${2:var})"
            },
            {
                "key": "Rnd",
                "icon": 3,
                "documentation": "The RND() function returns a random number.",
                "detail": "RND(expr)",
                "snippet": "RND(${1:expr})"
            },
            {
                "key": "Rounddown",
                "icon": 3,
                "documentation": "The ROUNDDOWN() function returns an integer value rounded towards zero in a given increment.",
                "detail": "ROUNDDOWN(value, increment)",
                "snippet": "ROUNDDOWN(${1:value}, ${2:increment})"
            },
            {
                "key": "Roundup",
                "icon": 3,
                "documentation": "The ROUNDUP() function returns an integer value rounded away from zero in a given increment.",
                "detail": "ROUNDUP(value, increment)",
                "snippet": "ROUNDUP(${1:value}, ${2:increment})"
            },
            {
                "key": "Rollback",
                "icon": 14,
                "documentation": "The ROLLBACK statement discards any cached updates and continues at the statement following the END TRANSACTION. A roll-back is implied if the program executes the END TRANSACTION directly.",
                "detail": "ROLLBACK",
                "snippet": "ROLLBACK"
            },
            {
                "key": "Rqm",
                "icon": 14,
                "documentation": "The RQM may be used in place of SLEEP.",
                "detail": "RQM {time}",
                "snippet": "RQM ${1:seconds}"
            },
            {
                "key": "Rtrans",
                "icon": 3,
                "documentation": "The RTRANS() function is similar tothe TRANS() function but has a slight difference for closer compatibility with some other environments. The RTRANS() function does not lower the mark characters. This makes it impossible to distinguish between the results of retrieving a multivalued field from a single record and retrieving a single valued field from multiple records.",
                "detail": "RTRANS({DICT} file.name, record.id, field, action)",
                "snippet": "RTRANS(${1:filename}, ${2:key}, ${3:field}, ${4:actioncode})"
            },
            {
                "key": "Sadd",
                "icon": 3,
                "documentation": "The SADD() function performs addition on numeric strings of any length.",
                "detail": "SADD(a, b)",
                "snippet": "SADD($1, $2)"
            },
            {
                "key": "Save.Screen",
                "icon": 3,
                "documentation": "The SAVE.SCREEN() function saves a rectangular portion of the display screen image.",
                "detail": "SAVE.SCREEN(col, line, width, height)",
                "snippet": "SAVE.SCREEN(${1:col}, ${2:line}, ${3:width}, ${4:height})"
            },
            {
                "key": "Savelist",
                "icon": 14,
                "documentation": "The SAVELIST statement saves an active select list to the $SAVEDLISTS file.",
                "detail": "SAVELIST name {FROM list} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "SAVELIST ${1:name} FROM ${2:list} THEN\n\t${3:then_statements}\nEND ELSE\n\t${4:else_statements}\nEND"
            },
            {
                "key": "Scmp",
                "icon": 3,
                "documentation": "The SCMP() function performs comparison of two integer numeric strings of any length.",
                "detail": "SCMP(a, b)",
                "snippet": "SCMP($1, $2)"
            },
            {
                "key": "Sdiv",
                "icon": 3,
                "documentation": "The SDIV function performs division on numeric strings of any length.",
                "detail": "SDIV(a, b {, r{, dp}})",
                "snippet": "SDIV($1, $2, $3, $4)"
            },
            {
                "key": "Seek",
                "icon": 14,
                "documentation": "The SEEK statement sets the current read \/ write position in a directory file record previously opened for sequential access.",
                "detail": "SEEK file.var {, offset{, relto }} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "SEEK ${1:filevar}, ${2:offset}, ${3:relto} THEN\n\t${4:then_statements}\nEND ELSE\n\t${5:else_statements}\nEND"
            },
            {
                "key": "Select",
                "icon": 14,
                "documentation": "The SELECT statement creates a select list containing all record keys from a file.",
                "detail": "SELECT var {TO list.no} {ON ERROR statement(s)}\nSELECTN var {TO list.no} {ON ERROR statement(s)}\nSELECTV var {TO list.var} {ON ERROR statement(s)}",
                "snippet": "SELECT ${1:variable1} TO ${2:list} ON ERROR ${3:err_statements}"
            },
            {
                "key": "Select.Socket",
                "icon": 3,
                "documentation": "The SELECT.SOCKET() function monitors multiple sockets for events.",
                "detail": "SELECT.SOCKET(skt.array, timeout)",
                "snippet": "SELECT.SOCKET(${1:sktarr}, ${2:timeout})"
            },
            {
                "key": "Selecte",
                "icon": 14,
                "documentation": "The SELECTE statement transfers select list 0 to a select list variable.",
                "detail": "SELECTE TO list.var",
                "snippet": "SELECTE TO ${1:listname}"
            },
            {
                "key": "Selectindex",
                "icon": 14,
                "documentation": "The SELECTINDEX statement creates a numbered select list from an alternate key index entry.",
                "detail": "SELECTINDEX index.name {, value} FROM file.var {TO list.no}",
                "snippet": "SELECTINDEX ${1:indexname}, ${2:val} FROM ${3:filevar} TO ${4:listno}"
            },
            {
                "key": "Selectinfo",
                "icon": 3,
                "documentation": "The SELECTINFO() function returns information about a select list.",
                "detail": "SELECTINFO(list.no, key)\nSELECTINFO(var, key)",
                "snippet": "SELECTINFO(${1:var}, ${2:key})"
            },
            {
                "key": "Selectindexv",
                "icon": 14,
                "documentation": "The SELECTINDEXV statement is similar to the SELECTINDEX statement but creates a select list variable.",
                "detail": "SELECTINDEXV index.name {, value} FROM file.var TO list.var",
                "snippet": "SELECTINDEXV ${1:indexname}, ${2:val} FROM ${3:filevar} TO ${4:listno}"
            },
            {
                "key": "Selectleft",
                "icon": 14,
                "documentation": "The SELECTLEFT statement creates a numbered select list from the entry in an alternate key index to the left of the last entry processed. ",
                "detail": "SELECTLEFT index.name FROM file.var {SETTING key} {TO list.no}",
                "snippet": "SELECTLEFT ${1:indexname} FROM ${2:filevar} SETTING ${3:key} TO ${4:listno}"
            },
            {
                "key": "Selectleftv",
                "icon": 14,
                "documentation": "The SELECTLEFTV is similar to the SELECTLEFT statement but create a select list variable. ",
                "detail": "SELECTLEFTV index.name FROM file.var {SETTING key} TO list.var",
                "snippet": "SELECTLEFTV ${1:indexname} FROM ${2:filevar} SETTING ${3:key} TO ${4:listno}"
            },
            {
                "key": "Selectn",
                "icon": 14,
                "documentation": "The SELECT statement creates a select list containing all record keys from a file.",
                "detail": "SELECTN $variable1 TO $list ON ERROR $err_statements",
                "snippet": "SELECTN ${1:variable1} TO ${2:list} ON ERROR ${3:err_statements}"
            },
            {
                "key": "Selectright",
                "icon": 14,
                "documentation": "The SELECTRIGHT statement creates a numbered select list from the entry in an alternate key index to the right of the last entry processed. ",
                "detail": "SELECTRIGHT index.name FROM file.var {SETTING key} {TO list.no}",
                "snippet": "SELECTRIGHT ${1:indexname} FROM ${2:filevar} SETTING ${3:key} TO ${4:listno}"
            },
            {
                "key": "Selectrightv",
                "icon": 14,
                "documentation": "The SELECTRIGHTV is similar to the SELECTRIGHT statement but create a select list variable. ",
                "detail": "SELECTRIGHTV index.name FROM file.var {SETTING key} TO list.var",
                "snippet": "SELECTRIGHTV ${1:indexname} FROM ${2:filevar} SETTING ${3:key} TO ${4:listno}"
            },
            {
                "key": "Selectv",
                "icon": 14,
                "documentation": "The SELECT statement creates a select list containing all record keys from a file.",
                "detail": "SELECTV $variable1 TO $list ON ERROR $err_statements",
                "snippet": "SELECTV ${1:variable1} TO ${2:list} ON ERROR ${3:err_statements}"
            },
            {
                "key": "Sentence",
                "icon": 3,
                "documentation": "The SENTENCE() function returns command line that started the current program. The SENTENCE() function is an alternative to the use of the @SENTENCE variable.",
                "detail": "SENTENCE()",
                "snippet": "SENTENCE()"
            },
            {
                "key": "Seq",
                "icon": 3,
                "documentation": "The SEQ() function returns the character set position value of a character. It is the inverse of the CHAR() or ECHAR() functions.",
                "detail": "SEQ(char)",
                "snippet": "SEQ(${1:char})"
            },
            {
                "key": "Seqs",
                "icon": 3,
                "documentation": "The SEQS() function takes a dynamic array of char and returns a similarly structured dynamic array in which each element contains the ASCII value of the character in the corresponding element of char.",
                "detail": "SEQS(dyn.arr)",
                "snippet": "SEQS(${1:DynArr})"
            },
            {
                "key": "Server.Addr",
                "icon": 3,
                "documentation": "The SERVER.ADDR() function returns the IP address for a given server name.",
                "detail": "SERVER.ADDR(server.name)",
                "snippet": "SERVER.ADDR(${1:servername})"
            },
            {
                "key": "Server.Window",
                "icon": 3,
                "documentation": "The SERVER.WINDOW() function, available only in Windows QMConsole sessions, opens an asynchronous application window.",
                "detail": "SERVER.WINDOW(program {, parameters})",
                "snippet": "SERVER.WINDOW(${1:prog}, ${2:params})"
            },
            {
                "key": "Set.Arg",
                "icon": 14,
                "documentation": "The SET.ARG statement updates a subroutine argument value based on its position in the argument list. It is intended for use with subroutines declared with the VAR.ARGS option.",
                "detail": "SET.ARG n, value",
                "snippet": "SET.ARG ${1:n}, ${2:value}"
            },
            {
                "key": "Set.Break.Handler",
                "icon": 14,
                "documentation": "The SET.BREAK.HANDLER statement allows a program to establish a handler subroutine that will be called if the user presses the break key.",
                "detail": "SET.BREAK.HANDLER name",
                "snippet": "SET.BREAK.HANDLER ${1:name}"
            },
            {
                "key": "Set.Ecs.Map",
                "icon": 3,
                "documentation": "The SET.ECS.MAP() function selects a given ECS character map.",
                "detail": "SET.ECS.MAP(name)",
                "snippet": "SET.ECS.MAP(${1:name})"
            },
            {
                "key": "Set.Exit.Status",
                "icon": 14,
                "documentation": "The SET.EXIT.STATUS statement sets the final exit status returned by QM to the operating system.",
                "detail": "SET.EXIT.STATUS value",
                "snippet": "SET.EXIT.STATUS ${1:value}"
            },
            {
                "key": "Set.Port.Params",
                "icon": 3,
                "documentation": "The SET.PORT.PARAMS() function sets the communications parameters for a serial port.",
                "detail": "SET.PORT.PARAMS(fvar, params)",
                "snippet": "SET.PORT.PARAMS(${1:fvar}, ${2:params})"
            },
            {
                "key": "Set.Socket.Mode",
                "icon": 3,
                "documentation": "The SET.SOCKET.MODE() function sets parameters for an open socket.",
                "detail": "SET.SOCKET.MODE(skt, key, value)",
                "snippet": "SET.SOCKET.MODE(${1:skt}, ${2:key}, ${3:value})"
            },
            {
                "key": "Set.Status",
                "icon": 14,
                "documentation": "The SET.STATUS statement sets a value for return by the STATUS() function.",
                "detail": "SET.STATUS expr",
                "snippet": "SET.STATUS ${1:expr}"
            },
            {
                "key": "Set.Timezone",
                "icon": 14,
                "documentation": "The SET.TIMEZONE statement sets the time zone for use by the epoch conversion code.",
                "detail": "SET.TIMEZONE zone",
                "snippet": "SET.TIMEZONE ${1:zone}"
            },
            {
                "key": "Setleft",
                "icon": 14,
                "documentation": "The SETLEFT statement sets the scanning position of an alternate key index at the extreme left of the data.",
                "detail": "SETLEFT index.name FROM file.var",
                "snippet": "SETLEFT ${1:indexname} FROM ${2:filevar}"
            },
            {
                "key": "Setnls",
                "icon": 14,
                "documentation": "The SETNLS statement sets the value of a national language support parameter.",
                "detail": "SETNLS key,  value",
                "snippet": "SETNLS ${1:key}, ${2:value}"
            },
            {
                "key": "Setpu",
                "icon": 14,
                "documentation": "The SETPU statement sets the characteristics of a print unit.",
                "detail": "SETPU key, unit, value",
                "snippet": "SETPU ${1:key}, ${2:unit}, ${3:value}"
            },
            {
                "key": "Setrem",
                "icon": 14,
                "documentation": "The SETREM statement sets the remove pointer of a string.",
                "detail": "SETREM offset ON string",
                "snippet": "SETREM ${1:offset} ON ${2:str}"
            },
            {
                "key": "Setright",
                "icon": 14,
                "documentation": "The SETRIGHT statement sets the scanning position of an alternate key index at the extreme right of the data.",
                "detail": "SETRIGHT index.name FROM file.var",
                "snippet": "SETRIGHT ${1:indexname} FROM ${2:filevar}"
            },
            {
                "key": "Shared",
                "icon": 14,
                "documentation": "The SHARED statement declares persistent variables to be shared across all instances of a QMBasic class module.",
                "detail": "SHARED {PRIVATE | PUBLIC} {var1 {,var2...}",
                "snippet": "SHARED ${1:PRIVATE_PUBLIC} ${2:vars}"
            },
            {
                "key": "Shift",
                "icon": 3,
                "documentation": "The SHIFT() function performs a logical bit-shift operation on an integer value.",
                "detail": "SHIFT(value, shift.len)",
                "snippet": "SHIFT(${1:value}, ${2:shiftlen})"
            },
            {
                "key": "Signal",
                "icon": 3,
                "documentation": "The SIGNAL() function raises a cross-process application signal.",
                "detail": "SIGNAL(user.no)",
                "snippet": "SIGNAL(${1:userno})"
            },
            {
                "key": "Sin",
                "icon": 3,
                "documentation": "The SIN() function returns the sine of a value.",
                "detail": "SIN(expr)",
                "snippet": "SIN(${1:expression})"
            },
            {
                "key": "Sleep",
                "icon": 3,
                "documentation": "The SLEEP statement causes the program in which it is executed to pause for a given number of seconds or until a specific time. The synonym RQM may be used in place of SLEEP.",
                "detail": "SLEEP {time}",
                "snippet": "SLEEP ${1:seconds}"
            },
            {
                "key": "Smul",
                "icon": 3,
                "documentation": "The SMUL() function perform multiplication on numeric strings of any length.",
                "detail": "SMUL(a, b)",
                "snippet": "SMUL($1, $2)"
            },
            {
                "key": "Socket.Info",
                "icon": 3,
                "documentation": "The SOCKET.INFO() function returns information about an open socket.",
                "detail": "SOCKET.INFO(skt, key)",
                "snippet": "SOCKET.INFO(${1:skt}, ${2:key})"
            },
            {
                "key": "Sort",
                "icon": 3,
                "documentation": "The SORT() function creates a sort variable.",
                "detail": "SORT(key.count, {MAT} flags)",
                "snippet": "SORT(${1:keycnt})"
            },
            {
                "key": "Sortadd",
                "icon": 3,
                "documentation": "The SORTADD statement adds data to the sort system.",
                "detail": "SORTADD sortvar, {MAT} keys {, data}",
                "snippet": "SORTADD ${1:sortvar}, ${2:keys}, ${3:data}"
            },
            {
                "key": "Sortclear",
                "icon": 3,
                "documentation": "The SORTCLEAR statement terminates a sort session, discarding all data.",
                "detail": "SORTCLEAR sortvar",
                "snippet": "SORTCLEAR ${1:sortvar}"
            },
            {
                "key": "Sortdata",
                "icon": 3,
                "documentation": "The SORTDATA() function returns the data elements from a sort.",
                "detail": "SORTDATA(sort.var, {max.items})",
                "snippet": "SORTDATA(${1:sortvar}, ${2:maxitems})"
            },
            {
                "key": "Sortnext",
                "icon": 3,
                "documentation": "The SORTNEXT() function retrieves the next entry from a sort.",
                "detail": "SORTNEXT(sort.var, {{MAT} keys})",
                "snippet": "SORTNEXT(${1:sortvar}, ${2:keys})"
            },
            {
                "key": "Sort.Compare",
                "icon": 3,
                "documentation": "The SORT.COMPARE() function compares two items using a specified set of comparison rules.",
                "detail": "SORT.COMPARE(string1, string2, mode {, no.case})",
                "snippet": "SORT.COMPARE(${1:str1}, ${2:str2}, ${3:mode}, ${4:nocase})"
            },
            {
                "key": "Soundex",
                "icon": 3,
                "documentation": "The SOUNDEX() function returns a four character string determined by the phonetic content of a string.",
                "detail": "SOUNDEX(string)",
                "snippet": "SOUNDEX(${1:str})"
            },
            {
                "key": "Soundexs",
                "icon": 3,
                "documentation": "The SOUNDEXS() function is similar to SOUNDEX() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "SOUNDEXS(dyn.arr)",
                "snippet": "SOUNDEXS(${1:dynarr})"
            },
            {
                "key": "Space",
                "icon": 3,
                "documentation": "The SPACE() function returns a string consisting of a given number of spaces.",
                "detail": "SPACE(count)",
                "snippet": "SPACE(${1:cnt})"
            },
            {
                "key": "Spaces",
                "icon": 3,
                "documentation": "The SPACES() function is similar to SPACE() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "SPACES(dyn.arr)",
                "snippet": "SPACES(${1:DynArr})"
            },
            {
                "key": "Splice",
                "icon": 3,
                "documentation": "The SPLICE() function concatenates corresponding elements of a dynamic array, inserting a string between each pair of items.",
                "detail": "SPLICE(array1, string, array2)",
                "snippet": "SPLICE(${1:array1}, ${2:str}, ${3:array2})"
            },
            {
                "key": "Sqrt",
                "icon": 3,
                "documentation": "The SQRT() function returns the square root of a value.",
                "detail": "SQRT(expr)",
                "snippet": "SQRT(${1:expression})"
            },
            {
                "key": "Squote",
                "icon": 3,
                "documentation": "The SQUOTE() function returns a copy of its argument string enclosed in single quotes.",
                "detail": "SQUOTE(expr)",
                "snippet": "SQUOTE(${1:expression})"
            },
            {
                "key": "Squotes",
                "icon": 3,
                "documentation": "The SQUOTES() function is similar to the SQUOTE() function but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "SQUOTES(dyn.arr)",
                "snippet": "SQUOTES(${1:dynarr})"
            },
            {
                "key": "Sselect",
                "icon": 14,
                "documentation": "The SSELECT statement creates a select list containing all record keys from a file sorted into order.",
                "detail": "SSELECT file.var {TO list.no} {modes} {ON ERROR statement(s)}",
                "snippet": "SSELECT ${1:filevar} TO ${2:list} ${3:modes} ON ERROR ${4:statements}"
            },
            {
                "key": "Sselectn",
                "icon": 14,
                "documentation": "The SSELECT statement creates a numbered select list containing all record keys from a file sorted into order.",
                "detail": "SSELECTN file.var {TO list.no} {modes} {ON ERROR statement(s)}",
                "snippet": "SSELECTN ${1:filevar} TO ${2:list} ${3:modes} ON ERROR ${4:statements}"
            },
            {
                "key": "Sselectv",
                "icon": 14,
                "documentation": "The SSELECTV statement constructs the list in the same way as SSELECT but stores it in a select list variable which can be processed by a subsequent use of READNEXT. If the TO clause is omitted, the default select list (numbered list 0) is used.",
                "detail": "SSELECTV file.var {TO list.var} {modes} {ON ERROR statement(s)}",
                "snippet": "SSELECTV ${1:filevar} TO ${2:list} ${3:modes} ON ERROR ${4:statements}"
            },
            {
                "key": "Ssub",
                "icon": 3,
                "documentation": "The SSUB() functions perform subtraction on numeric strings of any length.",
                "detail": "SSUB(a, b)",
                "snippet": "SSUB($1, $2)"
            },
            {
                "key": "Status",
                "icon": 3,
                "documentation": "The STATUS() function returns information following execution of certain other statements. In many cases, this information gives details of an error condition.",
                "detail": "STATUS()",
                "snippet": "STATUS()"
            },
            {
                "key": "Status",
                "icon": 14,
                "documentation": "The STATUS statement returns a dynamic array containing a variety of information about an open file.",
                "detail": "STATUS var FROM file.var THEN statement(s) ELSE statement(s)",
                "snippet": "STATUS ${1:var} FROM ${2:filevar} THEN ${3:then_statement} ELSE ${4:else_statement}"
            },
            {
                "key": "Stop",
                "icon": 3,
                "documentation": "The STOP statement terminates the current program.",
                "detail": "STOP {message}",
                "snippet": "STOP $1"
            },
            {
                "key": "Stope",
                "icon": 3,
                "documentation": "The STOPE statement provides STOP compatibility with other multivalue database products.",
                "detail": "STOPE {message}",
                "snippet": "STOPE ${1:message}"
            },
            {
                "key": "Stopm",
                "icon": 3,
                "documentation": "The STOPM statement provides STOP compatibility with other multivalue database products.",
                "detail": "STOPM {message}",
                "snippet": "STOPM ${1:message}"
            },
            {
                "key": "Str",
                "icon": 3,
                "documentation": "The STR() function returns a string made up of a given number of repeated occurrences of another string.",
                "detail": "STR(string {, count})",
                "snippet": "STR(${1:str}, ${2:cnt})"
            },
            {
                "key": "Strs",
                "icon": 3,
                "documentation": "The STRS() function is similar to STR() but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "STR(dyn.arr {, count})",
                "snippet": "STRS(${1:DynArr}, ${2:count})"
            },
            {
                "key": "Subr",
                "icon": 3,
                "documentation": "The SUBR() function calls a subroutine as a function in an expression. It is normally only used in dictionary I-type items.",
                "detail": "SUBR(name {,arg1 {, arg2...})",
                "snippet": "SUBR(${1:name}, ${2:args})"
            },
            {
                "key": "Subroutine",
                "icon": 14,
                "documentation": "The SUBROUTINE statement introduces a subroutine. The abbreviation SUB may be used.",
                "detail": "SUBROUTINE name{(arg1 {, arg2...}) {VAR.ARGS}}",
                "snippet": "SUBROUTINE ${1:name}(${2:args})"
            },
            {
                "key": "Substitute",
                "icon": 3,
                "documentation": "The SUBSTITUTE() function performs substring replacement on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "SUBSTITUTE(dyn.array, old.list, new.list {, delimiter})",
                "snippet": "SUBSTITUTE(${1:DynArr}, ${2:oldlist}, ${3:newlist}, ${4:delim})"
            },
            {
                "key": "Substrdw",
                "icon": 3,
                "documentation": "The SUBSTRDW() function extracts a substring based on its display width.",
                "detail": "SUBSTRDW(string, start, length)",
                "snippet": "SUBSTRDW(${1:str}, ${2:start}, ${3:length})"
            },
            {
                "key": "Substrdws",
                "icon": 3,
                "documentation": "The SUBSTRDWS() function is similar to the SUBSTRDW() function but operates on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "SUBSTRDWS(string, start, length)",
                "snippet": "SUBSTRDWS(${1:str}, ${2:start}, ${3:length})"
            },
            {
                "key": "Substrings",
                "icon": 3,
                "documentation": "The SUBSTRINGS() function performs substring extraction on successive elements of a dynamic array, returning a similarly structured dynamic array of results.",
                "detail": "SUBSTRINGS(dyn.array, start, length)",
                "snippet": "SUBSTRINGS(${1:DynArr}, ${2:start}, ${3:length})"
            },
            {
                "key": "Sum",
                "icon": 3,
                "documentation": "The SUM() function eliminates the lowest level of a dynamic array by adding the elements to form an item of the next highest level.",
                "detail": "SUM(expr)",
                "snippet": "SUM(${1:DynArr})"
            },
            {
                "key": "Summation",
                "icon": 3,
                "documentation": "The SUMMATION() function returns the total value of all elements of a numeric array.",
                "detail": "SUMMATION(expr)",
                "snippet": "SUMMATION(${1:expr})"
            },
            {
                "key": "Swap",
                "icon": 3,
                "documentation": "The CHANGE() function replaces occurrences of a substring within a string by another substring. The synonym SWAP() can be used.",
                "detail": "SWAP(string, old, new{, occurrence{, start}})",
                "snippet": "SWAP(${1:string}, ${2:old}, ${3:new}, ${4:occurrence}, ${5:start})"
            },
            {
                "key": "Swapcase",
                "icon": 3,
                "documentation": "The SWAPCASE() function inverts the case of all alphabetic characters in a string.",
                "detail": "SWAPCASE(string)",
                "snippet": "SWAPCASE(${1:str})"
            },
            {
                "key": "Swapmarks",
                "icon": 3,
                "documentation": "The SWAPMARKS() function interchanges the mark characters with the Unicode characters that they have displaced in a string.",
                "detail": "SWAPMARKS(string)",
                "snippet": "SWAPMARKS(${1:str})"
            },
            {
                "key": "Sysmsg",
                "icon": 3,
                "documentation": "The SYSMSG() function returns a message text from the MESSAGES file.",
                "detail": "SYSMSG(key {, args...})",
                "snippet": "SYSMSG(${1:key}, ${2:args})"
            },
            {
                "key": "System",
                "icon": 3,
                "documentation": "The SYSTEM() function returns information regarding the status of various aspects of the system.",
                "detail": "SYSTEM(key)",
                "snippet": "SYSTEM(${1:key})"
            },
            {
                "key": "Tan",
                "icon": 3,
                "documentation": "The TAN() function returns the tangent of a value.",
                "detail": "TAN(expr)",
                "snippet": "TAN(${1:expression})"
            },
            {
                "key": "Tclread",
                "icon": 14,
                "documentation": "The TCLREAD statement retrieves the sentence that started the current program.",
                "detail": "TCLREAD var",
                "snippet": "TCLREAD ${1:var}"
            },
            {
                "key": "Terminfo",
                "icon": 3,
                "documentation": "The TERMINFO() function returns information from the terminfo database.",
                "detail": "TERMINFO()\nTERMINFO(cap.name)",
                "snippet": "TERMINFO(${1:capname})"
            },
            {
                "key": "Terminfo.Ex",
                "icon": 3,
                "documentation": "The TERMINFO.EX() function returns extended data from the terminfo database.",
                "detail": "TERMINFO.EX()\nTERMINFO.EX(cap.name)",
                "snippet": "TERMINFO.EX(${1:capname})"
            },
            {
                "key": "Testlock",
                "icon": 3,
                "documentation": "The TESTLOCK() function returns the state of a task lock.",
                "detail": "TESTLOCK(lock.num)",
                "snippet": "TESTLOCK(${1:locknum})"
            },
            {
                "key": "Throw",
                "icon": 14,
                "documentation": "The THROW statement throws an exception that can be caught in a TRY \/ CATCH construct.",
                "detail": "THROW exception {, data}",
                "snippet": "THROW ${1:exception}, ${2:data}"
            },
            {
                "key": "Time",
                "icon": 3,
                "documentation": "The TIME() function returns the current time as the number of seconds since midnight.",
                "detail": "TIME()",
                "snippet": "TIME()"
            },
            {
                "key": "Timedate",
                "icon": 3,
                "documentation": "The TIMEDATE() function returns the current time and date as a string.",
                "detail": "TIMEDATE()",
                "snippet": "TIMEDATE()"
            },
            {
                "key": "Timeout",
                "icon": 14,
                "documentation": "The TIMEOUT statement sets a timeout for READBLK and READSEQ.",
                "detail": "TIMEOUT file.var, interval",
                "snippet": "TIMEOUT ${1:filevar}, ${2:time}"
            },
            {
                "key": "Total",
                "icon": 14,
                "documentation": "The TOTAL() function accumulates totals for use with the CALC query processor keyword. It is only available in dictionary I-type items.",
                "detail": "TOTAL($expr)",
                "snippet": "TOTAL(${1:expr})"
            },
            {
                "key": "Trans",
                "icon": 3,
                "documentation": "The TRANS() function returns a field or the entire record from a named data file. It is normally only used in dictionary I-type items. The synonym XLATE() may be used.",
                "detail": "TRANS({DICT} file.name, record.id, field, action)",
                "snippet": "TRANS(${1:filename}, ${2:key}, ${3:field}, ${4:actioncode})"
            },
            {
                "key": "Transaction Abort",
                "icon": 14,
                "documentation": "The TRANSACTION ABORT statement terminates the transaction, discarding any cached updates. Execution continues at the statement following the TRANSACTION ABORT.",
                "detail": "TRANSACTION ABORT",
                "snippet": "TRANSACTION ABORT"
            },
            {
                "key": "Transaction Commit",
                "icon": 14,
                "documentation": "This statement is used to mark the end of a successfully completed transaction.",
                "detail": "TRANSACTION COMMIT THEN {statements} ELSE {statements}",
                "snippet": "TRANSACTION COMMIT THEN\n\t${1:then_statements}\nEND ELSE\n\t${2:else_statements}\nEND"
            },
            {
                "key": "Transaction Start",
                "icon": 14,
                "documentation": "The TRANSACTION START statement starts a new transaction. All updates within the transaction are cached and only applied to the database when the TRANSACTION COMMIT statement is executed.",
                "detail": "TRANSACTION START THEN {statements} ELSE {statements}",
                "snippet": "TRANSACTION START THEN\n\t${1:then_statements}\nEND ELSE\n\t${2:else_statements}\nEND"
            },
            {
                "key": "Transliterate",
                "icon": 3,
                "documentation": "The TRANSLITERATE() function returns a transliterated version of a character string containing only 8 bit characters.",
                "detail": "TRANSLITERATE(string)",
                "snippet": "TRANSLITERATE(${1:str})"
            },
            {
                "key": "Trim",
                "icon": 3,
                "documentation": "The TRIM() function removes excess characters from a string.",
                "detail": "TRIM(string)\nTRIM(string, character{, mode})",
                "snippet": "TRIM(${1:str}, ${2:char}, ${3:mode})"
            },
            {
                "key": "Trimb",
                "icon": 3,
                "documentation": "The TRIMB() function removes excess spaces from the back of a string.",
                "detail": "TRIMB(string)",
                "snippet": "TRIMB(${1:str})"
            },
            {
                "key": "Trimbs",
                "icon": 3,
                "documentation": "The TRIMBS() function is similar to TRIMB() but operates on each element of a dynamic array and returns an equivalently structured dynamic array of trimmed strings.",
                "detail": "TRIMBS(dyn.arr)",
                "snippet": "TRIMBS(${1:DynArr})"
            },
            {
                "key": "Trimf",
                "icon": 3,
                "documentation": "The TRIMF() function removes excess spaces from the front of a string.",
                "detail": "TRIMF(string)",
                "snippet": "TRIMF(${1:str})"
            },
            {
                "key": "Trimfs",
                "icon": 3,
                "documentation": "The TRIMFS() function is similar to TRIMF() but operates on each element of a dynamic array and returns an equivalently structured dynamic array of trimmed strings.",
                "detail": "TRIMFS(dyn.arr)",
                "snippet": "TRIMFS(${1:DynArr})"
            },
            {
                "key": "Trims",
                "icon": 3,
                "documentation": "The TRIMS() function removes excess characters from strings in a dynamic array, operating on each element in turn and returning an equivalently structured dynamic array of trimmed strings.",
                "detail": "TRIMS(string)\nTRIMS(string, character{, mode})",
                "snippet": "TRIMS(${1:str}, ${2:char}, ${3:mode})"
            },
            {
                "key": "Trimw",
                "icon": 3,
                "documentation": "The TRIMW() function removes excess whitespace characters from a string.",
                "detail": "TRIMW(string)",
                "snippet": "TRIMW(${1:str})"
            },
            {
                "key": "Trimws",
                "icon": 3,
                "documentation": "The TRIMWS() function is similar to TRIMW() but operates on each element of a dynamic array and returns an equivalently structured dynamic array of trimmed strings.",
                "detail": "TRIMWS(dyn.arr)",
                "snippet": "TRIMWS(${1:dynarr})"
            },
            {
                "key": "Try",
                "icon": 14,
                "documentation": "The TRY\/CATCH construct allows creation of exception handlers in a manner broadly similar to that of some other programming languages.",
                "detail": "TRY {statement}\n{statements}\nCATCH exception {qualifiers}{, exception {qualifiers}...}\n{statements}\nCATCH exception {qualifiers}{, exception {qualifiers}...}\n{statements}\nEND",
                "snippet": "TRY \n\t${1:try_statements}\nCATCH ${2:exception}\n\t${3:catch_statements}}\nEND"
            },
            {
                "key": "Ttyget",
                "icon": 3,
                "documentation": "The TTYGET() function returns a dynamic array containing the current terminal settings.",
                "detail": "TTYGET()",
                "snippet": "TTYGET()"
            },
            {
                "key": "Ttyset",
                "icon": 3,
                "documentation": "The TTYSET statement sets the terminal modes.",
                "detail": "TTYSET var",
                "snippet": "TTYSET ${1:var}"
            },
            {
                "key": "Unassigned",
                "icon": 3,
                "documentation": "The UNASSIGNED() function tests whether a variable is unassigned.",
                "detail": "UNASSIGNED(var)",
                "snippet": "UNASSIGNED(${1:variable})"
            },
            {
                "key": "Unlock",
                "icon": 14,
                "documentation": "The UNLOCK statement releases one of 64 system wide task locks.",
                "detail": "UNLOCK {lock.num} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "UNLOCK ${1:locknum} THEN\n\t${2:then_statements}\nEND ELSE\n\t${3:else_statements}\nEND"
            },
            {
                "key": "Until",
                "icon": 14,
                "documentation": "The UNTIL statement is used in conjunction with the FOR \/ NEXT or LOOP \/ REPEAT constructs to determine whether execution of the loop should continue.",
                "detail": "UNTIL expr",
                "snippet": "UNTIL ${1:expr}"
            },
            {
                "key": "Upcase",
                "icon": 3,
                "documentation": "The UPCASE() function returns a string with all letters converted to upper case.",
                "detail": "UPCASE(string)",
                "snippet": "UPCASE(${1:str})"
            },
            {
                "key": "Vartype",
                "icon": 3,
                "documentation": "The VARTYPE() function returns a value indicating the data type associated with a variable.",
                "detail": "VARTYPE(variable)",
                "snippet": "VARTYPE(${1:var})"
            },
            {
                "key": "Vocpath",
                "icon": 3,
                "documentation": "The VOCPATH() function returns the pathname for a file referenced via the VOC.",
                "detail": "VOCPATH(filename {, dict.flag})",
                "snippet": "VOCPATH(${1:filename}, ${2:dictflag})"
            },
            {
                "key": "Void",
                "icon": 14,
                "documentation": "The VOID statement discards the result of an associated expression.",
                "detail": "VOID expr",
                "snippet": "VOID ${1:expr}"
            },
            {
                "key": "Vslice",
                "icon": 3,
                "documentation": "The VSLICE() function returns a string formed by extracting a given value or subvalue position from a dynamic array.",
                "detail": "VSLICE(string, vpos)\nVSLICE(string, vpos, svpos)",
                "snippet": "VSLICE(${1:str}, ${2:vpos}, ${3:svpos})"
            },
            {
                "key": "Wait.File.Event",
                "icon": 3,
                "documentation": "The WAIT.FILE.EVENT() function waits for a file monitoring event (Windows only).",
                "detail": "WAIT.FILE.EVENT(event, timeout)",
                "snippet": "WAIT.FILE.EVENT(${1:event}, ${2:timeout})"
            },
            {
                "key": "Wake",
                "icon": 14,
                "documentation": "The WAKE statement awakens another process that has executed a PAUSE.",
                "detail": "WAKE user.no",
                "snippet": "WAKE ${1:userno}"
            },
            {
                "key": "Weofseq",
                "icon": 14,
                "documentation": "The WEOFSEQ statement truncates a record open for sequential access at the current position.",
                "detail": "WEOFSEQ file.var {ON ERROR statement(s)}",
                "snippet": "WEOFSEQ ${1:filevar} ON ERROR ${2:err_statements}"
            },
            {
                "key": "While",
                "icon": 14,
                "documentation": "The WHILE statement is used in conjunction with the FOR \/ NEXT or LOOP \/ REPEAT constructs to determine whether execution of the loop should continue.",
                "detail": "WHILE expr",
                "snippet": "WHILE ${1:expr}"
            },
            {
                "key": "Write",
                "icon": 14,
                "documentation": "The WRITE statement writes a record to a previously opened file.",
                "detail": "WRITE var {ENCODING name} TO file.var, record.id {ON ERROR statement(s)}\nWRITE var {ENCODING name} TO file.var CREATING.SEQKEY id.var {ON ERROR statement(s)}",
                "snippet": "WRITE ${1:var} TO ${2:filevar},${3:recordkey}"
            },
            {
                "key": "Write.Socket",
                "icon": 14,
                "documentation": "The WRITE.SOCKET() function writes data to a socket.",
                "detail": "WRITE.SOCKET(skt, data, flags, timeout)",
                "snippet": "WRITE.SOCKET(${1:skt}, ${2:data}, ${3:flags}, ${4:timeout})"
            },
            {
                "key": "Writeblk",
                "icon": 14,
                "documentation": "The WRITEBLK statement writes data at the current file position in a record previously opened using OPENSEQ.",
                "detail": "WRITEBLK var {ENCODING name} TO file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "WRITEBLK ${1:var} ${2:ENCODING} TO ${3:filevar} ON ERROR ${4:err_statements} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Writecsv",
                "icon": 14,
                "documentation": "The WRITECSV statement writes data at the current file position in a record previously opened using OPENSEQ. The data to be written is assembled from one or more variables and written in CSV format.",
                "detail": "WRITECSV var1, var2, ... {ENCODING name} TO file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "WRITECSV ${1:vars} ENCODING ${2:name} TO ${3:filevar} ON ERROR ${4:err_statements} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Writelist",
                "icon": 14,
                "documentation": "The WRITELIST statement writes a dynamic array to the $SAVEDLISTS file.",
                "detail": "WRITELIST ids TO list.name",
                "snippet": "WRITELIST ${1:ids} TO ${2:listname}"
            },
            {
                "key": "Writeseq",
                "icon": 14,
                "documentation": "The WRITESEQ statement writes a string array to a directory file record previously opened for sequential access.",
                "detail": "WRITESEQ var {ENCODING name} TO file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "WRITESEQ ${1:var} ENCODING ${2:name} TO ${3:filevar} ON ERROR ${4:err_statements} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Writeseqf",
                "icon": 14,
                "documentation": "The WRITESEQF statement is identical to the WRIRESEQ statement except that it force writes the data to disk",
                "detail": "WRITESEQF var {ENCODING name} TO file.var {ON ERROR statement(s)} {THEN statement(s)} {ELSE statement(s)}",
                "snippet": "WRITESEQF ${1:var} ENCODING ${2:name} TO ${3:filevar} ON ERROR ${4:err_statements} THEN\n\t${5:then_statements}\nEND ELSE\n\t${6:else_statements}\nEND"
            },
            {
                "key": "Writeu",
                "icon": 14,
                "documentation": "The WRITEU statement is identical to the WRITE statement but preserves any lock on the record.",
                "detail": "WRITEU var {ENCODING name} TO file.var, record.id {ON ERROR statement(s)}\nWRITEU var {ENCODING name} TO file.var CREATING.SEQKEY id.var {ON ERROR statement(s)}",
                "snippet": "WRITEU ${1:var} TO ${2:filevar},${3:recordkey}"
            },
            {
                "key": "Writev",
                "icon": 14,
                "documentation": "The WRITEV statement writes a specific field to a record of a previously opened file.",
                "detail": "WRITEV var {ENCODING name} TO file.var, record.id, field.expr {ON ERROR statement(s)}",
                "snippet": "WRITEV ${1:var} TO ${2:filevar},${3:recordkey},${4:attr}"
            },
            {
                "key": "Writevu",
                "icon": 14,
                "documentation": "The WRITEVU statement is identical to the WRITEV statement but preserves any lock on the record.",
                "detail": "WRITEVU var {ENCODING name} TO file.var, record.id, field.expr {ON ERROR statement(s)}",
                "snippet": "WRITEVU ${1:var} TO ${2:filevar},${3:recordkey},${4:attr}"
            },
            {
                "key": "Xlate",
                "icon": 3,
                "documentation": "The XLATE() function returns a field or the entire record from a named data file. It is normally only used in dictionary I-type items. ",
                "detail": "XLATE({DICT} file.name, record.id, field, action)",
                "snippet": "XLATE(${1:filename}, ${2:recordid}, ${3:field}, ${4:action})"
            },
            {
                "key": "Xtd",
                "icon": 3,
                "documentation": "The XTD() function converts a string of hexadecimal characters to a number.",
                "detail": "XTD(expr)",
                "snippet": "XTD(${1:expr})"
            },
            {
                "key": "Xtrans",
                "icon": 3,
                "documentation": "The TRANS() function returns a field or the entire record from a named data file. It is normally only used in dictionary I-type items. The synonym XLATE() may be used.",
                "detail": "XTRANS($filename, $key, $field, $actioncode)",
                "snippet": "XTRANS(${1:filename}, ${2:key}, ${3:field}, ${4:actioncode})"
            }
        ]
    }
}
